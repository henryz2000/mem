{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {import('./infer.js').Align} Align\n */\nvar alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n}; // To do: next major: expose functions.\n// To do: next major: use `infer` here, when all events are exposed.\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions` to support\n * GFM tables when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\n\nexport var gfmTableHtml = {\n  enter: {\n    table: function table(token) {\n      /** @type {Array<Align>} */\n      // @ts-expect-error Custom.\n      var tableAlign = token._align;\n      this.lineEndingIfNeeded();\n      this.tag('<table>');\n      this.setData('tableAlign', tableAlign);\n    },\n    tableBody: function tableBody() {\n      this.tag('<tbody>');\n    },\n    tableData: function tableData() {\n      var tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      var tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n      var align = alignment[tableAlign[tableColumn]];\n\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer();\n      } else {\n        this.lineEndingIfNeeded();\n        this.tag('<td' + align + '>');\n      }\n    },\n    tableHead: function tableHead() {\n      this.lineEndingIfNeeded();\n      this.tag('<thead>');\n    },\n    tableHeader: function tableHeader() {\n      var tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      var tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n      var align = alignment[tableAlign[tableColumn]];\n      this.lineEndingIfNeeded();\n      this.tag('<th' + align + '>');\n    },\n    tableRow: function tableRow() {\n      this.setData('tableColumn', 0);\n      this.lineEndingIfNeeded();\n      this.tag('<tr>');\n    }\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData: function codeTextData(token) {\n      var value = this.sliceSerialize(token);\n\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace);\n      }\n\n      this.raw(this.encode(value));\n    },\n    table: function table() {\n      this.setData('tableAlign'); // Note: we don’t set `slurpAllLineEndings` anymore, in delimiter rows,\n      // but we do need to reset it to match a funky newline GH generates for\n      // list items combined with tables.\n\n      this.setData('slurpAllLineEndings');\n      this.lineEndingIfNeeded();\n      this.tag('</table>');\n    },\n    tableBody: function tableBody() {\n      this.lineEndingIfNeeded();\n      this.tag('</tbody>');\n    },\n    tableData: function tableData() {\n      var tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      var tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n\n      if (tableColumn in tableAlign) {\n        this.tag('</td>');\n        this.setData('tableColumn', tableColumn + 1);\n      } else {\n        // Stop capturing.\n        this.resume();\n      }\n    },\n    tableHead: function tableHead() {\n      this.lineEndingIfNeeded();\n      this.tag('</thead>');\n    },\n    tableHeader: function tableHeader() {\n      var tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n      this.tag('</th>');\n      this.setData('tableColumn', tableColumn + 1);\n    },\n    tableRow: function tableRow() {\n      var tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      var tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n\n      while (tableColumn < tableAlign.length) {\n        this.lineEndingIfNeeded();\n        this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>');\n        tableColumn++;\n      }\n\n      this.setData('tableColumn', tableColumn);\n      this.lineEndingIfNeeded();\n      this.tag('</tr>');\n    }\n  }\n};\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0;\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/micromark-extension-gfm-table/lib/html.js"],"names":["alignment","none","left","right","center","gfmTableHtml","enter","table","token","tableAlign","_align","lineEndingIfNeeded","tag","setData","tableBody","tableData","getData","tableColumn","align","undefined","buffer","tableHead","tableHeader","tableRow","exit","codeTextData","value","sliceSerialize","replace","raw","encode","resume","length","$0","$1"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {import('./infer.js').Align} Align\n */\n\nconst alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n}\n\n// To do: next major: expose functions.\n// To do: next major: use `infer` here, when all events are exposed.\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions` to support\n * GFM tables when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmTableHtml = {\n  enter: {\n    table(token) {\n      /** @type {Array<Align>} */\n      // @ts-expect-error Custom.\n      const tableAlign = token._align\n      this.lineEndingIfNeeded()\n      this.tag('<table>')\n      this.setData('tableAlign', tableAlign)\n    },\n    tableBody() {\n      this.tag('<tbody>')\n    },\n    tableData() {\n      const tableAlign = /** @type {Array<Align>} */ this.getData('tableAlign')\n      const tableColumn = /** @type {number} */ this.getData('tableColumn')\n      const align = alignment[tableAlign[tableColumn]]\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer()\n      } else {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + align + '>')\n      }\n    },\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('<thead>')\n    },\n    tableHeader() {\n      const tableAlign = /** @type {Array<Align>} */ this.getData('tableAlign')\n      const tableColumn = /** @type {number} */ this.getData('tableColumn')\n      const align = alignment[tableAlign[tableColumn]]\n      this.lineEndingIfNeeded()\n      this.tag('<th' + align + '>')\n    },\n    tableRow() {\n      this.setData('tableColumn', 0)\n      this.lineEndingIfNeeded()\n      this.tag('<tr>')\n    }\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token)\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace)\n      }\n      this.raw(this.encode(value))\n    },\n    table() {\n      this.setData('tableAlign')\n      // Note: we don’t set `slurpAllLineEndings` anymore, in delimiter rows,\n      // but we do need to reset it to match a funky newline GH generates for\n      // list items combined with tables.\n      this.setData('slurpAllLineEndings')\n      this.lineEndingIfNeeded()\n      this.tag('</table>')\n    },\n    tableBody() {\n      this.lineEndingIfNeeded()\n      this.tag('</tbody>')\n    },\n    tableData() {\n      const tableAlign = /** @type {Array<Align>} */ this.getData('tableAlign')\n      const tableColumn = /** @type {number} */ this.getData('tableColumn')\n      if (tableColumn in tableAlign) {\n        this.tag('</td>')\n        this.setData('tableColumn', tableColumn + 1)\n      } else {\n        // Stop capturing.\n        this.resume()\n      }\n    },\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('</thead>')\n    },\n    tableHeader() {\n      const tableColumn = /** @type {number} */ this.getData('tableColumn')\n      this.tag('</th>')\n      this.setData('tableColumn', tableColumn + 1)\n    },\n    tableRow() {\n      const tableAlign = /** @type {Array<Align>} */ this.getData('tableAlign')\n      let tableColumn = /** @type {number} */ this.getData('tableColumn')\n      while (tableColumn < tableAlign.length) {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>')\n        tableColumn++\n      }\n      this.setData('tableColumn', tableColumn)\n      this.lineEndingIfNeeded()\n      this.tag('</tr>')\n    }\n  }\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n"]},"metadata":{},"sourceType":"module"}