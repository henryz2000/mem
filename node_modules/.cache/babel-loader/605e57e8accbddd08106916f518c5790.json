{"ast":null,"code":"// @ts-nocheck\nimport refractorCsharp from './csharp.js';\nimport refractorMarkup from './markup.js';\ncshtml.displayName = 'cshtml';\ncshtml.aliases = ['razor'];\n/** @type {import('../core.js').Syntax} */\n\nexport default function cshtml(Prism) {\n  Prism.register(refractorCsharp);\n  Prism.register(refractorMarkup) // Docs:\n  // https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-5.0&tabs=visual-studio\n  // https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-5.0\n  ;\n\n  (function (Prism) {\n    var commentLike = /\\/(?![/*])|\\/\\/.*[\\r\\n]|\\/\\*[^*]*(?:\\*(?!\\/)[^*]*)*\\*\\//.source;\n    var stringLike = /@(?!\")|\"(?:[^\\r\\n\\\\\"]|\\\\.)*\"|@\"(?:[^\\\\\"]|\"\"|\\\\[\\s\\S])*\"(?!\")/.source + '|' + /'(?:(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'|(?=[^\\\\](?!')))/.source;\n    /**\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n     *\n     * @param {string} pattern\n     * @param {number} depthLog2\n     * @returns {string}\n     */\n\n    function nested(pattern, depthLog2) {\n      for (var i = 0; i < depthLog2; i++) {\n        pattern = pattern.replace(/<self>/g, function () {\n          return '(?:' + pattern + ')';\n        });\n      }\n\n      return pattern.replace(/<self>/g, '[^\\\\s\\\\S]').replace(/<str>/g, '(?:' + stringLike + ')').replace(/<comment>/g, '(?:' + commentLike + ')');\n    }\n\n    var round = nested(/\\((?:[^()'\"@/]|<str>|<comment>|<self>)*\\)/.source, 2);\n    var square = nested(/\\[(?:[^\\[\\]'\"@/]|<str>|<comment>|<self>)*\\]/.source, 1);\n    var curly = nested(/\\{(?:[^{}'\"@/]|<str>|<comment>|<self>)*\\}/.source, 2);\n    var angle = nested(/<(?:[^<>'\"@/]|<comment>|<self>)*>/.source, 1);\n    var inlineCs = /@/.source + /(?:await\\b\\s*)?/.source + '(?:' + /(?!await\\b)\\w+\\b/.source + '|' + round + ')' + '(?:' + /[?!]?\\.\\w+\\b/.source + '|' + '(?:' + angle + ')?' + round + '|' + square + ')*' + /(?![?!\\.(\\[]|<(?!\\/))/.source; // Note about the above bracket patterns:\n    // They all ignore HTML expressions that might be in the C# code. This is a problem because HTML (like strings and\n    // comments) is parsed differently. This is a huge problem because HTML might contain brackets and quotes which\n    // messes up the bracket and string counting implemented by the above patterns.\n    //\n    // This problem is not fixable because 1) HTML expression are highly context sensitive and very difficult to detect\n    // and 2) they require one capturing group at every nested level. See the `tagRegion` pattern to admire the\n    // complexity of an HTML expression.\n    //\n    // To somewhat alleviate the problem a bit, the patterns for characters (e.g. 'a') is very permissive, it also\n    // allows invalid characters to support HTML expressions like this: <p>That's it!</p>.\n\n    var tagAttrInlineCs = /@(?![\\w()])/.source + '|' + inlineCs;\n    var tagAttrValue = '(?:' + /\"[^\"@]*\"|'[^'@]*'|[^\\s'\"@>=]+(?=[\\s>])/.source + '|' + '[\"\\'][^\"\\'@]*(?:(?:' + tagAttrInlineCs + ')[^\"\\'@]*)+[\"\\']' + ')';\n    var tagAttrs = /(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*<tagAttrValue>|(?=[\\s/>])))+)?/.source.replace(/<tagAttrValue>/, tagAttrValue);\n    var tagContent = /(?!\\d)[^\\s>\\/=$<%]+/.source + tagAttrs + /\\s*\\/?>/.source;\n    var tagRegion = /\\B@?/.source + '(?:' + /<([a-zA-Z][\\w:]*)/.source + tagAttrs + /\\s*>/.source + '(?:' + (/[^<]/.source + '|' + // all tags that are not the start tag\n    // eslint-disable-next-line regexp/strict\n    /<\\/?(?!\\1\\b)/.source + tagContent + '|' + // nested start tag\n    nested( // eslint-disable-next-line regexp/strict\n    /<\\1/.source + tagAttrs + /\\s*>/.source + '(?:' + (/[^<]/.source + '|' + // all tags that are not the start tag\n    // eslint-disable-next-line regexp/strict\n    /<\\/?(?!\\1\\b)/.source + tagContent + '|' + '<self>') + ')*' + // eslint-disable-next-line regexp/strict\n    /<\\/\\1\\s*>/.source, 2)) + ')*' + // eslint-disable-next-line regexp/strict\n    /<\\/\\1\\s*>/.source + '|' + /</.source + tagContent + ')'; // Now for the actual language definition(s):\n    //\n    // Razor as a language has 2 parts:\n    //  1) CSHTML: A markup-like language that has been extended with inline C# code expressions and blocks.\n    //  2) C#+HTML: A variant of C# that can contain CSHTML tags as expressions.\n    //\n    // In the below code, both CSHTML and C#+HTML will be create as separate language definitions that reference each\n    // other. However, only CSHTML will be exported via `Prism.languages`.\n\n    Prism.languages.cshtml = Prism.languages.extend('markup', {});\n    var csharpWithHtml = Prism.languages.insertBefore('csharp', 'string', {\n      html: {\n        pattern: RegExp(tagRegion),\n        greedy: true,\n        inside: Prism.languages.cshtml\n      }\n    }, {\n      csharp: Prism.languages.extend('csharp', {})\n    });\n    var cs = {\n      pattern: /\\S[\\s\\S]*/,\n      alias: 'language-csharp',\n      inside: csharpWithHtml\n    };\n    var inlineValue = {\n      pattern: RegExp(/(^|[^@])/.source + inlineCs),\n      lookbehind: true,\n      greedy: true,\n      alias: 'variable',\n      inside: {\n        keyword: /^@/,\n        csharp: cs\n      }\n    };\n    Prism.languages.cshtml.tag.pattern = RegExp(/<\\/?/.source + tagContent);\n    Prism.languages.cshtml.tag.inside['attr-value'].pattern = RegExp(/=\\s*/.source + tagAttrValue);\n    Prism.languages.insertBefore('inside', 'punctuation', {\n      value: inlineValue\n    }, Prism.languages.cshtml.tag.inside['attr-value']);\n    Prism.languages.insertBefore('cshtml', 'prolog', {\n      'razor-comment': {\n        pattern: /@\\*[\\s\\S]*?\\*@/,\n        greedy: true,\n        alias: 'comment'\n      },\n      block: {\n        pattern: RegExp(/(^|[^@])@/.source + '(?:' + [// @{ ... }\n        curly, // @code{ ... }\n        /(?:code|functions)\\s*/.source + curly, // @for (...) { ... }\n        /(?:for|foreach|lock|switch|using|while)\\s*/.source + round + /\\s*/.source + curly, // @do { ... } while (...);\n        /do\\s*/.source + curly + /\\s*while\\s*/.source + round + /(?:\\s*;)?/.source, // @try { ... } catch (...) { ... } finally { ... }\n        /try\\s*/.source + curly + /\\s*catch\\s*/.source + round + /\\s*/.source + curly + /\\s*finally\\s*/.source + curly, // @if (...) {...} else if (...) {...} else {...}\n        /if\\s*/.source + round + /\\s*/.source + curly + '(?:' + /\\s*else/.source + '(?:' + /\\s+if\\s*/.source + round + ')?' + /\\s*/.source + curly + ')*', // @helper Ident(params) { ... }\n        /helper\\s+\\w+\\s*/.source + round + /\\s*/.source + curly].join('|') + ')'),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^@\\w*/,\n          csharp: cs\n        }\n      },\n      directive: {\n        pattern: /^([ \\t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\\s).*/m,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^@\\w+/,\n          csharp: cs\n        }\n      },\n      value: inlineValue,\n      'delegate-operator': {\n        pattern: /(^|[^@])@(?=<)/,\n        lookbehind: true,\n        alias: 'operator'\n      }\n    });\n    Prism.languages.razor = Prism.languages.cshtml;\n  })(Prism);\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/refractor/lang/cshtml.js"],"names":["refractorCsharp","refractorMarkup","cshtml","displayName","aliases","Prism","register","commentLike","source","stringLike","nested","pattern","depthLog2","i","replace","round","square","curly","angle","inlineCs","tagAttrInlineCs","tagAttrValue","tagAttrs","tagContent","tagRegion","languages","extend","csharpWithHtml","insertBefore","html","RegExp","greedy","inside","csharp","cs","alias","inlineValue","lookbehind","keyword","tag","value","block","join","directive","razor"],"mappings":"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","sourcesContent":["// @ts-nocheck\nimport refractorCsharp from './csharp.js'\nimport refractorMarkup from './markup.js'\ncshtml.displayName = 'cshtml'\ncshtml.aliases = ['razor']\n\n/** @type {import('../core.js').Syntax} */\nexport default function cshtml(Prism) {\n  Prism.register(refractorCsharp)\n  Prism.register(refractorMarkup)\n  // Docs:\n  // https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-5.0&tabs=visual-studio\n  // https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-5.0\n\n  ;(function (Prism) {\n    var commentLike = /\\/(?![/*])|\\/\\/.*[\\r\\n]|\\/\\*[^*]*(?:\\*(?!\\/)[^*]*)*\\*\\//\n      .source\n    var stringLike =\n      /@(?!\")|\"(?:[^\\r\\n\\\\\"]|\\\\.)*\"|@\"(?:[^\\\\\"]|\"\"|\\\\[\\s\\S])*\"(?!\")/.source +\n      '|' +\n      /'(?:(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'|(?=[^\\\\](?!')))/.source\n\n    /**\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n     *\n     * @param {string} pattern\n     * @param {number} depthLog2\n     * @returns {string}\n     */\n    function nested(pattern, depthLog2) {\n      for (var i = 0; i < depthLog2; i++) {\n        pattern = pattern.replace(/<self>/g, function () {\n          return '(?:' + pattern + ')'\n        })\n      }\n      return pattern\n        .replace(/<self>/g, '[^\\\\s\\\\S]')\n        .replace(/<str>/g, '(?:' + stringLike + ')')\n        .replace(/<comment>/g, '(?:' + commentLike + ')')\n    }\n    var round = nested(/\\((?:[^()'\"@/]|<str>|<comment>|<self>)*\\)/.source, 2)\n    var square = nested(/\\[(?:[^\\[\\]'\"@/]|<str>|<comment>|<self>)*\\]/.source, 1)\n    var curly = nested(/\\{(?:[^{}'\"@/]|<str>|<comment>|<self>)*\\}/.source, 2)\n    var angle = nested(/<(?:[^<>'\"@/]|<comment>|<self>)*>/.source, 1)\n    var inlineCs =\n      /@/.source +\n      /(?:await\\b\\s*)?/.source +\n      '(?:' +\n      /(?!await\\b)\\w+\\b/.source +\n      '|' +\n      round +\n      ')' +\n      '(?:' +\n      /[?!]?\\.\\w+\\b/.source +\n      '|' +\n      '(?:' +\n      angle +\n      ')?' +\n      round +\n      '|' +\n      square +\n      ')*' +\n      /(?![?!\\.(\\[]|<(?!\\/))/.source\n\n    // Note about the above bracket patterns:\n    // They all ignore HTML expressions that might be in the C# code. This is a problem because HTML (like strings and\n    // comments) is parsed differently. This is a huge problem because HTML might contain brackets and quotes which\n    // messes up the bracket and string counting implemented by the above patterns.\n    //\n    // This problem is not fixable because 1) HTML expression are highly context sensitive and very difficult to detect\n    // and 2) they require one capturing group at every nested level. See the `tagRegion` pattern to admire the\n    // complexity of an HTML expression.\n    //\n    // To somewhat alleviate the problem a bit, the patterns for characters (e.g. 'a') is very permissive, it also\n    // allows invalid characters to support HTML expressions like this: <p>That's it!</p>.\n\n    var tagAttrInlineCs = /@(?![\\w()])/.source + '|' + inlineCs\n    var tagAttrValue =\n      '(?:' +\n      /\"[^\"@]*\"|'[^'@]*'|[^\\s'\"@>=]+(?=[\\s>])/.source +\n      '|' +\n      '[\"\\'][^\"\\'@]*(?:(?:' +\n      tagAttrInlineCs +\n      ')[^\"\\'@]*)+[\"\\']' +\n      ')'\n    var tagAttrs =\n      /(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*<tagAttrValue>|(?=[\\s/>])))+)?/.source.replace(\n        /<tagAttrValue>/,\n        tagAttrValue\n      )\n    var tagContent = /(?!\\d)[^\\s>\\/=$<%]+/.source + tagAttrs + /\\s*\\/?>/.source\n    var tagRegion =\n      /\\B@?/.source +\n      '(?:' +\n      /<([a-zA-Z][\\w:]*)/.source +\n      tagAttrs +\n      /\\s*>/.source +\n      '(?:' +\n      (/[^<]/.source +\n        '|' +\n        // all tags that are not the start tag\n        // eslint-disable-next-line regexp/strict\n        /<\\/?(?!\\1\\b)/.source +\n        tagContent +\n        '|' +\n        // nested start tag\n        nested(\n          // eslint-disable-next-line regexp/strict\n          /<\\1/.source +\n            tagAttrs +\n            /\\s*>/.source +\n            '(?:' +\n            (/[^<]/.source +\n              '|' +\n              // all tags that are not the start tag\n              // eslint-disable-next-line regexp/strict\n              /<\\/?(?!\\1\\b)/.source +\n              tagContent +\n              '|' +\n              '<self>') +\n            ')*' +\n            // eslint-disable-next-line regexp/strict\n            /<\\/\\1\\s*>/.source,\n          2\n        )) +\n      ')*' +\n      // eslint-disable-next-line regexp/strict\n      /<\\/\\1\\s*>/.source +\n      '|' +\n      /</.source +\n      tagContent +\n      ')'\n\n    // Now for the actual language definition(s):\n    //\n    // Razor as a language has 2 parts:\n    //  1) CSHTML: A markup-like language that has been extended with inline C# code expressions and blocks.\n    //  2) C#+HTML: A variant of C# that can contain CSHTML tags as expressions.\n    //\n    // In the below code, both CSHTML and C#+HTML will be create as separate language definitions that reference each\n    // other. However, only CSHTML will be exported via `Prism.languages`.\n\n    Prism.languages.cshtml = Prism.languages.extend('markup', {})\n    var csharpWithHtml = Prism.languages.insertBefore(\n      'csharp',\n      'string',\n      {\n        html: {\n          pattern: RegExp(tagRegion),\n          greedy: true,\n          inside: Prism.languages.cshtml\n        }\n      },\n      {\n        csharp: Prism.languages.extend('csharp', {})\n      }\n    )\n    var cs = {\n      pattern: /\\S[\\s\\S]*/,\n      alias: 'language-csharp',\n      inside: csharpWithHtml\n    }\n    var inlineValue = {\n      pattern: RegExp(/(^|[^@])/.source + inlineCs),\n      lookbehind: true,\n      greedy: true,\n      alias: 'variable',\n      inside: {\n        keyword: /^@/,\n        csharp: cs\n      }\n    }\n    Prism.languages.cshtml.tag.pattern = RegExp(/<\\/?/.source + tagContent)\n    Prism.languages.cshtml.tag.inside['attr-value'].pattern = RegExp(\n      /=\\s*/.source + tagAttrValue\n    )\n    Prism.languages.insertBefore(\n      'inside',\n      'punctuation',\n      {\n        value: inlineValue\n      },\n      Prism.languages.cshtml.tag.inside['attr-value']\n    )\n    Prism.languages.insertBefore('cshtml', 'prolog', {\n      'razor-comment': {\n        pattern: /@\\*[\\s\\S]*?\\*@/,\n        greedy: true,\n        alias: 'comment'\n      },\n      block: {\n        pattern: RegExp(\n          /(^|[^@])@/.source +\n            '(?:' +\n            [\n              // @{ ... }\n              curly,\n              // @code{ ... }\n              /(?:code|functions)\\s*/.source + curly,\n              // @for (...) { ... }\n              /(?:for|foreach|lock|switch|using|while)\\s*/.source +\n                round +\n                /\\s*/.source +\n                curly,\n              // @do { ... } while (...);\n              /do\\s*/.source +\n                curly +\n                /\\s*while\\s*/.source +\n                round +\n                /(?:\\s*;)?/.source,\n              // @try { ... } catch (...) { ... } finally { ... }\n              /try\\s*/.source +\n                curly +\n                /\\s*catch\\s*/.source +\n                round +\n                /\\s*/.source +\n                curly +\n                /\\s*finally\\s*/.source +\n                curly,\n              // @if (...) {...} else if (...) {...} else {...}\n              /if\\s*/.source +\n                round +\n                /\\s*/.source +\n                curly +\n                '(?:' +\n                /\\s*else/.source +\n                '(?:' +\n                /\\s+if\\s*/.source +\n                round +\n                ')?' +\n                /\\s*/.source +\n                curly +\n                ')*',\n              // @helper Ident(params) { ... }\n              /helper\\s+\\w+\\s*/.source + round + /\\s*/.source + curly\n            ].join('|') +\n            ')'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^@\\w*/,\n          csharp: cs\n        }\n      },\n      directive: {\n        pattern:\n          /^([ \\t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\\s).*/m,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^@\\w+/,\n          csharp: cs\n        }\n      },\n      value: inlineValue,\n      'delegate-operator': {\n        pattern: /(^|[^@])@(?=<)/,\n        lookbehind: true,\n        alias: 'operator'\n      }\n    })\n    Prism.languages.razor = Prism.languages.cshtml\n  })(Prism)\n}\n"]},"metadata":{},"sourceType":"module"}