{"ast":null,"code":"import _toConsumableArray from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @typedef _Token A hidden Prism token\n * @property {string} type\n * @property {string} content\n * @property {string} alias\n * @property {number} length\n *\n * @typedef _Env A hidden Prism environment\n * @property {string} type\n * @property {string} tag\n * @property {Text|RefractorElement|Array<Text|RefractorElement>} content\n * @property {Array<string>} classes\n * @property {Record<string, string>} attributes\n * @property {string} language\n *\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {Omit<Element, 'children'> & {children: Array<RefractorElement|Text>}} RefractorElement\n * @typedef {Omit<Root, 'children'> & {children: Array<RefractorElement|Text>}} RefractorRoot\n *\n * @typedef {import('prismjs').Languages} Languages\n * @typedef {import('prismjs').Grammar} Grammar Whatever this is, Prism handles it.\n * @typedef {((prism: unknown) => void) & {displayName: string, aliases?: Array<string>}} Syntax A refractor syntax function\n *\n * @typedef Refractor Virtual syntax highlighting\n * @property {highlight} highlight\n * @property {alias} alias\n * @property {register} register\n * @property {registered} registered\n * @property {listLanguages} listLanguages\n * @property {Languages} languages\n */\n// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.\n// The wrapped non-leaky grammars are loaded instead of Prism’s originals.\nimport { h } from 'hastscript';\nimport { parseEntities } from 'parse-entities';\nimport { Prism } from './prism-core.js';\nvar own = {}.hasOwnProperty; // Inherit.\n\nfunction Refractor() {}\n\nRefractor.prototype = Prism;\n/** @type {Refractor} */\n// @ts-expect-error: TS is wrong.\n\nexport var refractor = new Refractor(); // Create.\n\nrefractor.highlight = highlight;\nrefractor.register = register;\nrefractor.alias = alias;\nrefractor.registered = registered;\nrefractor.listLanguages = listLanguages; // @ts-expect-error Overwrite Prism.\n\nrefractor.util.encode = encode; // @ts-expect-error Overwrite Prism.\n\nrefractor.Token.stringify = stringify;\n/**\n * Highlight `value` (code) as `language` (programming language).\n *\n * @param {string} value\n *   Code to highlight.\n * @param {string|Grammar} language\n *   Programming language name, alias, or grammar.\n * @returns {RefractorRoot}\n *   Node representing highlighted code.\n */\n\nfunction highlight(value, language) {\n  if (typeof value !== 'string') {\n    throw new TypeError('Expected `string` for `value`, got `' + value + '`');\n  }\n  /** @type {Grammar} */\n\n\n  var grammar;\n  /** @type {string|undefined} */\n\n  var name; // `name` is a grammar object.\n  // This was called internally by Prism.js before 1.28.0.\n\n  /* c8 ignore next 2 */\n\n  if (language && typeof language === 'object') {\n    grammar = language;\n  } else {\n    name = language;\n\n    if (typeof name !== 'string') {\n      throw new TypeError('Expected `string` for `name`, got `' + name + '`');\n    }\n\n    if (own.call(refractor.languages, name)) {\n      grammar = refractor.languages[name];\n    } else {\n      throw new Error('Unknown language: `' + name + '` is not registered');\n    }\n  }\n\n  return {\n    type: 'root',\n    // @ts-expect-error: we hacked Prism to accept and return the things we want.\n    children: Prism.highlight.call(refractor, value, grammar, name)\n  };\n}\n/**\n * Register a syntax.\n *\n * @param {Syntax} syntax\n *   Language function made for refractor, as in, the files in\n *   `refractor/lang/*.js`.\n * @returns {void}\n */\n\n\nfunction register(syntax) {\n  if (typeof syntax !== 'function' || !syntax.displayName) {\n    throw new Error('Expected `function` for `syntax`, got `' + syntax + '`');\n  } // Do not duplicate registrations.\n\n\n  if (!own.call(refractor.languages, syntax.displayName)) {\n    syntax(refractor);\n  }\n}\n/**\n * Register aliases for already registered languages.\n *\n * @param {Record<string, string|Array<string>>|string} language\n * @param {string|Array<string>} [alias]\n * @returns {void}\n */\n\n\nfunction alias(language, alias) {\n  var languages = refractor.languages;\n  /** @type {Record<string, string|Array<string>>} */\n\n  var map = {};\n\n  if (typeof language === 'string') {\n    if (alias) {\n      map[language] = alias;\n    }\n  } else {\n    map = language;\n  }\n  /** @type {string} */\n\n\n  var key;\n\n  for (key in map) {\n    if (own.call(map, key)) {\n      var value = map[key];\n      var list = typeof value === 'string' ? [value] : value;\n      var index = -1;\n\n      while (++index < list.length) {\n        languages[list[index]] = languages[key];\n      }\n    }\n  }\n}\n/**\n * Check whether an `alias` or `language` is registered.\n *\n * @param {string} aliasOrLanguage\n * @returns {boolean}\n */\n\n\nfunction registered(aliasOrLanguage) {\n  if (typeof aliasOrLanguage !== 'string') {\n    throw new TypeError('Expected `string` for `aliasOrLanguage`, got `' + aliasOrLanguage + '`');\n  }\n\n  return own.call(refractor.languages, aliasOrLanguage);\n}\n/**\n * List all registered languages (names and aliases).\n *\n * @returns {Array<string>}\n */\n\n\nfunction listLanguages() {\n  var languages = refractor.languages;\n  /** @type {Array<string>} */\n\n  var list = [];\n  /** @type {string} */\n\n  var language;\n\n  for (language in languages) {\n    if (own.call(languages, language) && typeof languages[language] === 'object') {\n      list.push(language);\n    }\n  }\n\n  return list;\n}\n/**\n * @param {string|_Token|Array<string|_Token>} value\n * @param {string} language\n * @returns {Text|RefractorElement|Array<Text|RefractorElement>}\n */\n\n\nfunction stringify(value, language) {\n  if (typeof value === 'string') {\n    return {\n      type: 'text',\n      value: value\n    };\n  }\n\n  if (Array.isArray(value)) {\n    /** @type {Array<Text|RefractorElement>} */\n    var result = [];\n    var index = -1;\n\n    while (++index < value.length) {\n      if (value[index] !== '' && value[index] !== null && value[index] !== undefined) {\n        // @ts-expect-error Assume no sub-arrays.\n        result.push(stringify(value[index], language));\n      }\n    }\n\n    return result;\n  }\n  /** @type {_Env} */\n\n\n  var env = {\n    type: value.type,\n    content: stringify(value.content, language),\n    tag: 'span',\n    classes: ['token', value.type],\n    attributes: {},\n    language: language\n  };\n\n  if (value.alias) {\n    var _env$classes;\n\n    (_env$classes = env.classes).push.apply(_env$classes, _toConsumableArray(typeof value.alias === 'string' ? [value.alias] : value.alias));\n  } // @ts-expect-error Prism.\n\n\n  refractor.hooks.run('wrap', env); // @ts-expect-error Hush, it’s fine.\n\n  return h(env.tag + '.' + env.classes.join('.'), attributes(env.attributes), env.content);\n}\n/**\n * @template {unknown} T\n * @param {T} tokens\n * @returns {T}\n */\n\n\nfunction encode(tokens) {\n  return tokens;\n}\n/**\n * @param {Record<string, string>} attrs\n * @returns {Record<string, string>}\n */\n\n\nfunction attributes(attrs) {\n  /** @type {string} */\n  var key;\n\n  for (key in attrs) {\n    if (own.call(attrs, key)) {\n      attrs[key] = parseEntities(attrs[key]);\n    }\n  }\n\n  return attrs;\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/refractor/lib/core.js"],"names":["h","parseEntities","Prism","own","hasOwnProperty","Refractor","prototype","refractor","highlight","register","alias","registered","listLanguages","util","encode","Token","stringify","value","language","TypeError","grammar","name","call","languages","Error","type","children","syntax","displayName","map","key","list","index","length","aliasOrLanguage","push","Array","isArray","result","undefined","env","content","tag","classes","attributes","hooks","run","join","tokens","attrs"],"mappings":"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","sourcesContent":["/**\n * @typedef _Token A hidden Prism token\n * @property {string} type\n * @property {string} content\n * @property {string} alias\n * @property {number} length\n *\n * @typedef _Env A hidden Prism environment\n * @property {string} type\n * @property {string} tag\n * @property {Text|RefractorElement|Array<Text|RefractorElement>} content\n * @property {Array<string>} classes\n * @property {Record<string, string>} attributes\n * @property {string} language\n *\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {Omit<Element, 'children'> & {children: Array<RefractorElement|Text>}} RefractorElement\n * @typedef {Omit<Root, 'children'> & {children: Array<RefractorElement|Text>}} RefractorRoot\n *\n * @typedef {import('prismjs').Languages} Languages\n * @typedef {import('prismjs').Grammar} Grammar Whatever this is, Prism handles it.\n * @typedef {((prism: unknown) => void) & {displayName: string, aliases?: Array<string>}} Syntax A refractor syntax function\n *\n * @typedef Refractor Virtual syntax highlighting\n * @property {highlight} highlight\n * @property {alias} alias\n * @property {register} register\n * @property {registered} registered\n * @property {listLanguages} listLanguages\n * @property {Languages} languages\n */\n\n// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.\n// The wrapped non-leaky grammars are loaded instead of Prism’s originals.\nimport {h} from 'hastscript'\nimport {parseEntities} from 'parse-entities'\nimport {Prism} from './prism-core.js'\n\nconst own = {}.hasOwnProperty\n\n// Inherit.\nfunction Refractor() {}\n\nRefractor.prototype = Prism\n\n/** @type {Refractor} */\n// @ts-expect-error: TS is wrong.\nexport const refractor = new Refractor()\n\n// Create.\nrefractor.highlight = highlight\nrefractor.register = register\nrefractor.alias = alias\nrefractor.registered = registered\nrefractor.listLanguages = listLanguages\n\n// @ts-expect-error Overwrite Prism.\nrefractor.util.encode = encode\n// @ts-expect-error Overwrite Prism.\nrefractor.Token.stringify = stringify\n\n/**\n * Highlight `value` (code) as `language` (programming language).\n *\n * @param {string} value\n *   Code to highlight.\n * @param {string|Grammar} language\n *   Programming language name, alias, or grammar.\n * @returns {RefractorRoot}\n *   Node representing highlighted code.\n */\nfunction highlight(value, language) {\n  if (typeof value !== 'string') {\n    throw new TypeError('Expected `string` for `value`, got `' + value + '`')\n  }\n\n  /** @type {Grammar} */\n  let grammar\n  /** @type {string|undefined} */\n  let name\n\n  // `name` is a grammar object.\n  // This was called internally by Prism.js before 1.28.0.\n  /* c8 ignore next 2 */\n  if (language && typeof language === 'object') {\n    grammar = language\n  } else {\n    name = language\n\n    if (typeof name !== 'string') {\n      throw new TypeError('Expected `string` for `name`, got `' + name + '`')\n    }\n\n    if (own.call(refractor.languages, name)) {\n      grammar = refractor.languages[name]\n    } else {\n      throw new Error('Unknown language: `' + name + '` is not registered')\n    }\n  }\n\n  return {\n    type: 'root',\n    // @ts-expect-error: we hacked Prism to accept and return the things we want.\n    children: Prism.highlight.call(refractor, value, grammar, name)\n  }\n}\n\n/**\n * Register a syntax.\n *\n * @param {Syntax} syntax\n *   Language function made for refractor, as in, the files in\n *   `refractor/lang/*.js`.\n * @returns {void}\n */\nfunction register(syntax) {\n  if (typeof syntax !== 'function' || !syntax.displayName) {\n    throw new Error('Expected `function` for `syntax`, got `' + syntax + '`')\n  }\n\n  // Do not duplicate registrations.\n  if (!own.call(refractor.languages, syntax.displayName)) {\n    syntax(refractor)\n  }\n}\n\n/**\n * Register aliases for already registered languages.\n *\n * @param {Record<string, string|Array<string>>|string} language\n * @param {string|Array<string>} [alias]\n * @returns {void}\n */\nfunction alias(language, alias) {\n  const languages = refractor.languages\n  /** @type {Record<string, string|Array<string>>} */\n  let map = {}\n\n  if (typeof language === 'string') {\n    if (alias) {\n      map[language] = alias\n    }\n  } else {\n    map = language\n  }\n\n  /** @type {string} */\n  let key\n\n  for (key in map) {\n    if (own.call(map, key)) {\n      const value = map[key]\n      const list = typeof value === 'string' ? [value] : value\n      let index = -1\n\n      while (++index < list.length) {\n        languages[list[index]] = languages[key]\n      }\n    }\n  }\n}\n\n/**\n * Check whether an `alias` or `language` is registered.\n *\n * @param {string} aliasOrLanguage\n * @returns {boolean}\n */\nfunction registered(aliasOrLanguage) {\n  if (typeof aliasOrLanguage !== 'string') {\n    throw new TypeError(\n      'Expected `string` for `aliasOrLanguage`, got `' + aliasOrLanguage + '`'\n    )\n  }\n\n  return own.call(refractor.languages, aliasOrLanguage)\n}\n\n/**\n * List all registered languages (names and aliases).\n *\n * @returns {Array<string>}\n */\nfunction listLanguages() {\n  const languages = refractor.languages\n  /** @type {Array<string>} */\n  const list = []\n  /** @type {string} */\n  let language\n\n  for (language in languages) {\n    if (\n      own.call(languages, language) &&\n      typeof languages[language] === 'object'\n    ) {\n      list.push(language)\n    }\n  }\n\n  return list\n}\n\n/**\n * @param {string|_Token|Array<string|_Token>} value\n * @param {string} language\n * @returns {Text|RefractorElement|Array<Text|RefractorElement>}\n */\nfunction stringify(value, language) {\n  if (typeof value === 'string') {\n    return {type: 'text', value}\n  }\n\n  if (Array.isArray(value)) {\n    /** @type {Array<Text|RefractorElement>} */\n    const result = []\n    let index = -1\n\n    while (++index < value.length) {\n      if (\n        value[index] !== '' &&\n        value[index] !== null &&\n        value[index] !== undefined\n      ) {\n        // @ts-expect-error Assume no sub-arrays.\n        result.push(stringify(value[index], language))\n      }\n    }\n\n    return result\n  }\n\n  /** @type {_Env} */\n  const env = {\n    type: value.type,\n    content: stringify(value.content, language),\n    tag: 'span',\n    classes: ['token', value.type],\n    attributes: {},\n    language\n  }\n\n  if (value.alias) {\n    env.classes.push(\n      ...(typeof value.alias === 'string' ? [value.alias] : value.alias)\n    )\n  }\n\n  // @ts-expect-error Prism.\n  refractor.hooks.run('wrap', env)\n\n  // @ts-expect-error Hush, it’s fine.\n  return h(\n    env.tag + '.' + env.classes.join('.'),\n    attributes(env.attributes),\n    env.content\n  )\n}\n\n/**\n * @template {unknown} T\n * @param {T} tokens\n * @returns {T}\n */\nfunction encode(tokens) {\n  return tokens\n}\n\n/**\n * @param {Record<string, string>} attrs\n * @returns {Record<string, string>}\n */\nfunction attributes(attrs) {\n  /** @type {string} */\n  let key\n\n  for (key in attrs) {\n    if (own.call(attrs, key)) {\n      attrs[key] = parseEntities(attrs[key])\n    }\n  }\n\n  return attrs\n}\n"]},"metadata":{},"sourceType":"module"}