{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { asciiAlpha, asciiAlphanumeric, asciiControl, markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nvar wwwPrefix = {\n  tokenize: tokenizeWwwPrefix,\n  partial: true\n};\nvar domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nvar path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nvar trail = {\n  tokenize: tokenizeTrail,\n  partial: true\n};\nvar emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n};\nvar wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nvar protocolAutolink = {\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n};\nvar emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n/** @type {ConstructRecord} */\n\nvar text = {}; // To do: next major: expose functions that yields extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * autolink literal syntax.\n *\n * @type {Extension}\n */\n\nexport var gfmAutolinkLiteral = {\n  text: text\n};\nvar code = 48; // Add alphanumerics.\n\nwhile (code < 123) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === 58) code = 65;else if (code === 91) code = 97;\n}\n\ntext[43] = emailAutolink;\ntext[45] = emailAutolink;\ntext[46] = emailAutolink;\ntext[95] = emailAutolink;\ntext[72] = [emailAutolink, protocolAutolink];\ntext[104] = [emailAutolink, protocolAutolink];\ntext[87] = [emailAutolink, wwwAutolink];\ntext[119] = [emailAutolink, wwwAutolink]; // To do: perform email autolink literals on events, afterwards.\n// That’s where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  var self = this;\n  /** @type {boolean | undefined} */\n\n  var dot;\n  /** @type {boolean} */\n\n  var data;\n  return start;\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n\n    if (code === 64) {\n      effects.consume(code);\n      return emailDomain;\n    }\n\n    return nok(code);\n  }\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === 46) {\n      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);\n    } // Alphanumerical, `-`, and `_`.\n\n\n    if (code === 45 || code === 95 || asciiAlphanumeric(code)) {\n      data = true;\n      effects.consume(code);\n      return emailDomain;\n    } // To do: `/` if xmpp.\n    // Note: normally we’d truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isn’t trailing.\n    // So we can ignore truncating!\n\n\n    return emailDomainAfter(code);\n  }\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function emailDomainDot(code) {\n    effects.consume(code);\n    dot = true;\n    return emailDomain;\n  }\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  var self = this;\n  return wwwStart;\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function wwwStart(code) {\n    if (code !== 87 && code !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww'); // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n\n    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);\n  }\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  var self = this;\n  var buffer = '';\n  var seen = false;\n  return protocolStart;\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function protocolStart(code) {\n    if ((code === 72 || code === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {\n      effects.enter('literalAutolink');\n      effects.enter('literalAutolinkHttp');\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n\n    return nok(code);\n  }\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n\n    if (code === 58) {\n      var protocol = buffer.toLowerCase();\n\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code);\n        return protocolSlashesInside;\n      }\n    }\n\n    return nok(code);\n  }\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function protocolSlashesInside(code) {\n    if (code === 47) {\n      effects.consume(code);\n\n      if (seen) {\n        return afterProtocol;\n      }\n\n      seen = true;\n      return protocolSlashesInside;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === null || asciiControl(code) || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);\n  }\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  var size = 0;\n  return wwwPrefixInside;\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function wwwPrefixInside(code) {\n    if ((code === 87 || code === 119) && size < 3) {\n      size++;\n      effects.consume(code);\n      return wwwPrefixInside;\n    }\n\n    if (code === 46 && size === 3) {\n      effects.consume(code);\n      return wwwPrefixAfter;\n    }\n\n    return nok(code);\n  }\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === null ? nok(code) : ok(code);\n  }\n}\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  var underscoreInLastSegment;\n  /** @type {boolean | undefined} */\n\n  var underscoreInLastLastSegment;\n  /** @type {boolean | undefined} */\n\n  var seen;\n  return domainInside;\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === 46 || code === 95) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code);\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n\n\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || code !== 45 && unicodePunctuation(code)) {\n      return domainAfter(code);\n    }\n\n    seen = true;\n    effects.consume(code);\n    return domainInside;\n  }\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === 95) {\n      underscoreInLastSegment = true;\n    } // Otherwise, it’s a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment;\n      underscoreInLastSegment = undefined;\n    }\n\n    effects.consume(code);\n    return domainInside;\n  }\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n\n\n  function domainAfter(code) {\n    // Note: that’s GH says a dot is needed, but it’s not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code);\n    }\n\n    return ok(code);\n  }\n}\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizePath(effects, ok) {\n  var sizeOpen = 0;\n  var sizeClose = 0;\n  return pathInside;\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function pathInside(code) {\n    if (code === 40) {\n      sizeOpen++;\n      effects.consume(code);\n      return pathInside;\n    } // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we don’t check for a trail.\n\n\n    if (code === 41 && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code);\n    } // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n\n\n    if (code === 33 || code === 34 || code === 38 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 93 || code === 95 || code === 126) {\n      return effects.check(trail, ok, pathAtPunctuation)(code);\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n\n    effects.consume(code);\n    return pathInside;\n  }\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === 41) {\n      sizeClose++;\n    }\n\n    effects.consume(code);\n    return pathInside;\n  }\n}\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail;\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 63 || code === 95 || code === 126) {\n      effects.consume(code);\n      return trail;\n    } // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n\n\n    if (code === 38) {\n      effects.consume(code);\n      return trailCharRefStart;\n    } // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n\n\n    if (code === 93) {\n      effects.consume(code);\n      return trailBracketAfter;\n    }\n\n    if ( // `<` is an end.\n    code === 60 || // So is whitespace.\n    code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n  /**\n   * In trail, after `]`.\n   *\n   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (code === null || code === 40 || code === 91 || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n\n    return trail(code);\n  }\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function trailCharRefStart(code) {\n    // When non-alpha, it’s not a trail.\n    return asciiAlpha(code) ? trailCharRefInside(code) : nok(code);\n  }\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function trailCharRefInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === 59) {\n      effects.consume(code);\n      return trail;\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return trailCharRefInside;\n    } // It’s not a trail.\n\n\n    return nok(code);\n  }\n}\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start;\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    // Must be dot.\n    effects.consume(code);\n    return after;\n  }\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code);\n  }\n}\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\n\n\nfunction previousWww(code) {\n  return code === null || code === 40 || code === 42 || code === 95 || code === 91 || code === 93 || code === 126 || markdownLineEndingOrSpace(code);\n}\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\n\n\nfunction previousProtocol(code) {\n  return !asciiAlpha(code);\n}\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\n\n\nfunction previousEmail(code) {\n  // Do not allow a slash “inside” atext.\n  // The reference code is a bit weird, but that’s what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === 47 || gfmAtext(code));\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\n\nfunction gfmAtext(code) {\n  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric(code);\n}\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\n\n\nfunction previousUnbalanced(events) {\n  var index = events.length;\n  var result = false;\n\n  while (index--) {\n    var token = events[index][1];\n\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    } // @ts-expect-error If we’ve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n\n\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js"],"names":["asciiAlpha","asciiAlphanumeric","asciiControl","markdownLineEndingOrSpace","unicodePunctuation","unicodeWhitespace","wwwPrefix","tokenize","tokenizeWwwPrefix","partial","domain","tokenizeDomain","path","tokenizePath","trail","tokenizeTrail","emailDomainDotTrail","tokenizeEmailDomainDotTrail","wwwAutolink","tokenizeWwwAutolink","previous","previousWww","protocolAutolink","tokenizeProtocolAutolink","previousProtocol","emailAutolink","tokenizeEmailAutolink","previousEmail","text","gfmAutolinkLiteral","code","effects","ok","nok","self","dot","data","start","gfmAtext","call","previousUnbalanced","events","enter","atext","consume","emailDomain","check","emailDomainAfter","emailDomainDot","exit","wwwStart","attempt","wwwAfter","buffer","seen","protocolStart","String","fromCodePoint","protocolPrefixInside","length","protocol","toLowerCase","protocolSlashesInside","afterProtocol","protocolAfter","size","wwwPrefixInside","wwwPrefixAfter","underscoreInLastSegment","underscoreInLastLastSegment","domainInside","domainAfter","domainAtPunctuation","undefined","sizeOpen","sizeClose","pathInside","pathAtPunctuation","trailCharRefStart","trailBracketAfter","trailCharRefInside","after","index","result","token","type","_balanced","_gfmAutolinkLiteralWalkedInto"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiControl,\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nconst wwwPrefix = {\n  tokenize: tokenizeWwwPrefix,\n  partial: true\n}\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n}\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n}\nconst trail = {\n  tokenize: tokenizeTrail,\n  partial: true\n}\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n}\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n}\nconst protocolAutolink = {\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n}\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n}\n\n/** @type {ConstructRecord} */\nconst text = {}\n\n// To do: next major: expose functions that yields extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * autolink literal syntax.\n *\n * @type {Extension}\n */\nexport const gfmAutolinkLiteral = {\n  text\n}\nlet code = 48\n\n// Add alphanumerics.\nwhile (code < 123) {\n  text[code] = emailAutolink\n  code++\n  if (code === 58) code = 65\n  else if (code === 91) code = 97\n}\ntext[43] = emailAutolink\ntext[45] = emailAutolink\ntext[46] = emailAutolink\ntext[95] = emailAutolink\ntext[72] = [emailAutolink, protocolAutolink]\ntext[104] = [emailAutolink, protocolAutolink]\ntext[87] = [emailAutolink, wwwAutolink]\ntext[119] = [emailAutolink, wwwAutolink]\n\n// To do: perform email autolink literals on events, afterwards.\n// That’s where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this\n  /** @type {boolean | undefined} */\n  let dot\n  /** @type {boolean} */\n  let data\n  return start\n\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (\n      !gfmAtext(code) ||\n      !previousEmail.call(self, self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n    if (code === 64) {\n      effects.consume(code)\n      return emailDomain\n    }\n    return nok(code)\n  }\n\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === 46) {\n      return effects.check(\n        emailDomainDotTrail,\n        emailDomainAfter,\n        emailDomainDot\n      )(code)\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (code === 45 || code === 95 || asciiAlphanumeric(code)) {\n      data = true\n      effects.consume(code)\n      return emailDomain\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally we’d truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isn’t trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code)\n  }\n\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainDot(code) {\n    effects.consume(code)\n    dot = true\n    return emailDomain\n  }\n\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n    return nok(code)\n  }\n}\n\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this\n  return wwwStart\n\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwStart(code) {\n    if (\n      (code !== 87 && code !== 119) ||\n      !previousWww.call(self, self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww')\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(\n      wwwPrefix,\n      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),\n      nok\n    )(code)\n  }\n\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this\n  let buffer = ''\n  let seen = false\n  return protocolStart\n\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolStart(code) {\n    if (\n      (code === 72 || code === 104) &&\n      previousProtocol.call(self, self.previous) &&\n      !previousUnbalanced(self.events)\n    ) {\n      effects.enter('literalAutolink')\n      effects.enter('literalAutolinkHttp')\n      buffer += String.fromCodePoint(code)\n      effects.consume(code)\n      return protocolPrefixInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      buffer += String.fromCodePoint(code)\n      effects.consume(code)\n      return protocolPrefixInside\n    }\n    if (code === 58) {\n      const protocol = buffer.toLowerCase()\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code)\n        return protocolSlashesInside\n      }\n    }\n    return nok(code)\n  }\n\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolSlashesInside(code) {\n    if (code === 47) {\n      effects.consume(code)\n      if (seen) {\n        return afterProtocol\n      }\n      seen = true\n      return protocolSlashesInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === null ||\n      asciiControl(code) ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code)\n  }\n\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0\n  return wwwPrefixInside\n\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixInside(code) {\n    if ((code === 87 || code === 119) && size < 3) {\n      size++\n      effects.consume(code)\n      return wwwPrefixInside\n    }\n    if (code === 46 && size === 3) {\n      effects.consume(code)\n      return wwwPrefixAfter\n    }\n    return nok(code)\n  }\n\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === null ? nok(code) : ok(code)\n  }\n}\n\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment\n  /** @type {boolean | undefined} */\n  let seen\n  return domainInside\n\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === 46 || code === 95) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code)\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (\n      code === null ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code) ||\n      (code !== 45 && unicodePunctuation(code))\n    ) {\n      return domainAfter(code)\n    }\n    seen = true\n    effects.consume(code)\n    return domainInside\n  }\n\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === 95) {\n      underscoreInLastSegment = true\n    }\n    // Otherwise, it’s a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment\n      underscoreInLastSegment = undefined\n    }\n    effects.consume(code)\n    return domainInside\n  }\n\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: that’s GH says a dot is needed, but it’s not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code)\n    }\n    return ok(code)\n  }\n}\n\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0\n  let sizeClose = 0\n  return pathInside\n\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathInside(code) {\n    if (code === 40) {\n      sizeOpen++\n      effects.consume(code)\n      return pathInside\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we don’t check for a trail.\n    if (code === 41 && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code)\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (\n      code === 33 ||\n      code === 34 ||\n      code === 38 ||\n      code === 39 ||\n      code === 41 ||\n      code === 42 ||\n      code === 44 ||\n      code === 46 ||\n      code === 58 ||\n      code === 59 ||\n      code === 60 ||\n      code === 63 ||\n      code === 93 ||\n      code === 95 ||\n      code === 126\n    ) {\n      return effects.check(trail, ok, pathAtPunctuation)(code)\n    }\n    if (\n      code === null ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n    effects.consume(code)\n    return pathInside\n  }\n\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === 41) {\n      sizeClose++\n    }\n    effects.consume(code)\n    return pathInside\n  }\n}\n\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail\n\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (\n      code === 33 ||\n      code === 34 ||\n      code === 39 ||\n      code === 41 ||\n      code === 42 ||\n      code === 44 ||\n      code === 46 ||\n      code === 58 ||\n      code === 59 ||\n      code === 63 ||\n      code === 95 ||\n      code === 126\n    ) {\n      effects.consume(code)\n      return trail\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === 38) {\n      effects.consume(code)\n      return trailCharRefStart\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === 93) {\n      effects.consume(code)\n      return trailBracketAfter\n    }\n    if (\n      // `<` is an end.\n      code === 60 ||\n      // So is whitespace.\n      code === null ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In trail, after `]`.\n   *\n   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (\n      code === null ||\n      code === 40 ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n    return trail(code)\n  }\n\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharRefStart(code) {\n    // When non-alpha, it’s not a trail.\n    return asciiAlpha(code) ? trailCharRefInside(code) : nok(code)\n  }\n\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharRefInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === 59) {\n      effects.consume(code)\n      return trail\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return trailCharRefInside\n    }\n\n    // It’s not a trail.\n    return nok(code)\n  }\n}\n\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start\n\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code)\n    return after\n  }\n\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code)\n  }\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\nfunction previousWww(code) {\n  return (\n    code === null ||\n    code === 40 ||\n    code === 42 ||\n    code === 95 ||\n    code === 91 ||\n    code === 93 ||\n    code === 126 ||\n    markdownLineEndingOrSpace(code)\n  )\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\nfunction previousProtocol(code) {\n  return !asciiAlpha(code)\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previousEmail(code) {\n  // Do not allow a slash “inside” atext.\n  // The reference code is a bit weird, but that’s what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === 47 || gfmAtext(code))\n}\n\n/**\n * @param {Code} code\n * @returns {boolean}\n */\nfunction gfmAtext(code) {\n  return (\n    code === 43 ||\n    code === 45 ||\n    code === 46 ||\n    code === 95 ||\n    asciiAlphanumeric(code)\n  )\n}\n\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\nfunction previousUnbalanced(events) {\n  let index = events.length\n  let result = false\n  while (index--) {\n    const token = events[index][1]\n    if (\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\n      !token._balanced\n    ) {\n      result = true\n      break\n    }\n\n    // @ts-expect-error If we’ve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false\n      break\n    }\n  }\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\n  }\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}