{"ast":null,"code":"import _objectSpread from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\n/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  var indexStack = state.indexStack;\n  var children = parent.children || [];\n  /** @type {Array<string>} */\n\n  var results = [];\n  var index = -1;\n  var before = info.before;\n  indexStack.push(-1);\n  var tracker = state.createTracker(info);\n\n  while (++index < children.length) {\n    var child = children[index];\n    /** @type {string} */\n\n    var after = void 0;\n    indexStack[indexStack.length - 1] = index;\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      var handle = state.handle.handlers[children[index + 1].type];\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n\n      if (handle && handle.peek) handle = handle.peek;\n      after = handle ? handle(children[index + 1], parent, state, _objectSpread({\n        before: '',\n        after: ''\n      }, tracker.current())).charAt(0) : '';\n    } else {\n      after = info.after;\n    } // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n\n\n    if (results.length > 0 && (before === '\\r' || before === '\\n') && child.type === 'html') {\n      results[results.length - 1] = results[results.length - 1].replace(/(\\r?\\n|\\r)$/, ' ');\n      before = ' '; // To do: does this work to reset tracker?\n\n      tracker = state.createTracker(info);\n      tracker.move(results.join(''));\n    }\n\n    results.push(tracker.move(state.handle(child, parent, state, _objectSpread(_objectSpread({}, tracker.current()), {}, {\n      before: before,\n      after: after\n    }))));\n    before = results[results.length - 1].slice(-1);\n  }\n\n  indexStack.pop();\n  return results.join('');\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js"],"names":["containerPhrasing","parent","state","info","indexStack","children","results","index","before","push","tracker","createTracker","length","child","after","handle","handlers","type","peek","current","charAt","replace","move","join","slice","pop"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n"]},"metadata":{},"sourceType":"module"}