{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('vfile').Value} Value\n */\n\n/**\n * @typedef Point\n *   unist point, where `line` and `column` can be `undefined`.\n * @property {number | undefined} line\n *   Line.\n * @property {number | undefined} column\n *   Column.\n * @property {number | undefined} [offset]\n *   Offset.\n *\n * @typedef PointLike\n *   unist point, allowed as input.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @callback ToPoint\n *   Get a line/column-based `point` from `offset`.\n * @param {number | null | undefined} [offset]\n *   Something that should be an `offset.\n * @returns {Point}\n *   Point, line/column are undefined for invalid or out of bounds input.\n *\n * @callback ToOffset\n *   Get an offset from a line/column-based `point`.\n * @param {Point | null | undefined} [point]\n *   Something that should be a `point.\n * @returns {number}\n *   Offset or `-1` for invalid or out of bounds input.\n *\n * @typedef Location\n *   Accessors for index.\n * @property {ToPoint} toPoint\n *   Get a line/column-based `point` from `offset`.\n * @property {ToOffset} toOffset\n *   Get an offset from a line/column-based `point`.\n */\n\n/**\n * Index the given document so you can translate between line/column and offset\n * based positional info.\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nexport function location(file) {\n  var value = String(file);\n  /** @type {Array<number>} */\n\n  var indices = [];\n  var search = /\\r?\\n|\\r/g;\n\n  while (search.test(value)) {\n    indices.push(search.lastIndex);\n  }\n\n  indices.push(value.length + 1);\n  return {\n    toPoint: toPoint,\n    toOffset: toOffset\n  };\n  /** @type {ToPoint} */\n\n  function toPoint(offset) {\n    var index = -1;\n\n    if (typeof offset === 'number' && offset > -1 && offset < indices[indices.length - 1]) {\n      while (++index < indices.length) {\n        if (indices[index] > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset: offset\n          };\n        }\n      }\n    }\n\n    return {\n      line: undefined,\n      column: undefined,\n      offset: undefined\n    };\n  }\n  /** @type {ToOffset} */\n\n\n  function toOffset(point) {\n    var line = point && point.line;\n    var column = point && point.column;\n\n    if (typeof line === 'number' && typeof column === 'number' && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {\n      var offset = (indices[line - 2] || 0) + column - 1 || 0;\n\n      if (offset > -1 && offset < indices[indices.length - 1]) {\n        return offset;\n      }\n    }\n\n    return -1;\n  }\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/vfile-location/lib/index.js"],"names":["location","file","value","String","indices","search","test","push","lastIndex","length","toPoint","toOffset","offset","index","line","column","undefined","point","Number","isNaN"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,QAAT,CAAkBC,IAAlB,EAAwB;AAC7B,MAAMC,KAAK,GAAGC,MAAM,CAACF,IAAD,CAApB;AACA;;AACA,MAAMG,OAAO,GAAG,EAAhB;AACA,MAAMC,MAAM,GAAG,WAAf;;AAEA,SAAOA,MAAM,CAACC,IAAP,CAAYJ,KAAZ,CAAP,EAA2B;AACzBE,IAAAA,OAAO,CAACG,IAAR,CAAaF,MAAM,CAACG,SAApB;AACD;;AAEDJ,EAAAA,OAAO,CAACG,IAAR,CAAaL,KAAK,CAACO,MAAN,GAAe,CAA5B;AAEA,SAAO;AAACC,IAAAA,OAAO,EAAPA,OAAD;AAAUC,IAAAA,QAAQ,EAARA;AAAV,GAAP;AAEA;;AACA,WAASD,OAAT,CAAiBE,MAAjB,EAAyB;AACvB,QAAIC,KAAK,GAAG,CAAC,CAAb;;AAEA,QACE,OAAOD,MAAP,KAAkB,QAAlB,IACAA,MAAM,GAAG,CAAC,CADV,IAEAA,MAAM,GAAGR,OAAO,CAACA,OAAO,CAACK,MAAR,GAAiB,CAAlB,CAHlB,EAIE;AACA,aAAO,EAAEI,KAAF,GAAUT,OAAO,CAACK,MAAzB,EAAiC;AAC/B,YAAIL,OAAO,CAACS,KAAD,CAAP,GAAiBD,MAArB,EAA6B;AAC3B,iBAAO;AACLE,YAAAA,IAAI,EAAED,KAAK,GAAG,CADT;AAELE,YAAAA,MAAM,EAAEH,MAAM,IAAIC,KAAK,GAAG,CAAR,GAAYT,OAAO,CAACS,KAAK,GAAG,CAAT,CAAnB,GAAiC,CAArC,CAAN,GAAgD,CAFnD;AAGLD,YAAAA,MAAM,EAANA;AAHK,WAAP;AAKD;AACF;AACF;;AAED,WAAO;AAACE,MAAAA,IAAI,EAAEE,SAAP;AAAkBD,MAAAA,MAAM,EAAEC,SAA1B;AAAqCJ,MAAAA,MAAM,EAAEI;AAA7C,KAAP;AACD;AAED;;;AACA,WAASL,QAAT,CAAkBM,KAAlB,EAAyB;AACvB,QAAMH,IAAI,GAAGG,KAAK,IAAIA,KAAK,CAACH,IAA5B;AACA,QAAMC,MAAM,GAAGE,KAAK,IAAIA,KAAK,CAACF,MAA9B;;AAEA,QACE,OAAOD,IAAP,KAAgB,QAAhB,IACA,OAAOC,MAAP,KAAkB,QADlB,IAEA,CAACG,MAAM,CAACC,KAAP,CAAaL,IAAb,CAFD,IAGA,CAACI,MAAM,CAACC,KAAP,CAAaJ,MAAb,CAHD,IAIAD,IAAI,GAAG,CAAP,IAAYV,OALd,EAME;AACA,UAAMQ,MAAM,GAAG,CAACR,OAAO,CAACU,IAAI,GAAG,CAAR,CAAP,IAAqB,CAAtB,IAA2BC,MAA3B,GAAoC,CAApC,IAAyC,CAAxD;;AAEA,UAAIH,MAAM,GAAG,CAAC,CAAV,IAAeA,MAAM,GAAGR,OAAO,CAACA,OAAO,CAACK,MAAR,GAAiB,CAAlB,CAAnC,EAAyD;AACvD,eAAOG,MAAP;AACD;AACF;;AAED,WAAO,CAAC,CAAR;AACD;AACF","sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('vfile').Value} Value\n */\n\n/**\n * @typedef Point\n *   unist point, where `line` and `column` can be `undefined`.\n * @property {number | undefined} line\n *   Line.\n * @property {number | undefined} column\n *   Column.\n * @property {number | undefined} [offset]\n *   Offset.\n *\n * @typedef PointLike\n *   unist point, allowed as input.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @callback ToPoint\n *   Get a line/column-based `point` from `offset`.\n * @param {number | null | undefined} [offset]\n *   Something that should be an `offset.\n * @returns {Point}\n *   Point, line/column are undefined for invalid or out of bounds input.\n *\n * @callback ToOffset\n *   Get an offset from a line/column-based `point`.\n * @param {Point | null | undefined} [point]\n *   Something that should be a `point.\n * @returns {number}\n *   Offset or `-1` for invalid or out of bounds input.\n *\n * @typedef Location\n *   Accessors for index.\n * @property {ToPoint} toPoint\n *   Get a line/column-based `point` from `offset`.\n * @property {ToOffset} toOffset\n *   Get an offset from a line/column-based `point`.\n */\n\n/**\n * Index the given document so you can translate between line/column and offset\n * based positional info.\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nexport function location(file) {\n  const value = String(file)\n  /** @type {Array<number>} */\n  const indices = []\n  const search = /\\r?\\n|\\r/g\n\n  while (search.test(value)) {\n    indices.push(search.lastIndex)\n  }\n\n  indices.push(value.length + 1)\n\n  return {toPoint, toOffset}\n\n  /** @type {ToPoint} */\n  function toPoint(offset) {\n    let index = -1\n\n    if (\n      typeof offset === 'number' &&\n      offset > -1 &&\n      offset < indices[indices.length - 1]\n    ) {\n      while (++index < indices.length) {\n        if (indices[index] > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset\n          }\n        }\n      }\n    }\n\n    return {line: undefined, column: undefined, offset: undefined}\n  }\n\n  /** @type {ToOffset} */\n  function toOffset(point) {\n    const line = point && point.line\n    const column = point && point.column\n\n    if (\n      typeof line === 'number' &&\n      typeof column === 'number' &&\n      !Number.isNaN(line) &&\n      !Number.isNaN(column) &&\n      line - 1 in indices\n    ) {\n      const offset = (indices[line - 2] || 0) + column - 1 || 0\n\n      if (offset > -1 && offset < indices[indices.length - 1]) {\n        return offset\n      }\n    }\n\n    return -1\n  }\n}\n"]},"metadata":{},"sourceType":"module"}