{"ast":null,"code":"/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more info on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n *   BCP-47 tag.\n * @typedef {Array<Tag>} Tags\n *   List of BCP-47 tags.\n * @typedef {string} Range\n *   RFC 4647 range.\n * @typedef {Array<Range>} Ranges\n *   List of RFC 4647 range.\n *\n * @callback Check\n *   An internal check.\n * @param {Tag} tag\n *   BCP-47 tag.\n * @param {Range} range\n *   RFC 4647 range.\n * @returns {boolean}\n *   Whether the range matches the tag.\n *\n * @typedef {FilterOrLookup<true>} Filter\n *   Filter: yields all tags that match a range.\n * @typedef {FilterOrLookup<false>} Lookup\n *   Lookup: yields the best tag that matches a range.\n */\n\n/**\n * @template {boolean} IsFilter\n *   Whether to filter or perform a lookup.\n * @callback FilterOrLookup\n *   A check.\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {IsFilter extends true ? Tags : Tag|undefined}\n *   Result.\n */\n\n/**\n * Factory to perform a filter or a lookup.\n *\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.\n * That way, earlier ranges matching any tag have precedence over later ranges.\n *\n * @template {boolean} IsFilter\n * @param {Check} check\n *   A check.\n * @param {IsFilter} filter\n *   Whether to filter or perform a lookup.\n * @returns {FilterOrLookup<IsFilter>}\n *   Filter or lookup.\n */\nfunction factory(check, filter) {\n  /**\n   * @param {Tag|Tags} tags\n   *   One or more BCP-47 tags.\n   * @param {Range|Ranges|undefined} [ranges='*']\n   *   One or more RFC 4647 ranges.\n   * @returns {IsFilter extends true ? Tags : Tag|undefined}\n   *   Result.\n   */\n  return function (tags, ranges) {\n    var left = cast(tags, 'tag');\n    var right = cast(ranges === null || ranges === undefined ? '*' : ranges, 'range');\n    /** @type {Tags} */\n\n    var matches = [];\n    var rightIndex = -1;\n\n    while (++rightIndex < right.length) {\n      var range = right[rightIndex].toLowerCase(); // Ignore wildcards in lookup mode.\n\n      if (!filter && range === '*') continue;\n      var leftIndex = -1;\n      /** @type {Tags} */\n\n      var next = [];\n\n      while (++leftIndex < left.length) {\n        if (check(left[leftIndex].toLowerCase(), range)) {\n          // Exit if this is a lookup and we have a match.\n          if (!filter) {\n            return left[leftIndex];\n          }\n\n          matches.push(left[leftIndex]);\n        } else {\n          next.push(left[leftIndex]);\n        }\n      }\n\n      left = next;\n    } // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n    // a match, so return `undefined`.\n\n\n    return filter ? matches : undefined;\n  };\n}\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\n\n\nexport var basicFilter = factory(function (tag, range) {\n  return range === '*' || tag === range || tag.includes(range + '-');\n}, true);\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\n\nexport var extendedFilter = factory(function (tag, range) {\n  // 3.3.2.1\n  var left = tag.split('-');\n  var right = range.split('-');\n  var leftIndex = 0;\n  var rightIndex = 0; // 3.3.2.2\n\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n    return false;\n  }\n\n  leftIndex++;\n  rightIndex++; // 3.3.2.3\n\n  while (rightIndex < right.length) {\n    // 3.3.2.3.A\n    if (right[rightIndex] === '*') {\n      rightIndex++;\n      continue;\n    } // 3.3.2.3.B\n\n\n    if (!left[leftIndex]) return false; // 3.3.2.3.C\n\n    if (left[leftIndex] === right[rightIndex]) {\n      leftIndex++;\n      rightIndex++;\n      continue;\n    } // 3.3.2.3.D\n\n\n    if (left[leftIndex].length === 1) return false; // 3.3.2.3.E\n\n    leftIndex++;\n  } // 3.3.2.4\n\n\n  return true;\n}, true);\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tag|undefined}\n *   BCP-47 tag.\n */\n\nexport var lookup = factory(function (tag, range) {\n  var right = range;\n  /* eslint-disable-next-line no-constant-condition */\n\n  while (true) {\n    if (right === '*' || tag === right) return true;\n    var index = right.lastIndexOf('-');\n    if (index < 0) return false;\n    if (right.charAt(index - 2) === '-') index -= 2;\n    right = right.slice(0, index);\n  }\n}, false);\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\n\nfunction cast(values, name) {\n  var value = values && typeof values === 'string' ? [values] : values;\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error('Invalid ' + name + ' `' + value + '`, expected non-empty string');\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/bcp-47-match/index.js"],"names":["factory","check","filter","tags","ranges","left","cast","right","undefined","matches","rightIndex","length","range","toLowerCase","leftIndex","next","push","basicFilter","tag","includes","extendedFilter","split","lookup","index","lastIndexOf","charAt","slice","values","name","value","Error"],"mappings":"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","sourcesContent":["/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more info on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n *   BCP-47 tag.\n * @typedef {Array<Tag>} Tags\n *   List of BCP-47 tags.\n * @typedef {string} Range\n *   RFC 4647 range.\n * @typedef {Array<Range>} Ranges\n *   List of RFC 4647 range.\n *\n * @callback Check\n *   An internal check.\n * @param {Tag} tag\n *   BCP-47 tag.\n * @param {Range} range\n *   RFC 4647 range.\n * @returns {boolean}\n *   Whether the range matches the tag.\n *\n * @typedef {FilterOrLookup<true>} Filter\n *   Filter: yields all tags that match a range.\n * @typedef {FilterOrLookup<false>} Lookup\n *   Lookup: yields the best tag that matches a range.\n */\n\n/**\n * @template {boolean} IsFilter\n *   Whether to filter or perform a lookup.\n * @callback FilterOrLookup\n *   A check.\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {IsFilter extends true ? Tags : Tag|undefined}\n *   Result.\n */\n\n/**\n * Factory to perform a filter or a lookup.\n *\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.\n * That way, earlier ranges matching any tag have precedence over later ranges.\n *\n * @template {boolean} IsFilter\n * @param {Check} check\n *   A check.\n * @param {IsFilter} filter\n *   Whether to filter or perform a lookup.\n * @returns {FilterOrLookup<IsFilter>}\n *   Filter or lookup.\n */\nfunction factory(check, filter) {\n  /**\n   * @param {Tag|Tags} tags\n   *   One or more BCP-47 tags.\n   * @param {Range|Ranges|undefined} [ranges='*']\n   *   One or more RFC 4647 ranges.\n   * @returns {IsFilter extends true ? Tags : Tag|undefined}\n   *   Result.\n   */\n  return function (tags, ranges) {\n    let left = cast(tags, 'tag')\n    const right = cast(\n      ranges === null || ranges === undefined ? '*' : ranges,\n      'range'\n    )\n    /** @type {Tags} */\n    const matches = []\n    let rightIndex = -1\n\n    while (++rightIndex < right.length) {\n      const range = right[rightIndex].toLowerCase()\n\n      // Ignore wildcards in lookup mode.\n      if (!filter && range === '*') continue\n\n      let leftIndex = -1\n      /** @type {Tags} */\n      const next = []\n\n      while (++leftIndex < left.length) {\n        if (check(left[leftIndex].toLowerCase(), range)) {\n          // Exit if this is a lookup and we have a match.\n          if (!filter) {\n            return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ (\n              left[leftIndex]\n            )\n          }\n\n          matches.push(left[leftIndex])\n        } else {\n          next.push(left[leftIndex])\n        }\n      }\n\n      left = next\n    }\n\n    // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n    // a match, so return `undefined`.\n    return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ (\n      filter ? matches : undefined\n    )\n  }\n}\n\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\nexport const basicFilter = factory(function (tag, range) {\n  return range === '*' || tag === range || tag.includes(range + '-')\n}, true)\n\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tags}\n *   List of BCP-47 tags.\n */\nexport const extendedFilter = factory(function (tag, range) {\n  // 3.3.2.1\n  const left = tag.split('-')\n  const right = range.split('-')\n  let leftIndex = 0\n  let rightIndex = 0\n\n  // 3.3.2.2\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n    return false\n  }\n\n  leftIndex++\n  rightIndex++\n\n  // 3.3.2.3\n  while (rightIndex < right.length) {\n    // 3.3.2.3.A\n    if (right[rightIndex] === '*') {\n      rightIndex++\n      continue\n    }\n\n    // 3.3.2.3.B\n    if (!left[leftIndex]) return false\n\n    // 3.3.2.3.C\n    if (left[leftIndex] === right[rightIndex]) {\n      leftIndex++\n      rightIndex++\n      continue\n    }\n\n    // 3.3.2.3.D\n    if (left[leftIndex].length === 1) return false\n\n    // 3.3.2.3.E\n    leftIndex++\n  }\n\n  // 3.3.2.4\n  return true\n}, true)\n\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n *\n * @param {Tag|Tags} tags\n *   One or more BCP-47 tags.\n * @param {Range|Ranges|undefined} [ranges='*']\n *   One or more RFC 4647 ranges.\n * @returns {Tag|undefined}\n *   BCP-47 tag.\n */\nexport const lookup = factory(function (tag, range) {\n  let right = range\n\n  /* eslint-disable-next-line no-constant-condition */\n  while (true) {\n    if (right === '*' || tag === right) return true\n\n    let index = right.lastIndexOf('-')\n\n    if (index < 0) return false\n\n    if (right.charAt(index - 2) === '-') index -= 2\n\n    right = right.slice(0, index)\n  }\n}, false)\n\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\nfunction cast(values, name) {\n  const value = values && typeof values === 'string' ? [values] : values\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error(\n      'Invalid ' + name + ' `' + value + '`, expected non-empty string'\n    )\n  }\n\n  return value\n}\n"]},"metadata":{},"sourceType":"module"}