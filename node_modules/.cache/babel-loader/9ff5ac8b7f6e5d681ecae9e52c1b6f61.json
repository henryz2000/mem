{"ast":null,"code":"/**\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Space} Space\n * @typedef {import('./types.js').SelectState} SelectState\n */\nimport { html, svg } from 'property-information';\nimport { queryToSelectors, walk } from './walk.js';\nimport { parse } from './parse.js';\n/**\n * Check that the given `node` matches `selector`.\n *\n * This only checks the element itself, not the surrounding tree.\n * Thus, nesting in selectors is not supported (`p b`, `p > b`), neither are\n * selectors like `:first-child`, etc.\n * This only checks that the given element matches the selector.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [node]\n *   Node that might match `selector`, should be an element.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {boolean}\n *   Whether `node` matches `selector`.\n */\n\nexport function matches(selector, node, space) {\n  var state = createState(selector, node, space);\n  state.one = true;\n  state.shallow = true;\n  walk(state, node || undefined);\n  return state.results.length > 0;\n}\n/**\n * Select the first element that matches `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {Element | null}\n *   First element in `tree` that matches `selector` or `null` if nothing is\n *   found.\n *   This could be `tree` itself.\n */\n\nexport function select(selector, tree, space) {\n  var state = createState(selector, tree, space);\n  state.one = true;\n  walk(state, tree || undefined); // To do in major: return `undefined` instead.\n\n  return state.results[0] || null;\n}\n/**\n * Select all elements that match `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {Array<Element>}\n *   Elements in `tree` that match `selector`.\n *   This could include `tree` itself.\n */\n\nexport function selectAll(selector, tree, space) {\n  var state = createState(selector, tree, space);\n  walk(state, tree || undefined);\n  return state.results;\n}\n/**\n * @param {string} selector\n *   Tree to search.\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {SelectState} SelectState\n */\n\nfunction createState(selector, tree, space) {\n  return {\n    // State of the query.\n    rootQuery: queryToSelectors(parse(selector)),\n    results: [],\n    // @ts-expect-error assume elements.\n    scopeElements: tree ? tree.type === 'root' ? tree.children : [tree] : [],\n    one: false,\n    shallow: false,\n    found: false,\n    // State in the tree.\n    schema: space === 'svg' ? svg : html,\n    language: undefined,\n    direction: 'ltr',\n    editableOrEditingHost: false,\n    typeIndex: undefined,\n    elementIndex: undefined,\n    typeCount: undefined,\n    elementCount: undefined\n  };\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/hast-util-select/lib/index.js"],"names":["html","svg","queryToSelectors","walk","parse","matches","selector","node","space","state","createState","one","shallow","undefined","results","length","select","tree","selectAll","rootQuery","scopeElements","type","children","found","schema","language","direction","editableOrEditingHost","typeIndex","elementIndex","typeCount","elementCount"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,IAAR,EAAcC,GAAd,QAAwB,sBAAxB;AACA,SAAQC,gBAAR,EAA0BC,IAA1B,QAAqC,WAArC;AACA,SAAQC,KAAR,QAAoB,YAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,OAAT,CAAiBC,QAAjB,EAA2BC,IAA3B,EAAiCC,KAAjC,EAAwC;AAC7C,MAAMC,KAAK,GAAGC,WAAW,CAACJ,QAAD,EAAWC,IAAX,EAAiBC,KAAjB,CAAzB;AACAC,EAAAA,KAAK,CAACE,GAAN,GAAY,IAAZ;AACAF,EAAAA,KAAK,CAACG,OAAN,GAAgB,IAAhB;AACAT,EAAAA,IAAI,CAACM,KAAD,EAAQF,IAAI,IAAIM,SAAhB,CAAJ;AACA,SAAOJ,KAAK,CAACK,OAAN,CAAcC,MAAd,GAAuB,CAA9B;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,MAAT,CAAgBV,QAAhB,EAA0BW,IAA1B,EAAgCT,KAAhC,EAAuC;AAC5C,MAAMC,KAAK,GAAGC,WAAW,CAACJ,QAAD,EAAWW,IAAX,EAAiBT,KAAjB,CAAzB;AACAC,EAAAA,KAAK,CAACE,GAAN,GAAY,IAAZ;AACAR,EAAAA,IAAI,CAACM,KAAD,EAAQQ,IAAI,IAAIJ,SAAhB,CAAJ,CAH4C,CAI5C;;AACA,SAAOJ,KAAK,CAACK,OAAN,CAAc,CAAd,KAAoB,IAA3B;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,SAAT,CAAmBZ,QAAnB,EAA6BW,IAA7B,EAAmCT,KAAnC,EAA0C;AAC/C,MAAMC,KAAK,GAAGC,WAAW,CAACJ,QAAD,EAAWW,IAAX,EAAiBT,KAAjB,CAAzB;AACAL,EAAAA,IAAI,CAACM,KAAD,EAAQQ,IAAI,IAAIJ,SAAhB,CAAJ;AACA,SAAOJ,KAAK,CAACK,OAAb;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASJ,WAAT,CAAqBJ,QAArB,EAA+BW,IAA/B,EAAqCT,KAArC,EAA4C;AAC1C,SAAO;AACL;AACAW,IAAAA,SAAS,EAAEjB,gBAAgB,CAACE,KAAK,CAACE,QAAD,CAAN,CAFtB;AAGLQ,IAAAA,OAAO,EAAE,EAHJ;AAIL;AACAM,IAAAA,aAAa,EAAEH,IAAI,GAAIA,IAAI,CAACI,IAAL,KAAc,MAAd,GAAuBJ,IAAI,CAACK,QAA5B,GAAuC,CAACL,IAAD,CAA3C,GAAqD,EALnE;AAMLN,IAAAA,GAAG,EAAE,KANA;AAOLC,IAAAA,OAAO,EAAE,KAPJ;AAQLW,IAAAA,KAAK,EAAE,KARF;AASL;AACAC,IAAAA,MAAM,EAAEhB,KAAK,KAAK,KAAV,GAAkBP,GAAlB,GAAwBD,IAV3B;AAWLyB,IAAAA,QAAQ,EAAEZ,SAXL;AAYLa,IAAAA,SAAS,EAAE,KAZN;AAaLC,IAAAA,qBAAqB,EAAE,KAblB;AAcLC,IAAAA,SAAS,EAAEf,SAdN;AAeLgB,IAAAA,YAAY,EAAEhB,SAfT;AAgBLiB,IAAAA,SAAS,EAAEjB,SAhBN;AAiBLkB,IAAAA,YAAY,EAAElB;AAjBT,GAAP;AAmBD","sourcesContent":["/**\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Space} Space\n * @typedef {import('./types.js').SelectState} SelectState\n */\n\nimport {html, svg} from 'property-information'\nimport {queryToSelectors, walk} from './walk.js'\nimport {parse} from './parse.js'\n\n/**\n * Check that the given `node` matches `selector`.\n *\n * This only checks the element itself, not the surrounding tree.\n * Thus, nesting in selectors is not supported (`p b`, `p > b`), neither are\n * selectors like `:first-child`, etc.\n * This only checks that the given element matches the selector.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [node]\n *   Node that might match `selector`, should be an element.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {boolean}\n *   Whether `node` matches `selector`.\n */\nexport function matches(selector, node, space) {\n  const state = createState(selector, node, space)\n  state.one = true\n  state.shallow = true\n  walk(state, node || undefined)\n  return state.results.length > 0\n}\n\n/**\n * Select the first element that matches `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {Element | null}\n *   First element in `tree` that matches `selector` or `null` if nothing is\n *   found.\n *   This could be `tree` itself.\n */\nexport function select(selector, tree, space) {\n  const state = createState(selector, tree, space)\n  state.one = true\n  walk(state, tree || undefined)\n  // To do in major: return `undefined` instead.\n  return state.results[0] || null\n}\n\n/**\n * Select all elements that match `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {Array<Element>}\n *   Elements in `tree` that match `selector`.\n *   This could include `tree` itself.\n */\nexport function selectAll(selector, tree, space) {\n  const state = createState(selector, tree, space)\n  walk(state, tree || undefined)\n  return state.results\n}\n\n/**\n * @param {string} selector\n *   Tree to search.\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {SelectState} SelectState\n */\nfunction createState(selector, tree, space) {\n  return {\n    // State of the query.\n    rootQuery: queryToSelectors(parse(selector)),\n    results: [],\n    // @ts-expect-error assume elements.\n    scopeElements: tree ? (tree.type === 'root' ? tree.children : [tree]) : [],\n    one: false,\n    shallow: false,\n    found: false,\n    // State in the tree.\n    schema: space === 'svg' ? svg : html,\n    language: undefined,\n    direction: 'ltr',\n    editableOrEditingHost: false,\n    typeIndex: undefined,\n    elementIndex: undefined,\n    typeCount: undefined,\n    elementCount: undefined\n  }\n}\n"]},"metadata":{},"sourceType":"module"}