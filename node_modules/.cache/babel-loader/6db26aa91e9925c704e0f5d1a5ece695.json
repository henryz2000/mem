{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\n/**\n * @typedef {[number, number, number, number]} Range\n *   Cell info.\n *\n * @typedef {0 | 1 | 2 | 3} RowKind\n *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { EditMap } from './edit-map.js';\nimport { gfmTableAlign } from './infer.js'; // To do: next major: expose functions.\n\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * table syntax.\n *\n * @type {Extension}\n */\n\nexport var gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolveAll: resolveTable\n    }\n  }\n};\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\nfunction tokenizeTable(effects, ok, nok) {\n  var self = this;\n  var size = 0;\n  var sizeB = 0;\n  /** @type {boolean | undefined} */\n\n  var seen;\n  return start;\n  /**\n   * Start of a GFM table.\n   *\n   * If there is a valid table row or table head before, then we try to parse\n   * another row.\n   * Otherwise, we try to parse a head.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   * @type {State}\n   */\n\n  function start(code) {\n    var index = self.events.length - 1;\n\n    while (index > -1) {\n      var type = self.events[index][1].type;\n      if (type === 'lineEnding' || // Note: markdown-rs uses `whitespace` instead of `linePrefix`\n      type === 'linePrefix') index--;else break;\n    }\n\n    var tail = index > -1 ? self.events[index][1].type : null;\n    var next = tail === 'tableHead' || tail === 'tableRow' ? bodyRowStart : headRowBefore; // Don’t allow lazy body rows.\n\n    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\n      return nok(code);\n    }\n\n    return next(code);\n  }\n  /**\n   * Before table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headRowBefore(code) {\n    effects.enter('tableHead');\n    effects.enter('tableRow');\n    return headRowStart(code);\n  }\n  /**\n   * Before table head row, after whitespace.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headRowStart(code) {\n    if (code === 124) {\n      return headRowBreak(code);\n    } // To do: micromark-js should let us parse our own whitespace in extensions,\n    // like `markdown-rs`:\n    //\n    // ```js\n    // // 4+ spaces.\n    // if (markdownSpace(code)) {\n    //   return nok(code)\n    // }\n    // ```\n\n\n    seen = true; // Count the first character, that isn’t a pipe, double.\n\n    sizeB += 1;\n    return headRowBreak(code);\n  }\n  /**\n   * At break in table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *       ^\n   *         ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headRowBreak(code) {\n    if (code === null) {\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n      return nok(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      // If anything other than one pipe (ignoring whitespace) was used, it’s fine.\n      if (sizeB > 1) {\n        sizeB = 0; // To do: check if this works.\n        // Feel free to interrupt:\n\n        self.interrupt = true;\n        effects.exit('tableRow');\n        effects.enter('lineEnding');\n        effects.consume(code);\n        effects.exit('lineEnding');\n        return headDelimiterStart;\n      } // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n\n\n      return nok(code);\n    }\n\n    if (markdownSpace(code)) {\n      // To do: check if this is fine.\n      // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)\n      // State::Retry(space_or_tab(tokenizer))\n      return factorySpace(effects, headRowBreak, 'whitespace')(code);\n    }\n\n    sizeB += 1;\n\n    if (seen) {\n      seen = false; // Header cell count.\n\n      size += 1;\n    }\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider'); // Whether a delimiter was seen.\n\n      seen = true;\n      return headRowBreak;\n    } // Anything else is cell data.\n\n\n    effects.enter('data');\n    return headRowData(code);\n  }\n  /**\n   * In table head row data.\n   *\n   * ```markdown\n   * > | | a |\n   *       ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headRowData(code) {\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('data');\n      return headRowBreak(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? headRowEscape : headRowData;\n  }\n  /**\n   * In table head row escape.\n   *\n   * ```markdown\n   * > | | a\\-b |\n   *         ^\n   *   | | ---- |\n   *   | | c    |\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headRowEscape(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return headRowData;\n    }\n\n    return headRowData(code);\n  }\n  /**\n   * Before delimiter row.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headDelimiterStart(code) {\n    // Reset `interrupt`.\n    self.interrupt = false; // Note: in `markdown-rs`, we need to handle piercing here too.\n\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code);\n    }\n\n    effects.enter('tableDelimiterRow'); // Track if we’ve seen a `:` or `|`.\n\n    seen = false;\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headDelimiterBefore, 'linePrefix', self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code);\n    }\n\n    return headDelimiterBefore(code);\n  }\n  /**\n   * Before delimiter row, after optional whitespace.\n   *\n   * Reused when a `|` is found later, to parse another cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headDelimiterBefore(code) {\n    if (code === 45 || code === 58) {\n      return headDelimiterValueBefore(code);\n    }\n\n    if (code === 124) {\n      seen = true; // If we start with a pipe, we open a cell marker.\n\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return headDelimiterCellBefore;\n    } // More whitespace / empty row not allowed at start.\n\n\n    return headDelimiterNok(code);\n  }\n  /**\n   * After `|`, before delimiter cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headDelimiterCellBefore(code) {\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headDelimiterValueBefore, 'whitespace')(code);\n    }\n\n    return headDelimiterValueBefore(code);\n  }\n  /**\n   * Before delimiter cell value.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headDelimiterValueBefore(code) {\n    // Align: left.\n    if (code === 58) {\n      sizeB += 1;\n      seen = true;\n      effects.enter('tableDelimiterMarker');\n      effects.consume(code);\n      effects.exit('tableDelimiterMarker');\n      return headDelimiterLeftAlignmentAfter;\n    } // Align: none.\n\n\n    if (code === 45) {\n      sizeB += 1; // To do: seems weird that this *isn’t* left aligned, but that state is used?\n\n      return headDelimiterLeftAlignmentAfter(code);\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      return headDelimiterCellAfter(code);\n    }\n\n    return headDelimiterNok(code);\n  }\n  /**\n   * After delimiter cell left alignment marker.\n   *\n   * ```markdown\n   *   | | a  |\n   * > | | :- |\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headDelimiterLeftAlignmentAfter(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      return headDelimiterFiller(code);\n    } // Anything else is not ok after the left-align colon.\n\n\n    return headDelimiterNok(code);\n  }\n  /**\n   * In delimiter cell filler.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headDelimiterFiller(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return headDelimiterFiller;\n    } // Align is `center` if it was `left`, `right` otherwise.\n\n\n    if (code === 58) {\n      seen = true;\n      effects.exit('tableDelimiterFiller');\n      effects.enter('tableDelimiterMarker');\n      effects.consume(code);\n      effects.exit('tableDelimiterMarker');\n      return headDelimiterRightAlignmentAfter;\n    }\n\n    effects.exit('tableDelimiterFiller');\n    return headDelimiterRightAlignmentAfter(code);\n  }\n  /**\n   * After delimiter cell right alignment marker.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headDelimiterRightAlignmentAfter(code) {\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headDelimiterCellAfter, 'whitespace')(code);\n    }\n\n    return headDelimiterCellAfter(code);\n  }\n  /**\n   * After delimiter cell.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headDelimiterCellAfter(code) {\n    if (code === 124) {\n      return headDelimiterBefore(code);\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      // Exit when:\n      // * there was no `:` or `|` at all (it’s a thematic break or setext\n      //   underline instead)\n      // * the header cell count is not the delimiter cell count\n      if (!seen || size !== sizeB) {\n        return headDelimiterNok(code);\n      } // Note: in markdown-rs`, a reset is needed here.\n\n\n      effects.exit('tableDelimiterRow');\n      effects.exit('tableHead'); // To do: in `markdown-rs`, resolvers need to be registered manually.\n      // effects.register_resolver(ResolveName::GfmTable)\n\n      return ok(code);\n    }\n\n    return headDelimiterNok(code);\n  }\n  /**\n   * In delimiter row, at a disallowed byte.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | x |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function headDelimiterNok(code) {\n    // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n    return nok(code);\n  }\n  /**\n   * Before table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function bodyRowStart(code) {\n    // Note: in `markdown-rs` we need to manually take care of a prefix,\n    // but in `micromark-js` that is done for us, so if we’re here, we’re\n    // never at whitespace.\n    effects.enter('tableRow');\n    return bodyRowBreak(code);\n  }\n  /**\n   * At break in table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   *       ^\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function bodyRowBreak(code) {\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return bodyRowBreak;\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('tableRow');\n      return ok(code);\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, bodyRowBreak, 'whitespace')(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('data');\n    return bodyRowData(code);\n  }\n  /**\n   * In table body row data.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function bodyRowData(code) {\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('data');\n      return bodyRowBreak(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? bodyRowEscape : bodyRowData;\n  }\n  /**\n   * In table body row escape.\n   *\n   * ```markdown\n   *   | | a    |\n   *   | | ---- |\n   * > | | b\\-c |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function bodyRowEscape(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return bodyRowData;\n    }\n\n    return bodyRowData(code);\n  }\n}\n/** @type {Resolver} */\n// eslint-disable-next-line complexity\n\n\nfunction resolveTable(events, context) {\n  var index = -1;\n  var inFirstCellAwaitingPipe = true;\n  /** @type {RowKind} */\n\n  var rowKind = 0;\n  /** @type {Range} */\n\n  var lastCell = [0, 0, 0, 0];\n  /** @type {Range} */\n\n  var cell = [0, 0, 0, 0];\n  var afterHeadAwaitingFirstBodyRow = false;\n  var lastTableEnd = 0;\n  /** @type {Token | undefined} */\n\n  var currentTable;\n  /** @type {Token | undefined} */\n\n  var currentBody;\n  /** @type {Token | undefined} */\n\n  var currentCell;\n  var map = new EditMap();\n\n  while (++index < events.length) {\n    var event = events[index];\n    var token = event[1];\n\n    if (event[0] === 'enter') {\n      // Start of head.\n      if (token.type === 'tableHead') {\n        afterHeadAwaitingFirstBodyRow = false; // Inject previous (body end and) table end.\n\n        if (lastTableEnd !== 0) {\n          flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);\n          currentBody = undefined;\n          lastTableEnd = 0;\n        } // Inject table start.\n\n\n        currentTable = {\n          type: 'table',\n          start: Object.assign({}, token.start),\n          // Note: correct end is set later.\n          end: Object.assign({}, token.end)\n        };\n        map.add(index, 0, [['enter', currentTable, context]]);\n      } else if (token.type === 'tableRow' || token.type === 'tableDelimiterRow') {\n        inFirstCellAwaitingPipe = true;\n        currentCell = undefined;\n        lastCell = [0, 0, 0, 0];\n        cell = [0, index + 1, 0, 0]; // Inject table body start.\n\n        if (afterHeadAwaitingFirstBodyRow) {\n          afterHeadAwaitingFirstBodyRow = false;\n          currentBody = {\n            type: 'tableBody',\n            start: Object.assign({}, token.start),\n            // Note: correct end is set later.\n            end: Object.assign({}, token.end)\n          };\n          map.add(index, 0, [['enter', currentBody, context]]);\n        }\n\n        rowKind = token.type === 'tableDelimiterRow' ? 2 : currentBody ? 3 : 1;\n      } // Cell data.\n      else if (rowKind && (token.type === 'data' || token.type === 'tableDelimiterMarker' || token.type === 'tableDelimiterFiller')) {\n        inFirstCellAwaitingPipe = false; // First value in cell.\n\n        if (cell[2] === 0) {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1];\n            currentCell = flushCell(map, context, lastCell, rowKind, undefined, currentCell);\n            lastCell = [0, 0, 0, 0];\n          }\n\n          cell[2] = index;\n        }\n      } else if (token.type === 'tableCellDivider') {\n        if (inFirstCellAwaitingPipe) {\n          inFirstCellAwaitingPipe = false;\n        } else {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1];\n            currentCell = flushCell(map, context, lastCell, rowKind, undefined, currentCell);\n          }\n\n          lastCell = cell;\n          cell = [lastCell[1], index, 0, 0];\n        }\n      }\n    } // Exit events.\n    else if (token.type === 'tableHead') {\n      afterHeadAwaitingFirstBodyRow = true;\n      lastTableEnd = index;\n    } else if (token.type === 'tableRow' || token.type === 'tableDelimiterRow') {\n      lastTableEnd = index;\n\n      if (lastCell[1] !== 0) {\n        cell[0] = cell[1];\n        currentCell = flushCell(map, context, lastCell, rowKind, index, currentCell);\n      } else if (cell[1] !== 0) {\n        currentCell = flushCell(map, context, cell, rowKind, index, currentCell);\n      }\n\n      rowKind = 0;\n    } else if (rowKind && (token.type === 'data' || token.type === 'tableDelimiterMarker' || token.type === 'tableDelimiterFiller')) {\n      cell[3] = index;\n    }\n  }\n\n  if (lastTableEnd !== 0) {\n    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);\n  }\n\n  map.consume(context.events); // To do: move this into `html`, when events are exposed there.\n  // That’s what `markdown-rs` does.\n  // That needs updates to `mdast-util-gfm-table`.\n\n  index = -1;\n\n  while (++index < context.events.length) {\n    var _event = context.events[index];\n\n    if (_event[0] === 'enter' && _event[1].type === 'table') {\n      // @ts-expect-error: custom field.\n      _event[1]._align = gfmTableAlign(context.events, index);\n    }\n  }\n\n  return events;\n} /// Generate a cell.\n\n/**\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {Range} range\n * @param {RowKind} rowKind\n * @param {number | undefined} rowEnd\n * @param {Token | undefined} previousCell\n * @returns {Token | undefined}\n */\n// eslint-disable-next-line max-params\n\n\nfunction flushCell(map, context, range, rowKind, rowEnd, previousCell) {\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'\n  var groupName = rowKind === 1 ? 'tableHeader' : rowKind === 2 ? 'tableDelimiter' : 'tableData'; // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'\n\n  var valueName = 'tableContent'; // Insert an exit for the previous cell, if there is one.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //          ^-- exit\n  //           ^^^^-- this cell\n  // ```\n\n  if (range[0] !== 0) {\n    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));\n    map.add(range[0], 0, [['exit', previousCell, context]]);\n  } // Insert enter of this cell.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //           ^-- enter\n  //           ^^^^-- this cell\n  // ```\n\n\n  var now = getPoint(context.events, range[1]);\n  previousCell = {\n    type: groupName,\n    start: Object.assign({}, now),\n    // Note: correct end is set later.\n    end: Object.assign({}, now)\n  };\n  map.add(range[1], 0, [['enter', previousCell, context]]); // Insert text start at first data start and end at last data end, and\n  // remove events between.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //            ^-- enter\n  //             ^-- exit\n  //           ^^^^-- this cell\n  // ```\n\n  if (range[2] !== 0) {\n    var relatedStart = getPoint(context.events, range[2]);\n    var relatedEnd = getPoint(context.events, range[3]);\n    var valueToken = {\n      type: valueName,\n      start: Object.assign({}, relatedStart),\n      end: Object.assign({}, relatedEnd)\n    };\n    map.add(range[2], 0, [['enter', valueToken, context]]);\n\n    if (rowKind !== 2) {\n      // Fix positional info on remaining events\n      var start = context.events[range[2]];\n      var end = context.events[range[3]];\n      start[1].end = Object.assign({}, end[1].end);\n      start[1].type = 'chunkText'; // @ts-expect-error It’s fine.\n\n      start[1].contentType = 'text'; // Remove if needed.\n\n      if (range[3] > range[2] + 1) {\n        var a = range[2] + 1;\n        var b = range[3] - range[2] - 1;\n        map.add(a, b, []);\n      }\n    }\n\n    map.add(range[3] + 1, 0, [['exit', valueToken, context]]);\n  } // Insert an exit for the last cell, if at the row end.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //                    ^-- exit\n  //               ^^^^^^-- this cell (the last one contains two “between” parts)\n  // ```\n\n\n  if (rowEnd !== undefined) {\n    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));\n    map.add(rowEnd, 0, [['exit', previousCell, context]]);\n    previousCell = undefined;\n  }\n\n  return previousCell;\n}\n/**\n * Generate table end (and table body end).\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {number} index\n * @param {Token} table\n * @param {Token | undefined} tableBody\n */\n// eslint-disable-next-line max-params\n\n\nfunction flushTableEnd(map, context, index, table, tableBody) {\n  /** @type {Array<Event>} */\n  var exits = [];\n  var related = getPoint(context.events, index);\n\n  if (tableBody) {\n    tableBody.end = Object.assign({}, related);\n    exits.push(['exit', tableBody, context]);\n  }\n\n  table.end = Object.assign({}, related);\n  exits.push(['exit', table, context]);\n  map.add(index + 1, 0, exits);\n}\n/**\n * @param {Array<Event>} events\n * @param {number} index\n * @returns {readonly Point}\n */\n\n\nfunction getPoint(events, index) {\n  var event = events[index];\n  var side = event[0] === 'enter' ? 'start' : 'end';\n  return event[1][side];\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/micromark-extension-gfm-table/lib/syntax.js"],"names":["factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","EditMap","gfmTableAlign","gfmTable","flow","null","tokenize","tokenizeTable","resolveAll","resolveTable","effects","ok","nok","self","size","sizeB","seen","start","code","index","events","length","type","tail","next","bodyRowStart","headRowBefore","parser","lazy","now","line","enter","headRowStart","headRowBreak","interrupt","exit","consume","headDelimiterStart","headRowData","headRowEscape","headDelimiterBefore","constructs","disable","includes","undefined","headDelimiterValueBefore","headDelimiterCellBefore","headDelimiterNok","headDelimiterLeftAlignmentAfter","headDelimiterCellAfter","headDelimiterFiller","headDelimiterRightAlignmentAfter","bodyRowBreak","bodyRowData","bodyRowEscape","context","inFirstCellAwaitingPipe","rowKind","lastCell","cell","afterHeadAwaitingFirstBodyRow","lastTableEnd","currentTable","currentBody","currentCell","map","event","token","flushTableEnd","Object","assign","end","add","flushCell","_align","range","rowEnd","previousCell","groupName","valueName","getPoint","relatedStart","relatedEnd","valueToken","contentType","a","b","table","tableBody","exits","related","push","side"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\n/**\n * @typedef {[number, number, number, number]} Range\n *   Cell info.\n *\n * @typedef {0 | 1 | 2 | 3} RowKind\n *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {EditMap} from './edit-map.js'\nimport {gfmTableAlign} from './infer.js'\n\n// To do: next major: expose functions.\n\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * table syntax.\n *\n * @type {Extension}\n */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolveAll: resolveTable\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  let size = 0\n  let sizeB = 0\n  /** @type {boolean | undefined} */\n  let seen\n  return start\n\n  /**\n   * Start of a GFM table.\n   *\n   * If there is a valid table row or table head before, then we try to parse\n   * another row.\n   * Otherwise, we try to parse a head.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length - 1\n    while (index > -1) {\n      const type = self.events[index][1].type\n      if (\n        type === 'lineEnding' ||\n        // Note: markdown-rs uses `whitespace` instead of `linePrefix`\n        type === 'linePrefix'\n      )\n        index--\n      else break\n    }\n    const tail = index > -1 ? self.events[index][1].type : null\n    const next =\n      tail === 'tableHead' || tail === 'tableRow' ? bodyRowStart : headRowBefore\n\n    // Don’t allow lazy body rows.\n    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n    return next(code)\n  }\n\n  /**\n   * Before table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowBefore(code) {\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n    return headRowStart(code)\n  }\n\n  /**\n   * Before table head row, after whitespace.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowStart(code) {\n    if (code === 124) {\n      return headRowBreak(code)\n    }\n\n    // To do: micromark-js should let us parse our own whitespace in extensions,\n    // like `markdown-rs`:\n    //\n    // ```js\n    // // 4+ spaces.\n    // if (markdownSpace(code)) {\n    //   return nok(code)\n    // }\n    // ```\n\n    seen = true\n    // Count the first character, that isn’t a pipe, double.\n    sizeB += 1\n    return headRowBreak(code)\n  }\n\n  /**\n   * At break in table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *       ^\n   *         ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowBreak(code) {\n    if (code === null) {\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n      return nok(code)\n    }\n    if (markdownLineEnding(code)) {\n      // If anything other than one pipe (ignoring whitespace) was used, it’s fine.\n      if (sizeB > 1) {\n        sizeB = 0\n        // To do: check if this works.\n        // Feel free to interrupt:\n        self.interrupt = true\n        effects.exit('tableRow')\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return headDelimiterStart\n      }\n\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n      return nok(code)\n    }\n    if (markdownSpace(code)) {\n      // To do: check if this is fine.\n      // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)\n      // State::Retry(space_or_tab(tokenizer))\n      return factorySpace(effects, headRowBreak, 'whitespace')(code)\n    }\n    sizeB += 1\n    if (seen) {\n      seen = false\n      // Header cell count.\n      size += 1\n    }\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      // Whether a delimiter was seen.\n      seen = true\n      return headRowBreak\n    }\n\n    // Anything else is cell data.\n    effects.enter('data')\n    return headRowData(code)\n  }\n\n  /**\n   * In table head row data.\n   *\n   * ```markdown\n   * > | | a |\n   *       ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowData(code) {\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('data')\n      return headRowBreak(code)\n    }\n    effects.consume(code)\n    return code === 92 ? headRowEscape : headRowData\n  }\n\n  /**\n   * In table head row escape.\n   *\n   * ```markdown\n   * > | | a\\-b |\n   *         ^\n   *   | | ---- |\n   *   | | c    |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowEscape(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return headRowData\n    }\n    return headRowData(code)\n  }\n\n  /**\n   * Before delimiter row.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterStart(code) {\n    // Reset `interrupt`.\n    self.interrupt = false\n\n    // Note: in `markdown-rs`, we need to handle piercing here too.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n    effects.enter('tableDelimiterRow')\n    // Track if we’ve seen a `:` or `|`.\n    seen = false\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        headDelimiterBefore,\n        'linePrefix',\n        self.parser.constructs.disable.null.includes('codeIndented')\n          ? undefined\n          : 4\n      )(code)\n    }\n    return headDelimiterBefore(code)\n  }\n\n  /**\n   * Before delimiter row, after optional whitespace.\n   *\n   * Reused when a `|` is found later, to parse another cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterBefore(code) {\n    if (code === 45 || code === 58) {\n      return headDelimiterValueBefore(code)\n    }\n    if (code === 124) {\n      seen = true\n      // If we start with a pipe, we open a cell marker.\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return headDelimiterCellBefore\n    }\n\n    // More whitespace / empty row not allowed at start.\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * After `|`, before delimiter cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterCellBefore(code) {\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headDelimiterValueBefore, 'whitespace')(code)\n    }\n    return headDelimiterValueBefore(code)\n  }\n\n  /**\n   * Before delimiter cell value.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterValueBefore(code) {\n    // Align: left.\n    if (code === 58) {\n      sizeB += 1\n      seen = true\n      effects.enter('tableDelimiterMarker')\n      effects.consume(code)\n      effects.exit('tableDelimiterMarker')\n      return headDelimiterLeftAlignmentAfter\n    }\n\n    // Align: none.\n    if (code === 45) {\n      sizeB += 1\n      // To do: seems weird that this *isn’t* left aligned, but that state is used?\n      return headDelimiterLeftAlignmentAfter(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      return headDelimiterCellAfter(code)\n    }\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * After delimiter cell left alignment marker.\n   *\n   * ```markdown\n   *   | | a  |\n   * > | | :- |\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterLeftAlignmentAfter(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      return headDelimiterFiller(code)\n    }\n\n    // Anything else is not ok after the left-align colon.\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * In delimiter cell filler.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterFiller(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return headDelimiterFiller\n    }\n\n    // Align is `center` if it was `left`, `right` otherwise.\n    if (code === 58) {\n      seen = true\n      effects.exit('tableDelimiterFiller')\n      effects.enter('tableDelimiterMarker')\n      effects.consume(code)\n      effects.exit('tableDelimiterMarker')\n      return headDelimiterRightAlignmentAfter\n    }\n    effects.exit('tableDelimiterFiller')\n    return headDelimiterRightAlignmentAfter(code)\n  }\n\n  /**\n   * After delimiter cell right alignment marker.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterRightAlignmentAfter(code) {\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headDelimiterCellAfter, 'whitespace')(code)\n    }\n    return headDelimiterCellAfter(code)\n  }\n\n  /**\n   * After delimiter cell.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterCellAfter(code) {\n    if (code === 124) {\n      return headDelimiterBefore(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      // Exit when:\n      // * there was no `:` or `|` at all (it’s a thematic break or setext\n      //   underline instead)\n      // * the header cell count is not the delimiter cell count\n      if (!seen || size !== sizeB) {\n        return headDelimiterNok(code)\n      }\n\n      // Note: in markdown-rs`, a reset is needed here.\n      effects.exit('tableDelimiterRow')\n      effects.exit('tableHead')\n      // To do: in `markdown-rs`, resolvers need to be registered manually.\n      // effects.register_resolver(ResolveName::GfmTable)\n      return ok(code)\n    }\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * In delimiter row, at a disallowed byte.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | x |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterNok(code) {\n    // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n    return nok(code)\n  }\n\n  /**\n   * Before table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowStart(code) {\n    // Note: in `markdown-rs` we need to manually take care of a prefix,\n    // but in `micromark-js` that is done for us, so if we’re here, we’re\n    // never at whitespace.\n    effects.enter('tableRow')\n    return bodyRowBreak(code)\n  }\n\n  /**\n   * At break in table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   *       ^\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowBreak(code) {\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return bodyRowBreak\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('tableRow')\n      return ok(code)\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(effects, bodyRowBreak, 'whitespace')(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('data')\n    return bodyRowData(code)\n  }\n\n  /**\n   * In table body row data.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowData(code) {\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('data')\n      return bodyRowBreak(code)\n    }\n    effects.consume(code)\n    return code === 92 ? bodyRowEscape : bodyRowData\n  }\n\n  /**\n   * In table body row escape.\n   *\n   * ```markdown\n   *   | | a    |\n   *   | | ---- |\n   * > | | b\\-c |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowEscape(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return bodyRowData\n    }\n    return bodyRowData(code)\n  }\n}\n\n/** @type {Resolver} */\n// eslint-disable-next-line complexity\nfunction resolveTable(events, context) {\n  let index = -1\n  let inFirstCellAwaitingPipe = true\n  /** @type {RowKind} */\n  let rowKind = 0\n  /** @type {Range} */\n  let lastCell = [0, 0, 0, 0]\n  /** @type {Range} */\n  let cell = [0, 0, 0, 0]\n  let afterHeadAwaitingFirstBodyRow = false\n  let lastTableEnd = 0\n  /** @type {Token | undefined} */\n  let currentTable\n  /** @type {Token | undefined} */\n  let currentBody\n  /** @type {Token | undefined} */\n  let currentCell\n  const map = new EditMap()\n  while (++index < events.length) {\n    const event = events[index]\n    const token = event[1]\n    if (event[0] === 'enter') {\n      // Start of head.\n      if (token.type === 'tableHead') {\n        afterHeadAwaitingFirstBodyRow = false\n\n        // Inject previous (body end and) table end.\n        if (lastTableEnd !== 0) {\n          flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\n          currentBody = undefined\n          lastTableEnd = 0\n        }\n\n        // Inject table start.\n        currentTable = {\n          type: 'table',\n          start: Object.assign({}, token.start),\n          // Note: correct end is set later.\n          end: Object.assign({}, token.end)\n        }\n        map.add(index, 0, [['enter', currentTable, context]])\n      } else if (\n        token.type === 'tableRow' ||\n        token.type === 'tableDelimiterRow'\n      ) {\n        inFirstCellAwaitingPipe = true\n        currentCell = undefined\n        lastCell = [0, 0, 0, 0]\n        cell = [0, index + 1, 0, 0]\n\n        // Inject table body start.\n        if (afterHeadAwaitingFirstBodyRow) {\n          afterHeadAwaitingFirstBodyRow = false\n          currentBody = {\n            type: 'tableBody',\n            start: Object.assign({}, token.start),\n            // Note: correct end is set later.\n            end: Object.assign({}, token.end)\n          }\n          map.add(index, 0, [['enter', currentBody, context]])\n        }\n        rowKind = token.type === 'tableDelimiterRow' ? 2 : currentBody ? 3 : 1\n      }\n      // Cell data.\n      else if (\n        rowKind &&\n        (token.type === 'data' ||\n          token.type === 'tableDelimiterMarker' ||\n          token.type === 'tableDelimiterFiller')\n      ) {\n        inFirstCellAwaitingPipe = false\n\n        // First value in cell.\n        if (cell[2] === 0) {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1]\n            currentCell = flushCell(\n              map,\n              context,\n              lastCell,\n              rowKind,\n              undefined,\n              currentCell\n            )\n            lastCell = [0, 0, 0, 0]\n          }\n          cell[2] = index\n        }\n      } else if (token.type === 'tableCellDivider') {\n        if (inFirstCellAwaitingPipe) {\n          inFirstCellAwaitingPipe = false\n        } else {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1]\n            currentCell = flushCell(\n              map,\n              context,\n              lastCell,\n              rowKind,\n              undefined,\n              currentCell\n            )\n          }\n          lastCell = cell\n          cell = [lastCell[1], index, 0, 0]\n        }\n      }\n    }\n    // Exit events.\n    else if (token.type === 'tableHead') {\n      afterHeadAwaitingFirstBodyRow = true\n      lastTableEnd = index\n    } else if (\n      token.type === 'tableRow' ||\n      token.type === 'tableDelimiterRow'\n    ) {\n      lastTableEnd = index\n      if (lastCell[1] !== 0) {\n        cell[0] = cell[1]\n        currentCell = flushCell(\n          map,\n          context,\n          lastCell,\n          rowKind,\n          index,\n          currentCell\n        )\n      } else if (cell[1] !== 0) {\n        currentCell = flushCell(map, context, cell, rowKind, index, currentCell)\n      }\n      rowKind = 0\n    } else if (\n      rowKind &&\n      (token.type === 'data' ||\n        token.type === 'tableDelimiterMarker' ||\n        token.type === 'tableDelimiterFiller')\n    ) {\n      cell[3] = index\n    }\n  }\n  if (lastTableEnd !== 0) {\n    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\n  }\n  map.consume(context.events)\n\n  // To do: move this into `html`, when events are exposed there.\n  // That’s what `markdown-rs` does.\n  // That needs updates to `mdast-util-gfm-table`.\n  index = -1\n  while (++index < context.events.length) {\n    const event = context.events[index]\n    if (event[0] === 'enter' && event[1].type === 'table') {\n      // @ts-expect-error: custom field.\n      event[1]._align = gfmTableAlign(context.events, index)\n    }\n  }\n  return events\n}\n\n/// Generate a cell.\n/**\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {Range} range\n * @param {RowKind} rowKind\n * @param {number | undefined} rowEnd\n * @param {Token | undefined} previousCell\n * @returns {Token | undefined}\n */\n// eslint-disable-next-line max-params\nfunction flushCell(map, context, range, rowKind, rowEnd, previousCell) {\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'\n  const groupName =\n    rowKind === 1\n      ? 'tableHeader'\n      : rowKind === 2\n      ? 'tableDelimiter'\n      : 'tableData'\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'\n  const valueName = 'tableContent'\n\n  // Insert an exit for the previous cell, if there is one.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //          ^-- exit\n  //           ^^^^-- this cell\n  // ```\n  if (range[0] !== 0) {\n    previousCell.end = Object.assign({}, getPoint(context.events, range[0]))\n    map.add(range[0], 0, [['exit', previousCell, context]])\n  }\n\n  // Insert enter of this cell.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //           ^-- enter\n  //           ^^^^-- this cell\n  // ```\n  const now = getPoint(context.events, range[1])\n  previousCell = {\n    type: groupName,\n    start: Object.assign({}, now),\n    // Note: correct end is set later.\n    end: Object.assign({}, now)\n  }\n  map.add(range[1], 0, [['enter', previousCell, context]])\n\n  // Insert text start at first data start and end at last data end, and\n  // remove events between.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //            ^-- enter\n  //             ^-- exit\n  //           ^^^^-- this cell\n  // ```\n  if (range[2] !== 0) {\n    const relatedStart = getPoint(context.events, range[2])\n    const relatedEnd = getPoint(context.events, range[3])\n    const valueToken = {\n      type: valueName,\n      start: Object.assign({}, relatedStart),\n      end: Object.assign({}, relatedEnd)\n    }\n    map.add(range[2], 0, [['enter', valueToken, context]])\n    if (rowKind !== 2) {\n      // Fix positional info on remaining events\n      const start = context.events[range[2]]\n      const end = context.events[range[3]]\n      start[1].end = Object.assign({}, end[1].end)\n      start[1].type = 'chunkText'\n      // @ts-expect-error It’s fine.\n      start[1].contentType = 'text'\n\n      // Remove if needed.\n      if (range[3] > range[2] + 1) {\n        const a = range[2] + 1\n        const b = range[3] - range[2] - 1\n        map.add(a, b, [])\n      }\n    }\n    map.add(range[3] + 1, 0, [['exit', valueToken, context]])\n  }\n\n  // Insert an exit for the last cell, if at the row end.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //                    ^-- exit\n  //               ^^^^^^-- this cell (the last one contains two “between” parts)\n  // ```\n  if (rowEnd !== undefined) {\n    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd))\n    map.add(rowEnd, 0, [['exit', previousCell, context]])\n    previousCell = undefined\n  }\n  return previousCell\n}\n\n/**\n * Generate table end (and table body end).\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {number} index\n * @param {Token} table\n * @param {Token | undefined} tableBody\n */\n// eslint-disable-next-line max-params\nfunction flushTableEnd(map, context, index, table, tableBody) {\n  /** @type {Array<Event>} */\n  const exits = []\n  const related = getPoint(context.events, index)\n  if (tableBody) {\n    tableBody.end = Object.assign({}, related)\n    exits.push(['exit', tableBody, context])\n  }\n  table.end = Object.assign({}, related)\n  exits.push(['exit', table, context])\n  map.add(index + 1, 0, exits)\n}\n\n/**\n * @param {Array<Event>} events\n * @param {number} index\n * @returns {readonly Point}\n */\nfunction getPoint(events, index) {\n  const event = events[index]\n  const side = event[0] === 'enter' ? 'start' : 'end'\n  return event[1][side]\n}\n"]},"metadata":{},"sourceType":"module"}