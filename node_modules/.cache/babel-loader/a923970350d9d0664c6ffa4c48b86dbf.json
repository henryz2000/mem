{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [cascade=true]\n *   Whether to drop parent nodes if they had children, but all their children\n *   were filtered out.\n */\nimport { convert } from 'unist-util-is';\nvar own = {}.hasOwnProperty;\n/**\n * Create a new `tree` of copies of all nodes that pass `test`.\n *\n * The tree is walked in *preorder* (NLR), visiting the node itself, then its\n * head, etc.\n *\n * @param tree\n *   Tree to filter.\n * @param options\n *   Configuration (optional).\n * @param test\n *   `unist-util-is` compatible test.\n * @returns\n *   New filtered tree.\n *\n *   `null` is returned if `tree` itself didn’t pass the test, or is cascaded\n *   away.\n */\n\nexport var filter =\n/**\n * @param {Node} tree\n * @param {Options | Test | null | undefined} [options]\n * @param {Test | null | undefined} [test]\n * @returns {Node | null}\n */\nfunction filter(tree, options, test) {\n  var is = convert(test || options);\n  /** @type {boolean | null | undefined} */\n\n  var cascadeRaw = options && typeof options === 'object' && 'cascade' in options ? options.cascade : undefined;\n  var cascade = cascadeRaw === undefined || cascadeRaw === null ? true : cascadeRaw;\n  return preorder(tree);\n  /**\n   * @param {Node} node\n   *   Current node.\n   * @param {number | undefined} [index]\n   *   Index of `node` in `parent`.\n   * @param {Parent | undefined} [parent]\n   *   Parent node.\n   * @returns {Node | null}\n   *   Shallow copy of `node`.\n   */\n\n  function preorder(node, index, parent) {\n    /** @type {Array<Node>} */\n    var children = [];\n    if (!is(node, index, parent)) return null; // @ts-expect-error: Looks like a parent.\n\n    if (node.children) {\n      var childIndex = -1; // @ts-expect-error Looks like a parent.\n\n      while (++childIndex < node.children.length) {\n        // @ts-expect-error Looks like a parent.\n        var result = preorder(node.children[childIndex], childIndex, node);\n\n        if (result) {\n          children.push(result);\n        }\n      } // @ts-expect-error Looks like a parent.\n\n\n      if (cascade && node.children.length > 0 && children.length === 0) return null;\n    } // Create a shallow clone, using the new children.\n\n    /** @type {typeof node} */\n    // @ts-expect-error all the fields will be copied over.\n\n\n    var next = {};\n    /** @type {string} */\n\n    var key;\n\n    for (key in node) {\n      if (own.call(node, key)) {\n        // @ts-expect-error: Looks like a record.\n        next[key] = key === 'children' ? children : node[key];\n      }\n    }\n\n    return next;\n  }\n};","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/unist-util-filter/lib/index.js"],"names":["convert","own","hasOwnProperty","filter","tree","options","test","is","cascadeRaw","cascade","undefined","preorder","node","index","parent","children","childIndex","length","result","push","next","key","call"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,OAAR,QAAsB,eAAtB;AAEA,IAAMC,GAAG,GAAG,GAAGC,cAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,MAAM;AASf;AACJ;AACA;AACA;AACA;AACA;AACI,SAfSA,MAeT,CAAUC,IAAV,EAAgBC,OAAhB,EAAyBC,IAAzB,EAA+B;AAC7B,MAAMC,EAAE,GAAGP,OAAO,CAACM,IAAI,IAAID,OAAT,CAAlB;AACA;;AACA,MAAMG,UAAU,GACdH,OAAO,IAAI,OAAOA,OAAP,KAAmB,QAA9B,IAA0C,aAAaA,OAAvD,GAC+CA,OAAO,CAACI,OADvD,GAEIC,SAHN;AAIA,MAAMD,OAAO,GACXD,UAAU,KAAKE,SAAf,IAA4BF,UAAU,KAAK,IAA3C,GAAkD,IAAlD,GAAyDA,UAD3D;AAGA,SAAOG,QAAQ,CAACP,IAAD,CAAf;AAEA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACM,WAASO,QAAT,CAAkBC,IAAlB,EAAwBC,KAAxB,EAA+BC,MAA/B,EAAuC;AACrC;AACA,QAAMC,QAAQ,GAAG,EAAjB;AAEA,QAAI,CAACR,EAAE,CAACK,IAAD,EAAOC,KAAP,EAAcC,MAAd,CAAP,EAA8B,OAAO,IAAP,CAJO,CAMrC;;AACA,QAAIF,IAAI,CAACG,QAAT,EAAmB;AACjB,UAAIC,UAAU,GAAG,CAAC,CAAlB,CADiB,CAGjB;;AACA,aAAO,EAAEA,UAAF,GAAeJ,IAAI,CAACG,QAAL,CAAcE,MAApC,EAA4C;AAC1C;AACA,YAAMC,MAAM,GAAGP,QAAQ,CAACC,IAAI,CAACG,QAAL,CAAcC,UAAd,CAAD,EAA4BA,UAA5B,EAAwCJ,IAAxC,CAAvB;;AAEA,YAAIM,MAAJ,EAAY;AACVH,UAAAA,QAAQ,CAACI,IAAT,CAAcD,MAAd;AACD;AACF,OAXgB,CAajB;;;AACA,UAAIT,OAAO,IAAIG,IAAI,CAACG,QAAL,CAAcE,MAAd,GAAuB,CAAlC,IAAuCF,QAAQ,CAACE,MAAT,KAAoB,CAA/D,EACE,OAAO,IAAP;AACH,KAvBoC,CAyBrC;;AACA;AACA;;;AACA,QAAMG,IAAI,GAAG,EAAb;AACA;;AACA,QAAIC,GAAJ;;AAEA,SAAKA,GAAL,IAAYT,IAAZ,EAAkB;AAChB,UAAIX,GAAG,CAACqB,IAAJ,CAASV,IAAT,EAAeS,GAAf,CAAJ,EAAyB;AACvB;AACAD,QAAAA,IAAI,CAACC,GAAD,CAAJ,GAAYA,GAAG,KAAK,UAAR,GAAqBN,QAArB,GAAgCH,IAAI,CAACS,GAAD,CAAhD;AACD;AACF;;AAED,WAAOD,IAAP;AACD;AACF,CA9EE","sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [cascade=true]\n *   Whether to drop parent nodes if they had children, but all their children\n *   were filtered out.\n */\n\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a new `tree` of copies of all nodes that pass `test`.\n *\n * The tree is walked in *preorder* (NLR), visiting the node itself, then its\n * head, etc.\n *\n * @param tree\n *   Tree to filter.\n * @param options\n *   Configuration (optional).\n * @param test\n *   `unist-util-is` compatible test.\n * @returns\n *   New filtered tree.\n *\n *   `null` is returned if `tree` itself didn’t pass the test, or is cascaded\n *   away.\n */\nexport const filter =\n  /**\n   * @type {(\n   *  (<Tree extends Node, Check extends Test>(node: Tree, options: Options | null | undefined, test: Check | null | undefined) => import('./complex-types.js').Matches<Tree, Check>) &\n   *  (<Tree extends Node, Check extends Test>(node: Tree, test: Check) => import('./complex-types.js').Matches<Tree, Check>) &\n   *  (<Tree extends Node>(node: Tree, options?: Options | null | undefined) => Tree)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Options | Test | null | undefined} [options]\n     * @param {Test | null | undefined} [test]\n     * @returns {Node | null}\n     */\n    function (tree, options, test) {\n      const is = convert(test || options)\n      /** @type {boolean | null | undefined} */\n      const cascadeRaw =\n        options && typeof options === 'object' && 'cascade' in options\n          ? /** @type {boolean | null | undefined} */ (options.cascade)\n          : undefined\n      const cascade =\n        cascadeRaw === undefined || cascadeRaw === null ? true : cascadeRaw\n\n      return preorder(tree)\n\n      /**\n       * @param {Node} node\n       *   Current node.\n       * @param {number | undefined} [index]\n       *   Index of `node` in `parent`.\n       * @param {Parent | undefined} [parent]\n       *   Parent node.\n       * @returns {Node | null}\n       *   Shallow copy of `node`.\n       */\n      function preorder(node, index, parent) {\n        /** @type {Array<Node>} */\n        const children = []\n\n        if (!is(node, index, parent)) return null\n\n        // @ts-expect-error: Looks like a parent.\n        if (node.children) {\n          let childIndex = -1\n\n          // @ts-expect-error Looks like a parent.\n          while (++childIndex < node.children.length) {\n            // @ts-expect-error Looks like a parent.\n            const result = preorder(node.children[childIndex], childIndex, node)\n\n            if (result) {\n              children.push(result)\n            }\n          }\n\n          // @ts-expect-error Looks like a parent.\n          if (cascade && node.children.length > 0 && children.length === 0)\n            return null\n        }\n\n        // Create a shallow clone, using the new children.\n        /** @type {typeof node} */\n        // @ts-expect-error all the fields will be copied over.\n        const next = {}\n        /** @type {string} */\n        let key\n\n        for (key in node) {\n          if (own.call(node, key)) {\n            // @ts-expect-error: Looks like a record.\n            next[key] = key === 'children' ? children : node[key]\n          }\n        }\n\n        return next\n      }\n    }\n  )\n"]},"metadata":{},"sourceType":"module"}