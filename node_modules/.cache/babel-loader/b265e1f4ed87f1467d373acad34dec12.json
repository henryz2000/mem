{"ast":null,"code":"import _toConsumableArray from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n// Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, it’s needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, it’s needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n\n/**\n * @typedef {[number, number, Array<Event>]} Change\n * @typedef {[number, number, number]} Jump\n */\n\n/**\n * Tracks a bunch of edits.\n */\nexport var EditMap = /*#__PURE__*/function () {\n  /**\n   * Create a new edit map.\n   */\n  function EditMap() {\n    _classCallCheck(this, EditMap);\n\n    /**\n     * Record of changes.\n     *\n     * @type {Array<Change>}\n     */\n    this.map = [];\n  }\n  /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {void}\n   */\n\n\n  _createClass(EditMap, [{\n    key: \"add\",\n    value: function add(index, remove, _add) {\n      addImpl(this, index, remove, _add);\n    } // To do: not used here.\n    // /**\n    //  * Create an edit: but insert `add` before existing additions.\n    //  *\n    //  * @param {number} index\n    //  * @param {number} remove\n    //  * @param {Array<Event>} add\n    //  * @returns {void}\n    //  */\n    // addBefore(index, remove, add) {\n    //   addImpl(this, index, remove, add, true)\n    // }\n\n    /**\n     * Done, change the events.\n     *\n     * @param {Array<Event>} events\n     * @returns {void}\n     */\n\n  }, {\n    key: \"consume\",\n    value: function consume(events) {\n      this.map.sort(function (a, b) {\n        return a[0] - b[0];\n      });\n      /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n\n      if (this.map.length === 0) {\n        return;\n      } // To do: if links are added in events, like they are in `markdown-rs`,\n      // this is needed.\n      // // Calculate jumps: where items in the current list move to.\n      // /** @type {Array<Jump>} */\n      // const jumps = []\n      // let index = 0\n      // let addAcc = 0\n      // let removeAcc = 0\n      // while (index < this.map.length) {\n      //   const [at, remove, add] = this.map[index]\n      //   removeAcc += remove\n      //   addAcc += add.length\n      //   jumps.push([at, removeAcc, addAcc])\n      //   index += 1\n      // }\n      //\n      // . shiftLinks(events, jumps)\n\n\n      var index = this.map.length;\n      /** @type {Array<Array<Event>>} */\n\n      var vecs = [];\n\n      while (index > 0) {\n        index -= 1;\n        vecs.push(events.slice(this.map[index][0] + this.map[index][1])); // eslint-disable-next-line unicorn/no-array-push-push\n\n        vecs.push(this.map[index][2]); // Truncate rest.\n\n        events.length = this.map[index][0];\n      }\n\n      vecs.push(_toConsumableArray(events));\n      events.length = 0;\n      var slice = vecs.pop();\n\n      while (slice) {\n        events.push.apply(events, _toConsumableArray(slice));\n        slice = vecs.pop();\n      } // Truncate everything.\n\n\n      this.map.length = 0;\n    }\n  }]);\n\n  return EditMap;\n}();\n/**\n * Create an edit.\n *\n * @param {EditMap} editMap\n * @param {number} at\n * @param {number} remove\n * @param {Array<Event>} add\n * @returns {void}\n */\n\nfunction addImpl(editMap, at, remove, add) {\n  var index = 0;\n  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n\n  if (remove === 0 && add.length === 0) {\n    return;\n  }\n\n  while (index < editMap.map.length) {\n    if (editMap.map[index][0] === at) {\n      var _editMap$map$index$;\n\n      editMap.map[index][1] += remove; // To do: before not used.\n      // if (before) {\n      //   add.push(...editMap.map[index][2])\n      //   editMap.map[index][2] = add\n      // } else {\n\n      (_editMap$map$index$ = editMap.map[index][2]).push.apply(_editMap$map$index$, _toConsumableArray(add)); // }\n\n\n      return;\n    }\n\n    index += 1;\n  }\n\n  editMap.map.push([at, remove, add]);\n} // /**\n//  * Shift `previous` and `next` links according to `jumps`.\n//  *\n//  * This fixes links in case there are events removed or added between them.\n//  *\n//  * @param {Array<Event>} events\n//  * @param {Array<Jump>} jumps\n//  */\n// function shiftLinks(events, jumps) {\n//   let jumpIndex = 0\n//   let index = 0\n//   let add = 0\n//   let rm = 0\n//   while (index < events.length) {\n//     const rmCurr = rm\n//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n//       add = jumps[jumpIndex][2]\n//       rm = jumps[jumpIndex][1]\n//       jumpIndex += 1\n//     }\n//     // Ignore items that will be removed.\n//     if (rm > rmCurr) {\n//       index += rm - rmCurr\n//     } else {\n//       console.log('to do: links?', add, rmCurr)\n//       // ?\n//       // if let Some(link) = &events[index].link {\n//       //     if let Some(next) = link.next {\n//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n//       //             add = jumps[jumpIndex].2;\n//       //             rm = jumps[jumpIndex].1;\n//       //             jumpIndex += 1;\n//       //         }\n//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n//       //         index = next;\n//       //         continue;\n//       //     }\n//       // }\n//       index += 1\n//     }\n//   }\n// }","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/micromark-extension-gfm-table/lib/edit-map.js"],"names":["EditMap","map","index","remove","add","addImpl","events","sort","a","b","length","vecs","push","slice","pop","editMap","at"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n// Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, it’s needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, it’s needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n\n/**\n * @typedef {[number, number, Array<Event>]} Change\n * @typedef {[number, number, number]} Jump\n */\n\n/**\n * Tracks a bunch of edits.\n */\nexport class EditMap {\n  /**\n   * Create a new edit map.\n   */\n  constructor() {\n    /**\n     * Record of changes.\n     *\n     * @type {Array<Change>}\n     */\n    this.map = []\n  }\n\n  /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {void}\n   */\n  add(index, remove, add) {\n    addImpl(this, index, remove, add)\n  }\n\n  // To do: not used here.\n  // /**\n  //  * Create an edit: but insert `add` before existing additions.\n  //  *\n  //  * @param {number} index\n  //  * @param {number} remove\n  //  * @param {Array<Event>} add\n  //  * @returns {void}\n  //  */\n  // addBefore(index, remove, add) {\n  //   addImpl(this, index, remove, add, true)\n  // }\n\n  /**\n   * Done, change the events.\n   *\n   * @param {Array<Event>} events\n   * @returns {void}\n   */\n  consume(events) {\n    this.map.sort((a, b) => a[0] - b[0])\n\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n    if (this.map.length === 0) {\n      return\n    }\n\n    // To do: if links are added in events, like they are in `markdown-rs`,\n    // this is needed.\n    // // Calculate jumps: where items in the current list move to.\n    // /** @type {Array<Jump>} */\n    // const jumps = []\n    // let index = 0\n    // let addAcc = 0\n    // let removeAcc = 0\n    // while (index < this.map.length) {\n    //   const [at, remove, add] = this.map[index]\n    //   removeAcc += remove\n    //   addAcc += add.length\n    //   jumps.push([at, removeAcc, addAcc])\n    //   index += 1\n    // }\n    //\n    // . shiftLinks(events, jumps)\n\n    let index = this.map.length\n    /** @type {Array<Array<Event>>} */\n    const vecs = []\n    while (index > 0) {\n      index -= 1\n      vecs.push(events.slice(this.map[index][0] + this.map[index][1]))\n      // eslint-disable-next-line unicorn/no-array-push-push\n      vecs.push(this.map[index][2])\n\n      // Truncate rest.\n      events.length = this.map[index][0]\n    }\n    vecs.push([...events])\n    events.length = 0\n    let slice = vecs.pop()\n    while (slice) {\n      events.push(...slice)\n      slice = vecs.pop()\n    }\n\n    // Truncate everything.\n    this.map.length = 0\n  }\n}\n\n/**\n * Create an edit.\n *\n * @param {EditMap} editMap\n * @param {number} at\n * @param {number} remove\n * @param {Array<Event>} add\n * @returns {void}\n */\nfunction addImpl(editMap, at, remove, add) {\n  let index = 0\n\n  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n  if (remove === 0 && add.length === 0) {\n    return\n  }\n  while (index < editMap.map.length) {\n    if (editMap.map[index][0] === at) {\n      editMap.map[index][1] += remove\n\n      // To do: before not used.\n      // if (before) {\n      //   add.push(...editMap.map[index][2])\n      //   editMap.map[index][2] = add\n      // } else {\n      editMap.map[index][2].push(...add)\n      // }\n\n      return\n    }\n    index += 1\n  }\n  editMap.map.push([at, remove, add])\n}\n\n// /**\n//  * Shift `previous` and `next` links according to `jumps`.\n//  *\n//  * This fixes links in case there are events removed or added between them.\n//  *\n//  * @param {Array<Event>} events\n//  * @param {Array<Jump>} jumps\n//  */\n// function shiftLinks(events, jumps) {\n//   let jumpIndex = 0\n//   let index = 0\n//   let add = 0\n//   let rm = 0\n\n//   while (index < events.length) {\n//     const rmCurr = rm\n\n//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n//       add = jumps[jumpIndex][2]\n//       rm = jumps[jumpIndex][1]\n//       jumpIndex += 1\n//     }\n\n//     // Ignore items that will be removed.\n//     if (rm > rmCurr) {\n//       index += rm - rmCurr\n//     } else {\n//       console.log('to do: links?', add, rmCurr)\n//       // ?\n//       // if let Some(link) = &events[index].link {\n//       //     if let Some(next) = link.next {\n//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n//       //             add = jumps[jumpIndex].2;\n//       //             rm = jumps[jumpIndex].1;\n//       //             jumpIndex += 1;\n//       //         }\n//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n//       //         index = next;\n//       //         continue;\n//       //     }\n//       // }\n//       index += 1\n//     }\n//   }\n// }\n"]},"metadata":{},"sourceType":"module"}