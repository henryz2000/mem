{"ast":null,"code":"import _defineProperty from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEndingOrSpace, markdownLineEnding, markdownSpace } from 'micromark-util-character';\nvar tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}; // To do: next major: expose function to make extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions`, to\n * enable GFM task list items syntax.\n *\n * @type {Extension}\n */\n\nexport var gfmTaskListItem = {\n  text: _defineProperty({}, 91, tasklistCheck)\n};\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  var self = this;\n  return open;\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function open(code) {\n    if ( // Exit if there’s stuff before.\n    self.previous !== null || // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n\n    return nok(code);\n  }\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return after;\n    }\n\n    return nok(code);\n  }\n  /**\n   * @type {State}\n   */\n\n\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code);\n    } // Space or tab?\n    // Check what comes after.\n\n\n    if (markdownSpace(code)) {\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok)(code);\n    } // EOF, or non-whitespace, both wrong.\n\n\n    return nok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, 'whitespace');\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means there’s content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js"],"names":["factorySpace","markdownLineEndingOrSpace","markdownLineEnding","markdownSpace","tasklistCheck","tokenize","tokenizeTasklistCheck","gfmTaskListItem","text","effects","ok","nok","self","open","code","previous","_gfmTasklistFirstContentOfListItem","enter","consume","exit","inside","close","after","check","spaceThenNonSpace"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  markdownSpace\n} from 'micromark-util-character'\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}\n\n// To do: next major: expose function to make extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions`, to\n * enable GFM task list items syntax.\n *\n * @type {Extension}\n */\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n  return open\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n      // Exit if there’s stuff before.\n      self.previous !== null ||\n      // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n    return nok(code)\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code)\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check(\n        {\n          tokenize: spaceThenNonSpace\n        },\n        ok,\n        nok\n      )(code)\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, 'whitespace')\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means there’s content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}