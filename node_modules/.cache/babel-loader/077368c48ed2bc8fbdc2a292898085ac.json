{"ast":null,"code":"import _objectSpread from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\n/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RulePseudo} RulePseudo\n * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').ElementChild} ElementChild\n */\nimport { extendedFilter } from 'bcp-47-match';\nimport { parse as commas } from 'comma-separated-tokens';\nimport { hasProperty } from 'hast-util-has-property';\nimport { whitespace } from 'hast-util-whitespace';\nimport fauxEsmNthCheck from 'nth-check';\nimport { zwitch } from 'zwitch';\nimport { queryToSelectors, walk } from './walk.js';\n/** @type {import('nth-check').default} */\n// @ts-expect-error\n\nvar nthCheck = fauxEsmNthCheck.default || fauxEsmNthCheck;\n/** @type {(rule: Rule | RulePseudo, element: Element, index: number | undefined, parent: Parent | undefined, state: SelectState) => boolean} */\n\nvar handle = zwitch('name', {\n  unknown: unknownPseudo,\n  invalid: invalidPseudo,\n  handlers: {\n    any: matches,\n    'any-link': anyLink,\n    blank: blank,\n    checked: checked,\n    dir: dir,\n    disabled: disabled,\n    empty: empty,\n    enabled: enabled,\n    'first-child': firstChild,\n    'first-of-type': firstOfType,\n    has: has,\n    lang: lang,\n    'last-child': lastChild,\n    'last-of-type': lastOfType,\n    matches: matches,\n    not: not,\n    'nth-child': nthChild,\n    'nth-last-child': nthLastChild,\n    'nth-of-type': nthOfType,\n    'nth-last-of-type': nthLastOfType,\n    'only-child': onlyChild,\n    'only-of-type': onlyOfType,\n    optional: optional,\n    'read-only': readOnly,\n    'read-write': readWrite,\n    required: required,\n    root: root,\n    scope: scope\n  }\n});\npseudo.needsIndex = ['any', 'first-child', 'first-of-type', 'last-child', 'last-of-type', 'matches', 'not', 'nth-child', 'nth-last-child', 'nth-of-type', 'nth-last-of-type', 'only-child', 'only-of-type'];\n/**\n * Check whether an element matches pseudo selectors.\n *\n * @param {Rule} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\n\nexport function pseudo(query, element, index, parent, state) {\n  var pseudos = query.pseudos;\n  var offset = -1;\n\n  while (++offset < pseudos.length) {\n    if (!handle(pseudos[offset], element, index, parent, state)) return false;\n  }\n\n  return true;\n}\n/**\n * Check whether an element matches an `:any-link` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\nfunction anyLink(_, element) {\n  return (element.tagName === 'a' || element.tagName === 'area' || element.tagName === 'link') && hasProperty(element, 'href');\n}\n/**\n * Check whether an element matches a `:blank` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction blank(_, element) {\n  return !someChildren(element, check);\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n\n  function check(child) {\n    return child.type === 'element' || child.type === 'text' && !whitespace(child);\n  }\n}\n/**\n * Check whether an element matches a `:checked` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction checked(_, element) {\n  if (element.tagName === 'input' || element.tagName === 'menuitem') {\n    return Boolean(element.properties && (element.properties.type === 'checkbox' || element.properties.type === 'radio') && hasProperty(element, 'checked'));\n  }\n\n  if (element.tagName === 'option') {\n    return hasProperty(element, 'selected');\n  }\n\n  return false;\n}\n/**\n * Check whether an element matches a `:dir()` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction dir(query, _1, _2, _3, state) {\n  return state.direction === query.value;\n}\n/**\n * Check whether an element matches a `:disabled` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction disabled(_, element) {\n  return (element.tagName === 'button' || element.tagName === 'input' || element.tagName === 'select' || element.tagName === 'textarea' || element.tagName === 'optgroup' || element.tagName === 'option' || element.tagName === 'menuitem' || element.tagName === 'fieldset') && hasProperty(element, 'disabled');\n}\n/**\n * Check whether an element matches an `:empty` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction empty(_, element) {\n  return !someChildren(element, check);\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n\n  function check(child) {\n    return child.type === 'element' || child.type === 'text';\n  }\n}\n/**\n * Check whether an element matches an `:enabled` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction enabled(query, element) {\n  return !disabled(query, element);\n}\n/**\n * Check whether an element matches a `:first-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.elementIndex === 0;\n}\n/**\n * Check whether an element matches a `:first-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.typeIndex === 0;\n}\n/**\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction has(query, element, _1, _2, state) {\n  /** @type {SelectState} */\n  var childState = _objectSpread(_objectSpread({}, state), {}, {\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeElements: [element],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  });\n\n  walk(childState, {\n    type: 'root',\n    children: element.children\n  });\n  return childState.results.length > 0;\n}\n/**\n * Check whether an element matches a `:lang()` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction lang(query, _1, _2, _3, state) {\n  return state.language !== '' && state.language !== undefined && // @ts-expect-error never `selectors`.\n  extendedFilter(state.language, commas(query.value)).length > 0;\n}\n/**\n * Check whether an element matches a `:last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return Boolean(state.elementCount && state.elementIndex === state.elementCount - 1);\n}\n/**\n * Check whether an element matches a `:last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return typeof state.typeIndex === 'number' && typeof state.typeCount === 'number' && state.typeIndex === state.typeCount - 1;\n}\n/**\n * Check whether an element `:matches` further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} _\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction matches(query, element, _, parent, state) {\n  /** @type {SelectState} */\n  var childState = _objectSpread(_objectSpread({}, state), {}, {\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeElements: [element],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  });\n\n  walk(childState, element);\n  return childState.results[0] === element;\n}\n/**\n * Check whether an element does `:not` match further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction not(query, element, index, parent, state) {\n  return !matches(query, element, index, parent, state);\n}\n/**\n * Check whether an element matches an `:nth-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction nthChild(query, _1, _2, _3, state) {\n  var fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.elementIndex === 'number' && fn(state.elementIndex);\n}\n/**\n * Check whether an element matches an `:nth-last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction nthLastChild(query, _1, _2, _3, state) {\n  var fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return Boolean(typeof state.elementCount === 'number' && typeof state.elementIndex === 'number' && fn(state.elementCount - state.elementIndex - 1));\n}\n/**\n * Check whether an element matches a `:nth-last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  var fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.typeCount === 'number' && typeof state.typeIndex === 'number' && fn(state.typeCount - 1 - state.typeIndex);\n}\n/**\n * Check whether an element matches an `:nth-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction nthOfType(query, _1, _2, _3, state) {\n  var fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.typeIndex === 'number' && fn(state.typeIndex);\n}\n/**\n * Check whether an element matches an `:only-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.elementCount === 1;\n}\n/**\n * Check whether an element matches an `:only-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.typeCount === 1;\n}\n/**\n * Check whether an element matches an `:optional` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction optional(query, element) {\n  return !required(query, element);\n}\n/**\n * Check whether an element matches a `:read-only` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction readOnly(query, element, index, parent, state) {\n  return !readWrite(query, element, index, parent, state);\n}\n/**\n * Check whether an element matches a `:read-write` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction readWrite(_, element, _1, _2, state) {\n  return element.tagName === 'input' || element.tagName === 'textarea' ? !hasProperty(element, 'readOnly') && !hasProperty(element, 'disabled') : Boolean(state.editableOrEditingHost);\n}\n/**\n * Check whether an element matches a `:required` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\n\n\nfunction required(_, element) {\n  return (element.tagName === 'input' || element.tagName === 'textarea' || element.tagName === 'select') && hasProperty(element, 'required');\n}\n/**\n * Check whether an element matches a `:root` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction root(_, element, _1, parent, state) {\n  return Boolean((!parent || parent.type === 'root') && state.schema && (state.schema.space === 'html' || state.schema.space === 'svg') && (element.tagName === 'html' || element.tagName === 'svg'));\n}\n/**\n * Check whether an element matches a `:scope` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\n\n\nfunction scope(_, element, _1, _2, state) {\n  return state.scopeElements.includes(element);\n} // Shouldn’t be called, parser gives correct data.\n\n/* c8 ignore next 3 */\n\n\nfunction invalidPseudo() {\n  throw new Error('Invalid pseudo-selector');\n}\n/**\n * @param {unknown} query\n * @returns {never}\n */\n\n\nfunction unknownPseudo(query) {\n  // @ts-expect-error: indexable.\n  if (query.name) {\n    // @ts-expect-error: indexable.\n    throw new Error('Unknown pseudo-selector `' + query.name + '`');\n  }\n\n  throw new Error('Unexpected pseudo-element or empty pseudo-class');\n}\n/**\n * Check children.\n *\n * @param {Element} element\n * @param {(child: ElementChild) => boolean} check\n * @returns {boolean}\n */\n\n\nfunction someChildren(element, check) {\n  var children = element.children;\n  var index = -1;\n\n  while (++index < children.length) {\n    if (check(children[index])) return true;\n  }\n\n  return false;\n}\n/**\n * @param {SelectState} state\n * @param {RulePseudo} query\n */\n\n\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent');\n  }\n}\n/**\n * @param {RulePseudo} query\n * @returns {(value: number) => boolean}\n */\n\n\nfunction getCachedNthCheck(query) {\n  /** @type {(value: number) => boolean} */\n  // @ts-expect-error: cache.\n  var fn = query._cachedFn;\n\n  if (!fn) {\n    // @ts-expect-error: always string.\n    fn = nthCheck(query.value); // @ts-expect-error: cache.\n\n    query._cachedFn = fn;\n  }\n\n  return fn;\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/hast-util-select/lib/pseudo.js"],"names":["extendedFilter","parse","commas","hasProperty","whitespace","fauxEsmNthCheck","zwitch","queryToSelectors","walk","nthCheck","default","handle","unknown","unknownPseudo","invalid","invalidPseudo","handlers","any","matches","anyLink","blank","checked","dir","disabled","empty","enabled","firstChild","firstOfType","has","lang","lastChild","lastOfType","not","nthChild","nthLastChild","nthOfType","nthLastOfType","onlyChild","onlyOfType","optional","readOnly","readWrite","required","root","scope","pseudo","needsIndex","query","element","index","parent","state","pseudos","offset","length","_","tagName","someChildren","check","child","type","Boolean","properties","_1","_2","_3","direction","value","assertDeep","elementIndex","typeIndex","childState","found","shallow","one","scopeElements","results","rootQuery","children","language","undefined","elementCount","typeCount","fn","getCachedNthCheck","editableOrEditingHost","schema","space","includes","Error","name","_cachedFn"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RulePseudo} RulePseudo\n * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').ElementChild} ElementChild\n */\n\nimport {extendedFilter} from 'bcp-47-match'\nimport {parse as commas} from 'comma-separated-tokens'\nimport {hasProperty} from 'hast-util-has-property'\nimport {whitespace} from 'hast-util-whitespace'\nimport fauxEsmNthCheck from 'nth-check'\nimport {zwitch} from 'zwitch'\nimport {queryToSelectors, walk} from './walk.js'\n\n/** @type {import('nth-check').default} */\n// @ts-expect-error\nconst nthCheck = fauxEsmNthCheck.default || fauxEsmNthCheck\n\n/** @type {(rule: Rule | RulePseudo, element: Element, index: number | undefined, parent: Parent | undefined, state: SelectState) => boolean} */\nconst handle = zwitch('name', {\n  unknown: unknownPseudo,\n  invalid: invalidPseudo,\n  handlers: {\n    any: matches,\n    'any-link': anyLink,\n    blank,\n    checked,\n    dir,\n    disabled,\n    empty,\n    enabled,\n    'first-child': firstChild,\n    'first-of-type': firstOfType,\n    has,\n    lang,\n    'last-child': lastChild,\n    'last-of-type': lastOfType,\n    matches,\n    not,\n    'nth-child': nthChild,\n    'nth-last-child': nthLastChild,\n    'nth-of-type': nthOfType,\n    'nth-last-of-type': nthLastOfType,\n    'only-child': onlyChild,\n    'only-of-type': onlyOfType,\n    optional,\n    'read-only': readOnly,\n    'read-write': readWrite,\n    required,\n    root,\n    scope\n  }\n})\n\npseudo.needsIndex = [\n  'any',\n  'first-child',\n  'first-of-type',\n  'last-child',\n  'last-of-type',\n  'matches',\n  'not',\n  'nth-child',\n  'nth-last-child',\n  'nth-of-type',\n  'nth-last-of-type',\n  'only-child',\n  'only-of-type'\n]\n\n/**\n * Check whether an element matches pseudo selectors.\n *\n * @param {Rule} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nexport function pseudo(query, element, index, parent, state) {\n  const pseudos = query.pseudos\n  let offset = -1\n\n  while (++offset < pseudos.length) {\n    if (!handle(pseudos[offset], element, index, parent, state)) return false\n  }\n\n  return true\n}\n\n/**\n * Check whether an element matches an `:any-link` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction anyLink(_, element) {\n  return (\n    (element.tagName === 'a' ||\n      element.tagName === 'area' ||\n      element.tagName === 'link') &&\n    hasProperty(element, 'href')\n  )\n}\n\n/**\n * Check whether an element matches a `:blank` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction blank(_, element) {\n  return !someChildren(element, check)\n\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return (\n      child.type === 'element' || (child.type === 'text' && !whitespace(child))\n    )\n  }\n}\n\n/**\n * Check whether an element matches a `:checked` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction checked(_, element) {\n  if (element.tagName === 'input' || element.tagName === 'menuitem') {\n    return Boolean(\n      element.properties &&\n        (element.properties.type === 'checkbox' ||\n          element.properties.type === 'radio') &&\n        hasProperty(element, 'checked')\n    )\n  }\n\n  if (element.tagName === 'option') {\n    return hasProperty(element, 'selected')\n  }\n\n  return false\n}\n\n/**\n * Check whether an element matches a `:dir()` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction dir(query, _1, _2, _3, state) {\n  return state.direction === query.value\n}\n\n/**\n * Check whether an element matches a `:disabled` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction disabled(_, element) {\n  return (\n    (element.tagName === 'button' ||\n      element.tagName === 'input' ||\n      element.tagName === 'select' ||\n      element.tagName === 'textarea' ||\n      element.tagName === 'optgroup' ||\n      element.tagName === 'option' ||\n      element.tagName === 'menuitem' ||\n      element.tagName === 'fieldset') &&\n    hasProperty(element, 'disabled')\n  )\n}\n\n/**\n * Check whether an element matches an `:empty` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction empty(_, element) {\n  return !someChildren(element, check)\n\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return child.type === 'element' || child.type === 'text'\n  }\n}\n\n/**\n * Check whether an element matches an `:enabled` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\nfunction enabled(query, element) {\n  return !disabled(query, element)\n}\n\n/**\n * Check whether an element matches a `:first-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.elementIndex === 0\n}\n\n/**\n * Check whether an element matches a `:first-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeIndex === 0\n}\n\n/**\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction has(query, element, _1, _2, state) {\n  /** @type {SelectState} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeElements: [element],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  }\n\n  walk(childState, {type: 'root', children: element.children})\n\n  return childState.results.length > 0\n}\n\n/**\n * Check whether an element matches a `:lang()` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lang(query, _1, _2, _3, state) {\n  return (\n    state.language !== '' &&\n    state.language !== undefined &&\n    // @ts-expect-error never `selectors`.\n    extendedFilter(state.language, commas(query.value)).length > 0\n  )\n}\n\n/**\n * Check whether an element matches a `:last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return Boolean(\n    state.elementCount && state.elementIndex === state.elementCount - 1\n  )\n}\n\n/**\n * Check whether an element matches a `:last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.typeIndex === 'number' &&\n    typeof state.typeCount === 'number' &&\n    state.typeIndex === state.typeCount - 1\n  )\n}\n\n/**\n * Check whether an element `:matches` further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} _\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction matches(query, element, _, parent, state) {\n  /** @type {SelectState} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeElements: [element],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  }\n\n  walk(childState, element)\n\n  return childState.results[0] === element\n}\n\n/**\n * Check whether an element does `:not` match further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction not(query, element, index, parent, state) {\n  return !matches(query, element, index, parent, state)\n}\n\n/**\n * Check whether an element matches an `:nth-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.elementIndex === 'number' && fn(state.elementIndex)\n}\n\n/**\n * Check whether an element matches an `:nth-last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return Boolean(\n    typeof state.elementCount === 'number' &&\n      typeof state.elementIndex === 'number' &&\n      fn(state.elementCount - state.elementIndex - 1)\n  )\n}\n\n/**\n * Check whether an element matches a `:nth-last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return (\n    typeof state.typeCount === 'number' &&\n    typeof state.typeIndex === 'number' &&\n    fn(state.typeCount - 1 - state.typeIndex)\n  )\n}\n\n/**\n * Check whether an element matches an `:nth-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.typeIndex === 'number' && fn(state.typeIndex)\n}\n\n/**\n * Check whether an element matches an `:only-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.elementCount === 1\n}\n\n/**\n * Check whether an element matches an `:only-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeCount === 1\n}\n\n/**\n * Check whether an element matches an `:optional` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\nfunction optional(query, element) {\n  return !required(query, element)\n}\n\n/**\n * Check whether an element matches a `:read-only` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction readOnly(query, element, index, parent, state) {\n  return !readWrite(query, element, index, parent, state)\n}\n\n/**\n * Check whether an element matches a `:read-write` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction readWrite(_, element, _1, _2, state) {\n  return element.tagName === 'input' || element.tagName === 'textarea'\n    ? !hasProperty(element, 'readOnly') && !hasProperty(element, 'disabled')\n    : Boolean(state.editableOrEditingHost)\n}\n\n/**\n * Check whether an element matches a `:required` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction required(_, element) {\n  return (\n    (element.tagName === 'input' ||\n      element.tagName === 'textarea' ||\n      element.tagName === 'select') &&\n    hasProperty(element, 'required')\n  )\n}\n\n/**\n * Check whether an element matches a `:root` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction root(_, element, _1, parent, state) {\n  return Boolean(\n    (!parent || parent.type === 'root') &&\n      state.schema &&\n      (state.schema.space === 'html' || state.schema.space === 'svg') &&\n      (element.tagName === 'html' || element.tagName === 'svg')\n  )\n}\n\n/**\n * Check whether an element matches a `:scope` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction scope(_, element, _1, _2, state) {\n  return state.scopeElements.includes(element)\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidPseudo() {\n  throw new Error('Invalid pseudo-selector')\n}\n\n/**\n * @param {unknown} query\n * @returns {never}\n */\nfunction unknownPseudo(query) {\n  // @ts-expect-error: indexable.\n  if (query.name) {\n    // @ts-expect-error: indexable.\n    throw new Error('Unknown pseudo-selector `' + query.name + '`')\n  }\n\n  throw new Error('Unexpected pseudo-element or empty pseudo-class')\n}\n\n/**\n * Check children.\n *\n * @param {Element} element\n * @param {(child: ElementChild) => boolean} check\n * @returns {boolean}\n */\nfunction someChildren(element, check) {\n  const children = element.children\n  let index = -1\n\n  while (++index < children.length) {\n    if (check(children[index])) return true\n  }\n\n  return false\n}\n\n/**\n * @param {SelectState} state\n * @param {RulePseudo} query\n */\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent')\n  }\n}\n\n/**\n * @param {RulePseudo} query\n * @returns {(value: number) => boolean}\n */\nfunction getCachedNthCheck(query) {\n  /** @type {(value: number) => boolean} */\n  // @ts-expect-error: cache.\n  let fn = query._cachedFn\n\n  if (!fn) {\n    // @ts-expect-error: always string.\n    fn = nthCheck(query.value)\n    // @ts-expect-error: cache.\n    query._cachedFn = fn\n  }\n\n  return fn\n}\n"]},"metadata":{},"sourceType":"module"}