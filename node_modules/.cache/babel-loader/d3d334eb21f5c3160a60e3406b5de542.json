{"ast":null,"code":"/**\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5Fragment\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['documentType']} P5Doctype\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['parentNode']} P5Parent\n * @typedef {import('parse5').Token.Attribute} P5Attribute\n * @typedef {Exclude<P5Node, P5Document | P5Fragment>} P5Child\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {'html' | 'svg'} Space\n *\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in.\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n */\nimport { stringify as commas } from 'comma-separated-tokens';\nimport { html, svg, find } from 'property-information';\nimport { stringify as spaces } from 'space-separated-tokens';\nimport { webNamespaces } from 'web-namespaces';\nimport { zwitch } from 'zwitch';\nvar own = {}.hasOwnProperty;\n/** @type {(from: Node, schema: Schema) => P5Node} */\n\nvar one = zwitch('type', {\n  handlers: {\n    root: root,\n    element: element,\n    text: text,\n    comment: comment,\n    doctype: doctype\n  }\n});\n/**\n * Transform a hast tree to Parse5’s AST.\n *\n * @param {Node} tree\n *   Tree to transform.\n * @param {Options | Space | null | undefined} [options]\n *   Configuration.\n * @returns {P5Node}\n *   `parse5` node.\n */\n\nexport function toParse5(tree, options) {\n  var space = options && typeof options === 'object' ? options.space : options;\n  return one(tree, space === 'svg' ? svg : html);\n}\n/**\n * @param {Root} node\n * @param {Schema} schema\n *   Current schema.\n * @returns {P5Document}\n */\n\nfunction root(node, schema) {\n  /** @type {P5Document} */\n  var result = {\n    nodeName: '#document',\n    // @ts-expect-error: `parse5` uses enums, which are actually strings.\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\n    childNodes: []\n  };\n  result.childNodes = all(node.children, result, schema);\n  patch(node, result);\n  return result;\n}\n/**\n * @param {Root} node\n * @param {Schema} schema\n *   Current schema.\n * @returns {P5Fragment}\n */\n\n\nfunction fragment(node, schema) {\n  /** @type {P5Fragment} */\n  var result = {\n    nodeName: '#document-fragment',\n    childNodes: []\n  };\n  result.childNodes = all(node.children, result, schema);\n  patch(node, result);\n  return result;\n}\n/**\n * @param {Doctype} node\n * @returns {P5Doctype}\n */\n\n\nfunction doctype(node) {\n  /** @type {P5Doctype} */\n  var result = {\n    nodeName: '#documentType',\n    name: 'html',\n    publicId: '',\n    systemId: '',\n    // @ts-expect-error: change to `null` in a major?\n    parentNode: undefined\n  };\n  patch(node, result);\n  return result;\n}\n/**\n * @param {Text} node\n * @returns {P5Text}\n */\n\n\nfunction text(node) {\n  /** @type {P5Text} */\n  var result = {\n    nodeName: '#text',\n    value: node.value,\n    // @ts-expect-error: no `parentNode`\n    parentNode: undefined\n  };\n  patch(node, result);\n  return result;\n}\n/**\n * @param {Comment} node\n * @returns {P5Comment}\n */\n\n\nfunction comment(node) {\n  /** @type {P5Comment} */\n  var result = {\n    nodeName: '#comment',\n    data: node.value,\n    // @ts-expect-error: no `parentNode`\n    parentNode: undefined\n  };\n  patch(node, result);\n  return result;\n}\n/**\n * @param {Element} node\n * @param {Schema} schema\n *   Current schema.\n * @returns {P5Element}\n *   `parse5` node.\n */\n\n\nfunction element(node, schema) {\n  var parentSchema = schema;\n  var currentSchema = parentSchema;\n\n  if (node.type === 'element' && node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    currentSchema = svg;\n  }\n  /** @type {Array<P5Attribute>} */\n\n\n  var attrs = [];\n  /** @type {string} */\n\n  var prop;\n\n  if (node.properties) {\n    for (prop in node.properties) {\n      if (prop !== 'children' && own.call(node.properties, prop)) {\n        var _result = createProperty(currentSchema, prop, node.properties[prop]);\n\n        if (_result) {\n          attrs.push(_result);\n        }\n      }\n    }\n  }\n  /** @type {P5Element} */\n\n\n  var result = {\n    nodeName: node.tagName,\n    tagName: node.tagName,\n    attrs: attrs,\n    // @ts-expect-error: html and svg both have a space.\n    namespaceURI: webNamespaces[currentSchema.space],\n    childNodes: [],\n    // @ts-expect-error: no `parentNode`\n    parentNode: undefined\n  };\n  result.childNodes = all(node.children, result, currentSchema);\n  patch(node, result);\n\n  if (node.tagName === 'template' && node.content) {\n    // @ts-expect-error: `parse5` types are wrong.\n    result.content = fragment(node.content, currentSchema);\n  }\n\n  return result;\n}\n/**\n * Handle a property.\n *\n * @param {Schema} schema\n *   Current schema.\n * @param {string} prop\n *   Key.\n * @param {Array<string | number> | string | number | boolean | null | undefined} value\n *   hast property value.\n * @returns {P5Attribute | void}\n *   Field for runtime, optional.\n */\n\n\nfunction createProperty(schema, prop, value) {\n  var info = find(schema, prop); // Ignore nullish and `NaN` values.\n\n  if (value === undefined || value === null || value === false || typeof value === 'number' && Number.isNaN(value) || !value && info.boolean) {\n    return;\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value);\n  }\n  /** @type {P5Attribute} */\n\n\n  var attribute = {\n    name: info.attribute,\n    value: value === true ? '' : String(value)\n  };\n\n  if (info.space && info.space !== 'html' && info.space !== 'svg') {\n    var index = attribute.name.indexOf(':');\n\n    if (index < 0) {\n      attribute.prefix = '';\n    } else {\n      attribute.name = attribute.name.slice(index + 1);\n      attribute.prefix = info.attribute.slice(0, index);\n    }\n\n    attribute.namespace = webNamespaces[info.space];\n  }\n\n  return attribute;\n}\n/**\n * Transform all hast nodes.\n *\n * @param {Array<Content>} children\n *   List of children.\n * @param {P5Parent} parentNode\n *   `parse5` parent node.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Array<P5Child>}\n *   Transformed children.\n */\n\n\nfunction all(children, parentNode, schema) {\n  var index = -1;\n  /** @type {Array<P5Child>} */\n\n  var results = [];\n\n  if (children) {\n    while (++index < children.length) {\n      /** @type {P5Child} */\n      // @ts-expect-error assume no document.\n      var child = one(children[index], schema);\n      child.parentNode = parentNode;\n      results.push(child);\n    }\n  }\n\n  return results;\n}\n/**\n * Add position info from `from` to `to`.\n *\n * @param {Node} from\n *   hast node.\n * @param {P5Node} to\n *   `parse5` node.\n * @returns {void}\n *   Nothing.\n */\n\n\nfunction patch(from, to) {\n  var position = from.position;\n\n  if (position && position.start && position.end) {\n    to.sourceCodeLocation = {\n      startLine: position.start.line,\n      startCol: position.start.column,\n      // @ts-expect-error assume this is set.\n      startOffset: position.start.offset,\n      endLine: position.end.line,\n      endCol: position.end.column,\n      // @ts-expect-error assume this is set.\n      endOffset: position.end.offset\n    };\n  }\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/hast-util-to-parse5/lib/index.js"],"names":["stringify","commas","html","svg","find","spaces","webNamespaces","zwitch","own","hasOwnProperty","one","handlers","root","element","text","comment","doctype","toParse5","tree","options","space","node","schema","result","nodeName","mode","data","quirksMode","childNodes","all","children","patch","fragment","name","publicId","systemId","parentNode","undefined","value","parentSchema","currentSchema","type","tagName","toLowerCase","attrs","prop","properties","call","createProperty","push","namespaceURI","content","info","Number","isNaN","boolean","Array","isArray","commaSeparated","attribute","String","index","indexOf","prefix","slice","namespace","results","length","child","from","to","position","start","end","sourceCodeLocation","startLine","line","startCol","column","startOffset","offset","endLine","endCol","endOffset"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5Fragment\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['documentType']} P5Doctype\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['parentNode']} P5Parent\n * @typedef {import('parse5').Token.Attribute} P5Attribute\n * @typedef {Exclude<P5Node, P5Document | P5Fragment>} P5Child\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {'html' | 'svg'} Space\n *\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in.\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {html, svg, find} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\nconst own = {}.hasOwnProperty\n\n/** @type {(from: Node, schema: Schema) => P5Node} */\nconst one = zwitch('type', {handlers: {root, element, text, comment, doctype}})\n\n/**\n * Transform a hast tree to Parse5’s AST.\n *\n * @param {Node} tree\n *   Tree to transform.\n * @param {Options | Space | null | undefined} [options]\n *   Configuration.\n * @returns {P5Node}\n *   `parse5` node.\n */\nexport function toParse5(tree, options) {\n  const space = options && typeof options === 'object' ? options.space : options\n  return one(tree, space === 'svg' ? svg : html)\n}\n\n/**\n * @param {Root} node\n * @param {Schema} schema\n *   Current schema.\n * @returns {P5Document}\n */\nfunction root(node, schema) {\n  /** @type {P5Document} */\n  const result = {\n    nodeName: '#document',\n    // @ts-expect-error: `parse5` uses enums, which are actually strings.\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\n    childNodes: []\n  }\n  result.childNodes = all(node.children, result, schema)\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Root} node\n * @param {Schema} schema\n *   Current schema.\n * @returns {P5Fragment}\n */\nfunction fragment(node, schema) {\n  /** @type {P5Fragment} */\n  const result = {nodeName: '#document-fragment', childNodes: []}\n  result.childNodes = all(node.children, result, schema)\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Doctype} node\n * @returns {P5Doctype}\n */\nfunction doctype(node) {\n  /** @type {P5Doctype} */\n  const result = {\n    nodeName: '#documentType',\n    name: 'html',\n    publicId: '',\n    systemId: '',\n    // @ts-expect-error: change to `null` in a major?\n    parentNode: undefined\n  }\n\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Text} node\n * @returns {P5Text}\n */\nfunction text(node) {\n  /** @type {P5Text} */\n  const result = {\n    nodeName: '#text',\n    value: node.value,\n    // @ts-expect-error: no `parentNode`\n    parentNode: undefined\n  }\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Comment} node\n * @returns {P5Comment}\n */\nfunction comment(node) {\n  /** @type {P5Comment} */\n  const result = {\n    nodeName: '#comment',\n    data: node.value,\n    // @ts-expect-error: no `parentNode`\n    parentNode: undefined\n  }\n\n  patch(node, result)\n\n  return result\n}\n\n/**\n * @param {Element} node\n * @param {Schema} schema\n *   Current schema.\n * @returns {P5Element}\n *   `parse5` node.\n */\nfunction element(node, schema) {\n  const parentSchema = schema\n  let currentSchema = parentSchema\n\n  if (\n    node.type === 'element' &&\n    node.tagName.toLowerCase() === 'svg' &&\n    parentSchema.space === 'html'\n  ) {\n    currentSchema = svg\n  }\n\n  /** @type {Array<P5Attribute>} */\n  const attrs = []\n  /** @type {string} */\n  let prop\n\n  if (node.properties) {\n    for (prop in node.properties) {\n      if (prop !== 'children' && own.call(node.properties, prop)) {\n        const result = createProperty(\n          currentSchema,\n          prop,\n          node.properties[prop]\n        )\n\n        if (result) {\n          attrs.push(result)\n        }\n      }\n    }\n  }\n\n  /** @type {P5Element} */\n  const result = {\n    nodeName: node.tagName,\n    tagName: node.tagName,\n    attrs,\n    // @ts-expect-error: html and svg both have a space.\n    namespaceURI: webNamespaces[currentSchema.space],\n    childNodes: [],\n    // @ts-expect-error: no `parentNode`\n    parentNode: undefined\n  }\n  result.childNodes = all(node.children, result, currentSchema)\n  patch(node, result)\n\n  if (node.tagName === 'template' && node.content) {\n    // @ts-expect-error: `parse5` types are wrong.\n    result.content = fragment(node.content, currentSchema)\n  }\n\n  return result\n}\n\n/**\n * Handle a property.\n *\n * @param {Schema} schema\n *   Current schema.\n * @param {string} prop\n *   Key.\n * @param {Array<string | number> | string | number | boolean | null | undefined} value\n *   hast property value.\n * @returns {P5Attribute | void}\n *   Field for runtime, optional.\n */\nfunction createProperty(schema, prop, value) {\n  const info = find(schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === undefined ||\n    value === null ||\n    value === false ||\n    (typeof value === 'number' && Number.isNaN(value)) ||\n    (!value && info.boolean)\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  /** @type {P5Attribute} */\n  const attribute = {\n    name: info.attribute,\n    value: value === true ? '' : String(value)\n  }\n\n  if (info.space && info.space !== 'html' && info.space !== 'svg') {\n    const index = attribute.name.indexOf(':')\n\n    if (index < 0) {\n      attribute.prefix = ''\n    } else {\n      attribute.name = attribute.name.slice(index + 1)\n      attribute.prefix = info.attribute.slice(0, index)\n    }\n\n    attribute.namespace = webNamespaces[info.space]\n  }\n\n  return attribute\n}\n\n/**\n * Transform all hast nodes.\n *\n * @param {Array<Content>} children\n *   List of children.\n * @param {P5Parent} parentNode\n *   `parse5` parent node.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Array<P5Child>}\n *   Transformed children.\n */\nfunction all(children, parentNode, schema) {\n  let index = -1\n  /** @type {Array<P5Child>} */\n  const results = []\n\n  if (children) {\n    while (++index < children.length) {\n      /** @type {P5Child} */\n      // @ts-expect-error assume no document.\n      const child = one(children[index], schema)\n\n      child.parentNode = parentNode\n\n      results.push(child)\n    }\n  }\n\n  return results\n}\n\n/**\n * Add position info from `from` to `to`.\n *\n * @param {Node} from\n *   hast node.\n * @param {P5Node} to\n *   `parse5` node.\n * @returns {void}\n *   Nothing.\n */\nfunction patch(from, to) {\n  const position = from.position\n\n  if (position && position.start && position.end) {\n    to.sourceCodeLocation = {\n      startLine: position.start.line,\n      startCol: position.start.column,\n      // @ts-expect-error assume this is set.\n      startOffset: position.start.offset,\n      endLine: position.end.line,\n      endCol: position.end.column,\n      // @ts-expect-error assume this is set.\n      endOffset: position.end.offset\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}