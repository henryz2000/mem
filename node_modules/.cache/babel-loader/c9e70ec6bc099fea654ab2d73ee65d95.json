{"ast":null,"code":"/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\nimport { characterEntitiesLegacy } from 'character-entities-legacy';\nimport { characterReferenceInvalid } from 'character-reference-invalid';\nimport { isDecimal } from 'is-decimal';\nimport { isHexadecimal } from 'is-hexadecimal';\nimport { isAlphanumerical } from 'is-alphanumerical';\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nvar fromCharCode = String.fromCharCode; // Warning messages.\n\nvar messages = ['',\n/* 1: Non terminated (named) */\n'Named character references must be terminated by a semicolon',\n/* 2: Non terminated (numeric) */\n'Numeric character references must be terminated by a semicolon',\n/* 3: Empty (named) */\n'Named character references cannot be empty',\n/* 4: Empty (numeric) */\n'Numeric character references cannot be empty',\n/* 5: Unknown (named) */\n'Named character references must be known',\n/* 6: Disallowed (numeric) */\n'Numeric character references cannot be disallowed',\n/* 7: Prohibited (numeric) */\n'Numeric character references cannot be outside the permissible Unicode range'];\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */\n\nexport function parseEntities(value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var additional = typeof options.additional === 'string' ? options.additional.charCodeAt(0) : options.additional;\n  /** @type {Array<string>} */\n\n  var result = [];\n  var index = 0;\n  var lines = -1;\n  var queue = '';\n  /** @type {Point|undefined} */\n\n  var point;\n  /** @type {Array<number>|undefined} */\n\n  var indent;\n\n  if (options.position) {\n    if ('start' in options.position || 'indent' in options.position) {\n      // @ts-expect-error: points don’t have indent.\n      indent = options.position.indent; // @ts-expect-error: points don’t have indent.\n\n      point = options.position.start;\n    } else {\n      point = options.position;\n    }\n  }\n\n  var line = (point ? point.line : 0) || 1;\n  var column = (point ? point.column : 0) || 1; // Cache the current point.\n\n  var previous = now();\n  /** @type {number|undefined} */\n\n  var character; // Ensure the algorithm walks over the first character (inclusive).\n\n  index--;\n\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10\n    /* `\\n` */\n    ) {\n      column = (indent ? indent[lines] : 0) || 1;\n    }\n\n    character = value.charCodeAt(index);\n\n    if (character === 38\n    /* `&` */\n    ) {\n      var following = value.charCodeAt(index + 1); // The behavior depends on the identity of the next character.\n\n      if (following === 9\n      /* `\\t` */\n      || following === 10\n      /* `\\n` */\n      || following === 12\n      /* `\\f` */\n      || following === 32\n      /* ` ` */\n      || following === 38\n      /* `&` */\n      || following === 60\n      /* `<` */\n      || Number.isNaN(following) || additional && following === additional) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character);\n        column++;\n        continue;\n      }\n\n      var start = index + 1;\n      var begin = start;\n      var end = start;\n      /** @type {string} */\n\n      var type = void 0;\n\n      if (following === 35\n      /* `#` */\n      ) {\n        // Numerical reference.\n        end = ++begin; // The behavior further depends on the next character.\n\n        var _following = value.charCodeAt(end);\n\n        if (_following === 88\n        /* `X` */\n        || _following === 120\n        /* `x` */\n        ) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal';\n          end = ++begin;\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal';\n        }\n      } else {\n        // Named reference.\n        type = 'named';\n      }\n\n      var characterReferenceCharacters = '';\n      var characterReference = '';\n      var characters = ''; // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n\n      var test = type === 'named' ? isAlphanumerical : type === 'decimal' ? isDecimal : isHexadecimal;\n      end--;\n\n      while (++end <= value.length) {\n        var _following2 = value.charCodeAt(end);\n\n        if (!test(_following2)) {\n          break;\n        }\n\n        characters += fromCharCode(_following2); // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n\n        if (type === 'named' && characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters; // @ts-expect-error: always able to decode.\n\n          characterReference = decodeNamedCharacterReference(characters);\n        }\n      }\n\n      var terminated = value.charCodeAt(end) === 59;\n      /* `;` */\n\n      if (terminated) {\n        end++;\n        var namedReference = type === 'named' ? decodeNamedCharacterReference(characters) : false;\n\n        if (namedReference) {\n          characterReferenceCharacters = characters;\n          characterReference = namedReference;\n        }\n      }\n\n      var diff = 1 + end - start;\n      var reference = '';\n\n      if (!terminated && options.nonTerminated === false) {// Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4\n          /* Empty (numeric) */\n          , diff);\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5\n          /* Unknown (named) */\n          , 1);\n        } else {\n          // If there’s something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length;\n            diff = 1 + end - begin;\n            terminated = false;\n          } // If the reference is not terminated, warn.\n\n\n          if (!terminated) {\n            var reason = characterReferenceCharacters ? 1\n            /* Non terminated (named) */\n            : 3;\n            /* Empty (named) */\n\n            if (options.attribute) {\n              var _following3 = value.charCodeAt(end);\n\n              if (_following3 === 61\n              /* `=` */\n              ) {\n                warning(reason, diff);\n                characterReference = '';\n              } else if (isAlphanumerical(_following3)) {\n                characterReference = '';\n              } else {\n                warning(reason, diff);\n              }\n            } else {\n              warning(reason, diff);\n            }\n          }\n        }\n\n        reference = characterReference;\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2\n          /* Non terminated (numeric) */\n          , diff);\n        } // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n\n\n        var referenceCode = Number.parseInt(characters, type === 'hexadecimal' ? 16 : 10); // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n\n        if (prohibited(referenceCode)) {\n          warning(7\n          /* Prohibited (numeric) */\n          , diff);\n          reference = fromCharCode(65533\n          /* `�` */\n          );\n        } else if (referenceCode in characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6\n          /* Disallowed (numeric) */\n          , diff);\n          reference = characterReferenceInvalid[referenceCode];\n        } else {\n          // Parse the number.\n          var output = ''; // Emit a warning when the parsed number should not be used.\n\n          if (disallowed(referenceCode)) {\n            warning(6\n            /* Disallowed (numeric) */\n            , diff);\n          } // Serialize the number.\n\n\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000;\n            output += fromCharCode(referenceCode >>> (10 & 0x3ff) | 0xd800);\n            referenceCode = 0xdc00 | referenceCode & 0x3ff;\n          }\n\n          reference = output + fromCharCode(referenceCode);\n        }\n      } // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n\n\n      if (reference) {\n        flush();\n        previous = now();\n        index = end - 1;\n        column += end - start + 1;\n        result.push(reference);\n        var next = now();\n        next.offset++;\n\n        if (options.reference) {\n          options.reference.call(options.referenceContext, reference, {\n            start: previous,\n            end: next\n          }, value.slice(start - 1, end));\n        }\n\n        previous = next;\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end);\n        queue += characters;\n        column += characters.length;\n        index = end - 1;\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10\n      /* `\\n` */\n      ) {\n        line++;\n        lines++;\n        column = 0;\n      }\n\n      if (Number.isNaN(character)) {\n        flush();\n      } else {\n        queue += fromCharCode(character);\n        column++;\n      }\n    }\n  } // Return the reduced nodes.\n\n\n  return result.join(''); // Get current position.\n\n  function now() {\n    return {\n      line: line,\n      column: column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    };\n  }\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n\n\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    var position;\n\n    if (options.warning) {\n      position = now();\n      position.column += offset;\n      position.offset += offset;\n      options.warning.call(options.warningContext, messages[code], position, code);\n    }\n  }\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n\n\n  function flush() {\n    if (queue) {\n      result.push(queue);\n\n      if (options.text) {\n        options.text.call(options.textContext, queue, {\n          start: previous,\n          end: now()\n        });\n      }\n\n      queue = '';\n    }\n  }\n}\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\n\nfunction prohibited(code) {\n  return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\n}\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\n\n\nfunction disallowed(code) {\n  return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/parse-entities/lib/index.js"],"names":["characterEntitiesLegacy","characterReferenceInvalid","isDecimal","isHexadecimal","isAlphanumerical","decodeNamedCharacterReference","fromCharCode","String","messages","parseEntities","value","options","additional","charCodeAt","result","index","lines","queue","point","indent","position","start","line","column","previous","now","character","length","following","Number","isNaN","begin","end","type","characterReferenceCharacters","characterReference","characters","test","includes","terminated","namedReference","diff","reference","nonTerminated","warning","reason","attribute","referenceCode","parseInt","prohibited","output","disallowed","flush","push","next","offset","call","referenceContext","slice","join","code","warningContext","text","textContext"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\nimport {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterReferenceInvalid} from 'character-reference-invalid'\nimport {isDecimal} from 'is-decimal'\nimport {isHexadecimal} from 'is-hexadecimal'\nimport {isAlphanumerical} from 'is-alphanumerical'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\n\nconst fromCharCode = String.fromCharCode\n\n// Warning messages.\nconst messages = [\n  '',\n  /* 1: Non terminated (named) */\n  'Named character references must be terminated by a semicolon',\n  /* 2: Non terminated (numeric) */\n  'Numeric character references must be terminated by a semicolon',\n  /* 3: Empty (named) */\n  'Named character references cannot be empty',\n  /* 4: Empty (numeric) */\n  'Numeric character references cannot be empty',\n  /* 5: Unknown (named) */\n  'Named character references must be known',\n  /* 6: Disallowed (numeric) */\n  'Numeric character references cannot be disallowed',\n  /* 7: Prohibited (numeric) */\n  'Numeric character references cannot be outside the permissible Unicode range'\n]\n\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */\nexport function parseEntities(value, options = {}) {\n  const additional =\n    typeof options.additional === 'string'\n      ? options.additional.charCodeAt(0)\n      : options.additional\n  /** @type {Array<string>} */\n  const result = []\n  let index = 0\n  let lines = -1\n  let queue = ''\n  /** @type {Point|undefined} */\n  let point\n  /** @type {Array<number>|undefined} */\n  let indent\n\n  if (options.position) {\n    if ('start' in options.position || 'indent' in options.position) {\n      // @ts-expect-error: points don’t have indent.\n      indent = options.position.indent\n      // @ts-expect-error: points don’t have indent.\n      point = options.position.start\n    } else {\n      point = options.position\n    }\n  }\n\n  let line = (point ? point.line : 0) || 1\n  let column = (point ? point.column : 0) || 1\n\n  // Cache the current point.\n  let previous = now()\n  /** @type {number|undefined} */\n  let character\n\n  // Ensure the algorithm walks over the first character (inclusive).\n  index--\n\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10 /* `\\n` */) {\n      column = (indent ? indent[lines] : 0) || 1\n    }\n\n    character = value.charCodeAt(index)\n\n    if (character === 38 /* `&` */) {\n      const following = value.charCodeAt(index + 1)\n\n      // The behavior depends on the identity of the next character.\n      if (\n        following === 9 /* `\\t` */ ||\n        following === 10 /* `\\n` */ ||\n        following === 12 /* `\\f` */ ||\n        following === 32 /* ` ` */ ||\n        following === 38 /* `&` */ ||\n        following === 60 /* `<` */ ||\n        Number.isNaN(following) ||\n        (additional && following === additional)\n      ) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character)\n        column++\n        continue\n      }\n\n      const start = index + 1\n      let begin = start\n      let end = start\n      /** @type {string} */\n      let type\n\n      if (following === 35 /* `#` */) {\n        // Numerical reference.\n        end = ++begin\n\n        // The behavior further depends on the next character.\n        const following = value.charCodeAt(end)\n\n        if (following === 88 /* `X` */ || following === 120 /* `x` */) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal'\n          end = ++begin\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal'\n        }\n      } else {\n        // Named reference.\n        type = 'named'\n      }\n\n      let characterReferenceCharacters = ''\n      let characterReference = ''\n      let characters = ''\n      // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n      const test =\n        type === 'named'\n          ? isAlphanumerical\n          : type === 'decimal'\n          ? isDecimal\n          : isHexadecimal\n\n      end--\n\n      while (++end <= value.length) {\n        const following = value.charCodeAt(end)\n\n        if (!test(following)) {\n          break\n        }\n\n        characters += fromCharCode(following)\n\n        // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n        if (type === 'named' && characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters\n          // @ts-expect-error: always able to decode.\n          characterReference = decodeNamedCharacterReference(characters)\n        }\n      }\n\n      let terminated = value.charCodeAt(end) === 59 /* `;` */\n\n      if (terminated) {\n        end++\n\n        const namedReference =\n          type === 'named' ? decodeNamedCharacterReference(characters) : false\n\n        if (namedReference) {\n          characterReferenceCharacters = characters\n          characterReference = namedReference\n        }\n      }\n\n      let diff = 1 + end - start\n      let reference = ''\n\n      if (!terminated && options.nonTerminated === false) {\n        // Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4 /* Empty (numeric) */, diff)\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5 /* Unknown (named) */, 1)\n        } else {\n          // If there’s something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length\n            diff = 1 + end - begin\n            terminated = false\n          }\n\n          // If the reference is not terminated, warn.\n          if (!terminated) {\n            const reason = characterReferenceCharacters\n              ? 1 /* Non terminated (named) */\n              : 3 /* Empty (named) */\n\n            if (options.attribute) {\n              const following = value.charCodeAt(end)\n\n              if (following === 61 /* `=` */) {\n                warning(reason, diff)\n                characterReference = ''\n              } else if (isAlphanumerical(following)) {\n                characterReference = ''\n              } else {\n                warning(reason, diff)\n              }\n            } else {\n              warning(reason, diff)\n            }\n          }\n        }\n\n        reference = characterReference\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2 /* Non terminated (numeric) */, diff)\n        }\n\n        // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n        let referenceCode = Number.parseInt(\n          characters,\n          type === 'hexadecimal' ? 16 : 10\n        )\n\n        // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n        if (prohibited(referenceCode)) {\n          warning(7 /* Prohibited (numeric) */, diff)\n          reference = fromCharCode(65533 /* `�` */)\n        } else if (referenceCode in characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6 /* Disallowed (numeric) */, diff)\n          reference = characterReferenceInvalid[referenceCode]\n        } else {\n          // Parse the number.\n          let output = ''\n\n          // Emit a warning when the parsed number should not be used.\n          if (disallowed(referenceCode)) {\n            warning(6 /* Disallowed (numeric) */, diff)\n          }\n\n          // Serialize the number.\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000\n            output += fromCharCode((referenceCode >>> (10 & 0x3ff)) | 0xd800)\n            referenceCode = 0xdc00 | (referenceCode & 0x3ff)\n          }\n\n          reference = output + fromCharCode(referenceCode)\n        }\n      }\n\n      // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n      if (reference) {\n        flush()\n\n        previous = now()\n        index = end - 1\n        column += end - start + 1\n        result.push(reference)\n        const next = now()\n        next.offset++\n\n        if (options.reference) {\n          options.reference.call(\n            options.referenceContext,\n            reference,\n            {start: previous, end: next},\n            value.slice(start - 1, end)\n          )\n        }\n\n        previous = next\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end)\n        queue += characters\n        column += characters.length\n        index = end - 1\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10 /* `\\n` */) {\n        line++\n        lines++\n        column = 0\n      }\n\n      if (Number.isNaN(character)) {\n        flush()\n      } else {\n        queue += fromCharCode(character)\n        column++\n      }\n    }\n  }\n\n  // Return the reduced nodes.\n  return result.join('')\n\n  // Get current position.\n  function now() {\n    return {\n      line,\n      column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    }\n  }\n\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    let position\n\n    if (options.warning) {\n      position = now()\n      position.column += offset\n      position.offset += offset\n\n      options.warning.call(\n        options.warningContext,\n        messages[code],\n        position,\n        code\n      )\n    }\n  }\n\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n  function flush() {\n    if (queue) {\n      result.push(queue)\n\n      if (options.text) {\n        options.text.call(options.textContext, queue, {\n          start: previous,\n          end: now()\n        })\n      }\n\n      queue = ''\n    }\n  }\n}\n\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction prohibited(code) {\n  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff\n}\n\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction disallowed(code) {\n  return (\n    (code >= 0x0001 && code <= 0x0008) ||\n    code === 0x000b ||\n    (code >= 0x000d && code <= 0x001f) ||\n    (code >= 0x007f && code <= 0x009f) ||\n    (code >= 0xfdd0 && code <= 0xfdef) ||\n    (code & 0xffff) === 0xffff ||\n    (code & 0xffff) === 0xfffe\n  )\n}\n"]},"metadata":{},"sourceType":"module"}