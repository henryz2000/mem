{"ast":null,"code":"// @ts-nocheck\n// This is a slimmed down version of `prism-core.js`, to remove globals,\n// document, workers, `util.encode`, `Token.stringify`\n// Private helper vars\nvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\nvar uniqueId = 0; // The grammar object for plaintext\n\nvar plainTextGrammar = {};\nvar _ = {\n  /**\n   * A namespace for utility methods.\n   *\n   * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n   * change or disappear at any time.\n   *\n   * @namespace\n   * @memberof Prism\n   */\n  util: {\n    /**\n     * Returns the name of the type of the given value.\n     *\n     * @param {any} o\n     * @returns {string}\n     * @example\n     * type(null)      === 'Null'\n     * type(undefined) === 'Undefined'\n     * type(123)       === 'Number'\n     * type('foo')     === 'String'\n     * type(true)      === 'Boolean'\n     * type([1, 2])    === 'Array'\n     * type({})        === 'Object'\n     * type(String)    === 'Function'\n     * type(/abc+/)    === 'RegExp'\n     */\n    type: function type(o) {\n      return Object.prototype.toString.call(o).slice(8, -1);\n    },\n\n    /**\n     * Returns a unique number for the given object. Later calls will still return the same number.\n     *\n     * @param {Object} obj\n     * @returns {number}\n     */\n    objId: function objId(obj) {\n      if (!obj['__id']) {\n        Object.defineProperty(obj, '__id', {\n          value: ++uniqueId\n        });\n      }\n\n      return obj['__id'];\n    },\n\n    /**\n     * Creates a deep clone of the given object.\n     *\n     * The main intended use of this function is to clone language definitions.\n     *\n     * @param {T} o\n     * @param {Record<number, any>} [visited]\n     * @returns {T}\n     * @template T\n     */\n    clone: function deepClone(o, visited) {\n      visited = visited || {};\n      var clone;\n      var id;\n\n      switch (_.util.type(o)) {\n        case 'Object':\n          id = _.util.objId(o);\n\n          if (visited[id]) {\n            return visited[id];\n          }\n\n          clone = {};\n          visited[id] = clone;\n\n          for (var key in o) {\n            if (o.hasOwnProperty(key)) {\n              clone[key] = deepClone(o[key], visited);\n            }\n          }\n\n          return clone;\n\n        case 'Array':\n          id = _.util.objId(o);\n\n          if (visited[id]) {\n            return visited[id];\n          }\n\n          clone = [];\n          visited[id] = clone;\n          o.forEach(function (v, i) {\n            clone[i] = deepClone(v, visited);\n          });\n          return clone;\n\n        default:\n          return o;\n      }\n    }\n  },\n\n  /**\n   * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n   *\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  languages: {\n    /**\n     * The grammar for plain, unformatted text.\n     */\n    plain: plainTextGrammar,\n    plaintext: plainTextGrammar,\n    text: plainTextGrammar,\n    txt: plainTextGrammar,\n\n    /**\n     * Creates a deep copy of the language with the given id and appends the given tokens.\n     *\n     * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n     * will be overwritten at its original position.\n     *\n     * ## Best practices\n     *\n     * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n     * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n     * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n     *\n     * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n     * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n     *\n     * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n     * @param {Grammar} redef The new tokens to append.\n     * @returns {Grammar} The new language created.\n     * @public\n     * @example\n     * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n     *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n     *     // at its original position\n     *     'comment': { ... },\n     *     // CSS doesn't have a 'color' token, so this token will be appended\n     *     'color': /\\b(?:red|green|blue)\\b/\n     * });\n     */\n    extend: function extend(id, redef) {\n      var lang = _.util.clone(_.languages[id]);\n\n      for (var key in redef) {\n        lang[key] = redef[key];\n      }\n\n      return lang;\n    },\n\n    /**\n     * Inserts tokens _before_ another token in a language definition or any other grammar.\n     *\n     * ## Usage\n     *\n     * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n     * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n     * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n     * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n     * this:\n     *\n     * ```js\n     * Prism.languages.markup.style = {\n     *     // token\n     * };\n     * ```\n     *\n     * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n     * before existing tokens. For the CSS example above, you would use it like this:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'cdata', {\n     *     'style': {\n     *         // token\n     *     }\n     * });\n     * ```\n     *\n     * ## Special cases\n     *\n     * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n     * will be ignored.\n     *\n     * This behavior can be used to insert tokens after `before`:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'comment', {\n     *     'comment': Prism.languages.markup.comment,\n     *     // tokens after 'comment'\n     * });\n     * ```\n     *\n     * ## Limitations\n     *\n     * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n     * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n     * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n     * deleting properties which is necessary to insert at arbitrary positions.\n     *\n     * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n     * Instead, it will create a new object and replace all references to the target object with the new one. This\n     * can be done without temporarily deleting properties, so the iteration order is well-defined.\n     *\n     * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n     * you hold the target object in a variable, then the value of the variable will not change.\n     *\n     * ```js\n     * var oldMarkup = Prism.languages.markup;\n     * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n     *\n     * assert(oldMarkup !== Prism.languages.markup);\n     * assert(newMarkup === Prism.languages.markup);\n     * ```\n     *\n     * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n     * object to be modified.\n     * @param {string} before The key to insert before.\n     * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n     * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n     * object to be modified.\n     *\n     * Defaults to `Prism.languages`.\n     * @returns {Grammar} The new grammar object.\n     * @public\n     */\n    insertBefore: function insertBefore(inside, before, insert, root) {\n      root = root || _.languages;\n      var grammar = root[inside];\n      /** @type {Grammar} */\n\n      var ret = {};\n\n      for (var token in grammar) {\n        if (grammar.hasOwnProperty(token)) {\n          if (token == before) {\n            for (var newToken in insert) {\n              if (insert.hasOwnProperty(newToken)) {\n                ret[newToken] = insert[newToken];\n              }\n            }\n          } // Do not insert token which also occur in insert. See #1525\n\n\n          if (!insert.hasOwnProperty(token)) {\n            ret[token] = grammar[token];\n          }\n        }\n      }\n\n      var old = root[inside];\n      root[inside] = ret; // Update references in other language definitions\n\n      _.languages.DFS(_.languages, function (key, value) {\n        if (value === old && key != inside) {\n          this[key] = ret;\n        }\n      });\n\n      return ret;\n    },\n    // Traverse a language definition with Depth First Search\n    DFS: function DFS(o, callback, type, visited) {\n      visited = visited || {};\n      var objId = _.util.objId;\n\n      for (var i in o) {\n        if (o.hasOwnProperty(i)) {\n          callback.call(o, i, o[i], type || i);\n          var property = o[i];\n\n          var propertyType = _.util.type(property);\n\n          if (propertyType === 'Object' && !visited[objId(property)]) {\n            visited[objId(property)] = true;\n            DFS(property, callback, null, visited);\n          } else if (propertyType === 'Array' && !visited[objId(property)]) {\n            visited[objId(property)] = true;\n            DFS(property, callback, i, visited);\n          }\n        }\n      }\n    }\n  },\n  plugins: {},\n\n  /**\n   * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n   * and the language definitions to use, and returns a string with the HTML produced.\n   *\n   * The following hooks will be run:\n   * 1. `before-tokenize`\n   * 2. `after-tokenize`\n   * 3. `wrap`: On each {@link Token}.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @param {string} language The name of the language definition passed to `grammar`.\n   * @returns {string} The highlighted HTML.\n   * @memberof Prism\n   * @public\n   * @example\n   * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n   */\n  highlight: function highlight(text, grammar, language) {\n    var env = {\n      code: text,\n      grammar: grammar,\n      language: language\n    };\n\n    _.hooks.run('before-tokenize', env);\n\n    if (!env.grammar) {\n      throw new Error('The language \"' + env.language + '\" has no grammar.');\n    }\n\n    env.tokens = _.tokenize(env.code, env.grammar);\n\n    _.hooks.run('after-tokenize', env);\n\n    return Token.stringify(_.util.encode(env.tokens), env.language);\n  },\n\n  /**\n   * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n   * and the language definitions to use, and returns an array with the tokenized code.\n   *\n   * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n   *\n   * This method could be useful in other contexts as well, as a very crude parser.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @returns {TokenStream} An array of strings and tokens, a token stream.\n   * @memberof Prism\n   * @public\n   * @example\n   * let code = `var foo = 0;`;\n   * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n   * tokens.forEach(token => {\n   *     if (token instanceof Prism.Token && token.type === 'number') {\n   *         console.log(`Found numeric literal: ${token.content}`);\n   *     }\n   * });\n   */\n  tokenize: function tokenize(text, grammar) {\n    var rest = grammar.rest;\n\n    if (rest) {\n      for (var token in rest) {\n        grammar[token] = rest[token];\n      }\n\n      delete grammar.rest;\n    }\n\n    var tokenList = new LinkedList();\n    addAfter(tokenList, tokenList.head, text);\n    matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n    return toArray(tokenList);\n  },\n\n  /**\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  hooks: {\n    all: {},\n\n    /**\n     * Adds the given callback to the list of callbacks for the given hook.\n     *\n     * The callback will be invoked when the hook it is registered for is run.\n     * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n     *\n     * One callback function can be registered to multiple hooks and the same hook multiple times.\n     *\n     * @param {string} name The name of the hook.\n     * @param {HookCallback} callback The callback function which is given environment variables.\n     * @public\n     */\n    add: function add(name, callback) {\n      var hooks = _.hooks.all;\n      hooks[name] = hooks[name] || [];\n      hooks[name].push(callback);\n    },\n\n    /**\n     * Runs a hook invoking all registered callbacks with the given environment variables.\n     *\n     * Callbacks will be invoked synchronously and in the order in which they were registered.\n     *\n     * @param {string} name The name of the hook.\n     * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n     * @public\n     */\n    run: function run(name, env) {\n      var callbacks = _.hooks.all[name];\n\n      if (!callbacks || !callbacks.length) {\n        return;\n      }\n\n      for (var i = 0, callback; callback = callbacks[i++];) {\n        callback(env);\n      }\n    }\n  },\n  Token: Token\n}; // Typescript note:\n// The following can be used to import the Token type in JSDoc:\n//\n//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n/**\n * Creates a new token.\n *\n * @param {string} type See {@link Token#type type}\n * @param {string | TokenStream} content See {@link Token#content content}\n * @param {string|string[]} [alias] The alias(es) of the token.\n * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n * @class\n * @global\n * @public\n */\n\nfunction Token(type, content, alias, matchedStr) {\n  /**\n   * The type of the token.\n   *\n   * This is usually the key of a pattern in a {@link Grammar}.\n   *\n   * @type {string}\n   * @see GrammarToken\n   * @public\n   */\n  this.type = type;\n  /**\n   * The strings or tokens contained by this token.\n   *\n   * This will be a token stream if the pattern matched also defined an `inside` grammar.\n   *\n   * @type {string | TokenStream}\n   * @public\n   */\n\n  this.content = content;\n  /**\n   * The alias(es) of the token.\n   *\n   * @type {string|string[]}\n   * @see GrammarToken\n   * @public\n   */\n\n  this.alias = alias; // Copy of the full string this token was created from\n\n  this.length = (matchedStr || '').length | 0;\n}\n/**\n * A token stream is an array of strings and {@link Token Token} objects.\n *\n * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n * them.\n *\n * 1. No adjacent strings.\n * 2. No empty strings.\n *\n *    The only exception here is the token stream that only contains the empty string and nothing else.\n *\n * @typedef {Array<string | Token>} TokenStream\n * @global\n * @public\n */\n\n/**\n * @param {RegExp} pattern\n * @param {number} pos\n * @param {string} text\n * @param {boolean} lookbehind\n * @returns {RegExpExecArray | null}\n */\n\n\nfunction matchPattern(pattern, pos, text, lookbehind) {\n  pattern.lastIndex = pos;\n  var match = pattern.exec(text);\n\n  if (match && lookbehind && match[1]) {\n    // change the match to remove the text matched by the Prism lookbehind group\n    var lookbehindLength = match[1].length;\n    match.index += lookbehindLength;\n    match[0] = match[0].slice(lookbehindLength);\n  }\n\n  return match;\n}\n/**\n * @param {string} text\n * @param {LinkedList<string | Token>} tokenList\n * @param {any} grammar\n * @param {LinkedListNode<string | Token>} startNode\n * @param {number} startPos\n * @param {RematchOptions} [rematch]\n * @returns {void}\n * @private\n *\n * @typedef RematchOptions\n * @property {string} cause\n * @property {number} reach\n */\n\n\nfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n  for (var token in grammar) {\n    if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n      continue;\n    }\n\n    var patterns = grammar[token];\n    patterns = Array.isArray(patterns) ? patterns : [patterns];\n\n    for (var j = 0; j < patterns.length; ++j) {\n      if (rematch && rematch.cause == token + ',' + j) {\n        return;\n      }\n\n      var patternObj = patterns[j];\n      var inside = patternObj.inside;\n      var lookbehind = !!patternObj.lookbehind;\n      var greedy = !!patternObj.greedy;\n      var alias = patternObj.alias;\n\n      if (greedy && !patternObj.pattern.global) {\n        // Without the global flag, lastIndex won't work\n        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n        patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n      }\n      /** @type {RegExp} */\n\n\n      var pattern = patternObj.pattern || patternObj;\n\n      for ( // iterate the token list and keep track of the current token/string position\n      var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {\n        if (rematch && pos >= rematch.reach) {\n          break;\n        }\n\n        var str = currentNode.value;\n\n        if (tokenList.length > text.length) {\n          // Something went terribly wrong, ABORT, ABORT!\n          return;\n        }\n\n        if (str instanceof Token) {\n          continue;\n        }\n\n        var removeCount = 1; // this is the to parameter of removeBetween\n\n        var match;\n\n        if (greedy) {\n          match = matchPattern(pattern, pos, text, lookbehind);\n\n          if (!match || match.index >= text.length) {\n            break;\n          }\n\n          var from = match.index;\n          var to = match.index + match[0].length;\n          var p = pos; // find the node that contains the match\n\n          p += currentNode.value.length;\n\n          while (from >= p) {\n            currentNode = currentNode.next;\n            p += currentNode.value.length;\n          } // adjust pos (and p)\n\n\n          p -= currentNode.value.length;\n          pos = p; // the current node is a Token, then the match starts inside another Token, which is invalid\n\n          if (currentNode.value instanceof Token) {\n            continue;\n          } // find the last node which is affected by this match\n\n\n          for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {\n            removeCount++;\n            p += k.value.length;\n          }\n\n          removeCount--; // replace with the new match\n\n          str = text.slice(pos, p);\n          match.index -= pos;\n        } else {\n          match = matchPattern(pattern, 0, str, lookbehind);\n\n          if (!match) {\n            continue;\n          }\n        } // eslint-disable-next-line no-redeclare\n\n\n        var from = match.index;\n        var matchStr = match[0];\n        var before = str.slice(0, from);\n        var after = str.slice(from + matchStr.length);\n        var reach = pos + str.length;\n\n        if (rematch && reach > rematch.reach) {\n          rematch.reach = reach;\n        }\n\n        var removeFrom = currentNode.prev;\n\n        if (before) {\n          removeFrom = addAfter(tokenList, removeFrom, before);\n          pos += before.length;\n        }\n\n        removeRange(tokenList, removeFrom, removeCount);\n        var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n        currentNode = addAfter(tokenList, removeFrom, wrapped);\n\n        if (after) {\n          addAfter(tokenList, currentNode, after);\n        }\n\n        if (removeCount > 1) {\n          // at least one Token object was removed, so we have to do some rematching\n          // this can only happen if the current pattern is greedy\n\n          /** @type {RematchOptions} */\n          var nestedRematch = {\n            cause: token + ',' + j,\n            reach: reach\n          };\n          matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch); // the reach might have been extended because of the rematching\n\n          if (rematch && nestedRematch.reach > rematch.reach) {\n            rematch.reach = nestedRematch.reach;\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * @typedef LinkedListNode\n * @property {T} value\n * @property {LinkedListNode<T> | null} prev The previous node.\n * @property {LinkedListNode<T> | null} next The next node.\n * @template T\n * @private\n */\n\n/**\n * @template T\n * @private\n */\n\n\nfunction LinkedList() {\n  /** @type {LinkedListNode<T>} */\n  var head = {\n    value: null,\n    prev: null,\n    next: null\n  };\n  /** @type {LinkedListNode<T>} */\n\n  var tail = {\n    value: null,\n    prev: head,\n    next: null\n  };\n  head.next = tail;\n  /** @type {LinkedListNode<T>} */\n\n  this.head = head;\n  /** @type {LinkedListNode<T>} */\n\n  this.tail = tail;\n  this.length = 0;\n}\n/**\n * Adds a new node with the given value to the list.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {T} value\n * @returns {LinkedListNode<T>} The added node.\n * @template T\n */\n\n\nfunction addAfter(list, node, value) {\n  // assumes that node != list.tail && values.length >= 0\n  var next = node.next;\n  var newNode = {\n    value: value,\n    prev: node,\n    next: next\n  };\n  node.next = newNode;\n  next.prev = newNode;\n  list.length++;\n  return newNode;\n}\n/**\n * Removes `count` nodes after the given node. The given node will not be removed.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {number} count\n * @template T\n */\n\n\nfunction removeRange(list, node, count) {\n  var next = node.next;\n\n  for (var i = 0; i < count && next !== list.tail; i++) {\n    next = next.next;\n  }\n\n  node.next = next;\n  next.prev = node;\n  list.length -= i;\n}\n/**\n * @param {LinkedList<T>} list\n * @returns {T[]}\n * @template T\n */\n\n\nfunction toArray(list) {\n  var array = [];\n  var node = list.head.next;\n\n  while (node !== list.tail) {\n    array.push(node.value);\n    node = node.next;\n  }\n\n  return array;\n}\n\nexport var Prism = _; // some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/refractor/lib/prism-core.js"],"names":["lang","uniqueId","plainTextGrammar","_","util","type","o","Object","prototype","toString","call","slice","objId","obj","defineProperty","value","clone","deepClone","visited","id","key","hasOwnProperty","forEach","v","i","languages","plain","plaintext","text","txt","extend","redef","insertBefore","inside","before","insert","root","grammar","ret","token","newToken","old","DFS","callback","property","propertyType","plugins","highlight","language","env","code","hooks","run","Error","tokens","tokenize","Token","stringify","encode","rest","tokenList","LinkedList","addAfter","head","matchGrammar","toArray","all","add","name","push","callbacks","length","content","alias","matchedStr","matchPattern","pattern","pos","lookbehind","lastIndex","match","exec","lookbehindLength","index","startNode","startPos","rematch","patterns","Array","isArray","j","cause","patternObj","greedy","global","flags","RegExp","source","currentNode","next","tail","reach","str","removeCount","from","to","p","k","matchStr","after","removeFrom","prev","removeRange","wrapped","nestedRematch","list","node","newNode","count","array","Prism"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n// This is a slimmed down version of `prism-core.js`, to remove globals,\n// document, workers, `util.encode`, `Token.stringify`\n\n// Private helper vars\nvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i\nvar uniqueId = 0\n\n// The grammar object for plaintext\nvar plainTextGrammar = {}\n\nvar _ = {\n  /**\n   * A namespace for utility methods.\n   *\n   * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n   * change or disappear at any time.\n   *\n   * @namespace\n   * @memberof Prism\n   */\n  util: {\n    /**\n     * Returns the name of the type of the given value.\n     *\n     * @param {any} o\n     * @returns {string}\n     * @example\n     * type(null)      === 'Null'\n     * type(undefined) === 'Undefined'\n     * type(123)       === 'Number'\n     * type('foo')     === 'String'\n     * type(true)      === 'Boolean'\n     * type([1, 2])    === 'Array'\n     * type({})        === 'Object'\n     * type(String)    === 'Function'\n     * type(/abc+/)    === 'RegExp'\n     */\n    type: function (o) {\n      return Object.prototype.toString.call(o).slice(8, -1)\n    },\n\n    /**\n     * Returns a unique number for the given object. Later calls will still return the same number.\n     *\n     * @param {Object} obj\n     * @returns {number}\n     */\n    objId: function (obj) {\n      if (!obj['__id']) {\n        Object.defineProperty(obj, '__id', {value: ++uniqueId})\n      }\n      return obj['__id']\n    },\n\n    /**\n     * Creates a deep clone of the given object.\n     *\n     * The main intended use of this function is to clone language definitions.\n     *\n     * @param {T} o\n     * @param {Record<number, any>} [visited]\n     * @returns {T}\n     * @template T\n     */\n    clone: function deepClone(o, visited) {\n      visited = visited || {}\n\n      var clone\n      var id\n      switch (_.util.type(o)) {\n        case 'Object':\n          id = _.util.objId(o)\n          if (visited[id]) {\n            return visited[id]\n          }\n          clone = /** @type {Record<string, any>} */ ({})\n          visited[id] = clone\n\n          for (var key in o) {\n            if (o.hasOwnProperty(key)) {\n              clone[key] = deepClone(o[key], visited)\n            }\n          }\n\n          return /** @type {any} */ (clone)\n\n        case 'Array':\n          id = _.util.objId(o)\n          if (visited[id]) {\n            return visited[id]\n          }\n          clone = []\n          visited[id] = clone\n\n          o.forEach(function (v, i) {\n            clone[i] = deepClone(v, visited)\n          })\n\n          return /** @type {any} */ (clone)\n\n        default:\n          return o\n      }\n    }\n  },\n\n  /**\n   * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n   *\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  languages: {\n    /**\n     * The grammar for plain, unformatted text.\n     */\n    plain: plainTextGrammar,\n    plaintext: plainTextGrammar,\n    text: plainTextGrammar,\n    txt: plainTextGrammar,\n\n    /**\n     * Creates a deep copy of the language with the given id and appends the given tokens.\n     *\n     * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n     * will be overwritten at its original position.\n     *\n     * ## Best practices\n     *\n     * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n     * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n     * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n     *\n     * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n     * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n     *\n     * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n     * @param {Grammar} redef The new tokens to append.\n     * @returns {Grammar} The new language created.\n     * @public\n     * @example\n     * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n     *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n     *     // at its original position\n     *     'comment': { ... },\n     *     // CSS doesn't have a 'color' token, so this token will be appended\n     *     'color': /\\b(?:red|green|blue)\\b/\n     * });\n     */\n    extend: function (id, redef) {\n      var lang = _.util.clone(_.languages[id])\n\n      for (var key in redef) {\n        lang[key] = redef[key]\n      }\n\n      return lang\n    },\n\n    /**\n     * Inserts tokens _before_ another token in a language definition or any other grammar.\n     *\n     * ## Usage\n     *\n     * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n     * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n     * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n     * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n     * this:\n     *\n     * ```js\n     * Prism.languages.markup.style = {\n     *     // token\n     * };\n     * ```\n     *\n     * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n     * before existing tokens. For the CSS example above, you would use it like this:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'cdata', {\n     *     'style': {\n     *         // token\n     *     }\n     * });\n     * ```\n     *\n     * ## Special cases\n     *\n     * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n     * will be ignored.\n     *\n     * This behavior can be used to insert tokens after `before`:\n     *\n     * ```js\n     * Prism.languages.insertBefore('markup', 'comment', {\n     *     'comment': Prism.languages.markup.comment,\n     *     // tokens after 'comment'\n     * });\n     * ```\n     *\n     * ## Limitations\n     *\n     * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n     * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n     * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n     * deleting properties which is necessary to insert at arbitrary positions.\n     *\n     * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n     * Instead, it will create a new object and replace all references to the target object with the new one. This\n     * can be done without temporarily deleting properties, so the iteration order is well-defined.\n     *\n     * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n     * you hold the target object in a variable, then the value of the variable will not change.\n     *\n     * ```js\n     * var oldMarkup = Prism.languages.markup;\n     * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n     *\n     * assert(oldMarkup !== Prism.languages.markup);\n     * assert(newMarkup === Prism.languages.markup);\n     * ```\n     *\n     * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n     * object to be modified.\n     * @param {string} before The key to insert before.\n     * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n     * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n     * object to be modified.\n     *\n     * Defaults to `Prism.languages`.\n     * @returns {Grammar} The new grammar object.\n     * @public\n     */\n    insertBefore: function (inside, before, insert, root) {\n      root = root || /** @type {any} */ (_.languages)\n      var grammar = root[inside]\n      /** @type {Grammar} */\n      var ret = {}\n\n      for (var token in grammar) {\n        if (grammar.hasOwnProperty(token)) {\n          if (token == before) {\n            for (var newToken in insert) {\n              if (insert.hasOwnProperty(newToken)) {\n                ret[newToken] = insert[newToken]\n              }\n            }\n          }\n\n          // Do not insert token which also occur in insert. See #1525\n          if (!insert.hasOwnProperty(token)) {\n            ret[token] = grammar[token]\n          }\n        }\n      }\n\n      var old = root[inside]\n      root[inside] = ret\n\n      // Update references in other language definitions\n      _.languages.DFS(_.languages, function (key, value) {\n        if (value === old && key != inside) {\n          this[key] = ret\n        }\n      })\n\n      return ret\n    },\n\n    // Traverse a language definition with Depth First Search\n    DFS: function DFS(o, callback, type, visited) {\n      visited = visited || {}\n\n      var objId = _.util.objId\n\n      for (var i in o) {\n        if (o.hasOwnProperty(i)) {\n          callback.call(o, i, o[i], type || i)\n\n          var property = o[i]\n          var propertyType = _.util.type(property)\n\n          if (propertyType === 'Object' && !visited[objId(property)]) {\n            visited[objId(property)] = true\n            DFS(property, callback, null, visited)\n          } else if (propertyType === 'Array' && !visited[objId(property)]) {\n            visited[objId(property)] = true\n            DFS(property, callback, i, visited)\n          }\n        }\n      }\n    }\n  },\n\n  plugins: {},\n\n  /**\n   * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n   * and the language definitions to use, and returns a string with the HTML produced.\n   *\n   * The following hooks will be run:\n   * 1. `before-tokenize`\n   * 2. `after-tokenize`\n   * 3. `wrap`: On each {@link Token}.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @param {string} language The name of the language definition passed to `grammar`.\n   * @returns {string} The highlighted HTML.\n   * @memberof Prism\n   * @public\n   * @example\n   * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n   */\n  highlight: function (text, grammar, language) {\n    var env = {\n      code: text,\n      grammar: grammar,\n      language: language\n    }\n    _.hooks.run('before-tokenize', env)\n    if (!env.grammar) {\n      throw new Error('The language \"' + env.language + '\" has no grammar.')\n    }\n    env.tokens = _.tokenize(env.code, env.grammar)\n    _.hooks.run('after-tokenize', env)\n    return Token.stringify(_.util.encode(env.tokens), env.language)\n  },\n\n  /**\n   * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n   * and the language definitions to use, and returns an array with the tokenized code.\n   *\n   * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n   *\n   * This method could be useful in other contexts as well, as a very crude parser.\n   *\n   * @param {string} text A string with the code to be highlighted.\n   * @param {Grammar} grammar An object containing the tokens to use.\n   *\n   * Usually a language definition like `Prism.languages.markup`.\n   * @returns {TokenStream} An array of strings and tokens, a token stream.\n   * @memberof Prism\n   * @public\n   * @example\n   * let code = `var foo = 0;`;\n   * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n   * tokens.forEach(token => {\n   *     if (token instanceof Prism.Token && token.type === 'number') {\n   *         console.log(`Found numeric literal: ${token.content}`);\n   *     }\n   * });\n   */\n  tokenize: function (text, grammar) {\n    var rest = grammar.rest\n    if (rest) {\n      for (var token in rest) {\n        grammar[token] = rest[token]\n      }\n\n      delete grammar.rest\n    }\n\n    var tokenList = new LinkedList()\n    addAfter(tokenList, tokenList.head, text)\n\n    matchGrammar(text, tokenList, grammar, tokenList.head, 0)\n\n    return toArray(tokenList)\n  },\n\n  /**\n   * @namespace\n   * @memberof Prism\n   * @public\n   */\n  hooks: {\n    all: {},\n\n    /**\n     * Adds the given callback to the list of callbacks for the given hook.\n     *\n     * The callback will be invoked when the hook it is registered for is run.\n     * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n     *\n     * One callback function can be registered to multiple hooks and the same hook multiple times.\n     *\n     * @param {string} name The name of the hook.\n     * @param {HookCallback} callback The callback function which is given environment variables.\n     * @public\n     */\n    add: function (name, callback) {\n      var hooks = _.hooks.all\n\n      hooks[name] = hooks[name] || []\n\n      hooks[name].push(callback)\n    },\n\n    /**\n     * Runs a hook invoking all registered callbacks with the given environment variables.\n     *\n     * Callbacks will be invoked synchronously and in the order in which they were registered.\n     *\n     * @param {string} name The name of the hook.\n     * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n     * @public\n     */\n    run: function (name, env) {\n      var callbacks = _.hooks.all[name]\n\n      if (!callbacks || !callbacks.length) {\n        return\n      }\n\n      for (var i = 0, callback; (callback = callbacks[i++]); ) {\n        callback(env)\n      }\n    }\n  },\n\n  Token: Token\n}\n\n// Typescript note:\n// The following can be used to import the Token type in JSDoc:\n//\n//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n/**\n * Creates a new token.\n *\n * @param {string} type See {@link Token#type type}\n * @param {string | TokenStream} content See {@link Token#content content}\n * @param {string|string[]} [alias] The alias(es) of the token.\n * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n * @class\n * @global\n * @public\n */\nfunction Token(type, content, alias, matchedStr) {\n  /**\n   * The type of the token.\n   *\n   * This is usually the key of a pattern in a {@link Grammar}.\n   *\n   * @type {string}\n   * @see GrammarToken\n   * @public\n   */\n  this.type = type\n  /**\n   * The strings or tokens contained by this token.\n   *\n   * This will be a token stream if the pattern matched also defined an `inside` grammar.\n   *\n   * @type {string | TokenStream}\n   * @public\n   */\n  this.content = content\n  /**\n   * The alias(es) of the token.\n   *\n   * @type {string|string[]}\n   * @see GrammarToken\n   * @public\n   */\n  this.alias = alias\n  // Copy of the full string this token was created from\n  this.length = (matchedStr || '').length | 0\n}\n\n/**\n * A token stream is an array of strings and {@link Token Token} objects.\n *\n * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n * them.\n *\n * 1. No adjacent strings.\n * 2. No empty strings.\n *\n *    The only exception here is the token stream that only contains the empty string and nothing else.\n *\n * @typedef {Array<string | Token>} TokenStream\n * @global\n * @public\n */\n\n/**\n * @param {RegExp} pattern\n * @param {number} pos\n * @param {string} text\n * @param {boolean} lookbehind\n * @returns {RegExpExecArray | null}\n */\nfunction matchPattern(pattern, pos, text, lookbehind) {\n  pattern.lastIndex = pos\n  var match = pattern.exec(text)\n  if (match && lookbehind && match[1]) {\n    // change the match to remove the text matched by the Prism lookbehind group\n    var lookbehindLength = match[1].length\n    match.index += lookbehindLength\n    match[0] = match[0].slice(lookbehindLength)\n  }\n  return match\n}\n\n/**\n * @param {string} text\n * @param {LinkedList<string | Token>} tokenList\n * @param {any} grammar\n * @param {LinkedListNode<string | Token>} startNode\n * @param {number} startPos\n * @param {RematchOptions} [rematch]\n * @returns {void}\n * @private\n *\n * @typedef RematchOptions\n * @property {string} cause\n * @property {number} reach\n */\nfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n  for (var token in grammar) {\n    if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n      continue\n    }\n\n    var patterns = grammar[token]\n    patterns = Array.isArray(patterns) ? patterns : [patterns]\n\n    for (var j = 0; j < patterns.length; ++j) {\n      if (rematch && rematch.cause == token + ',' + j) {\n        return\n      }\n\n      var patternObj = patterns[j]\n      var inside = patternObj.inside\n      var lookbehind = !!patternObj.lookbehind\n      var greedy = !!patternObj.greedy\n      var alias = patternObj.alias\n\n      if (greedy && !patternObj.pattern.global) {\n        // Without the global flag, lastIndex won't work\n        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0]\n        patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g')\n      }\n\n      /** @type {RegExp} */\n      var pattern = patternObj.pattern || patternObj\n\n      for (\n        // iterate the token list and keep track of the current token/string position\n        var currentNode = startNode.next, pos = startPos;\n        currentNode !== tokenList.tail;\n        pos += currentNode.value.length, currentNode = currentNode.next\n      ) {\n        if (rematch && pos >= rematch.reach) {\n          break\n        }\n\n        var str = currentNode.value\n\n        if (tokenList.length > text.length) {\n          // Something went terribly wrong, ABORT, ABORT!\n          return\n        }\n\n        if (str instanceof Token) {\n          continue\n        }\n\n        var removeCount = 1 // this is the to parameter of removeBetween\n        var match\n\n        if (greedy) {\n          match = matchPattern(pattern, pos, text, lookbehind)\n          if (!match || match.index >= text.length) {\n            break\n          }\n\n          var from = match.index\n          var to = match.index + match[0].length\n          var p = pos\n\n          // find the node that contains the match\n          p += currentNode.value.length\n          while (from >= p) {\n            currentNode = currentNode.next\n            p += currentNode.value.length\n          }\n          // adjust pos (and p)\n          p -= currentNode.value.length\n          pos = p\n\n          // the current node is a Token, then the match starts inside another Token, which is invalid\n          if (currentNode.value instanceof Token) {\n            continue\n          }\n\n          // find the last node which is affected by this match\n          for (\n            var k = currentNode;\n            k !== tokenList.tail && (p < to || typeof k.value === 'string');\n            k = k.next\n          ) {\n            removeCount++\n            p += k.value.length\n          }\n          removeCount--\n\n          // replace with the new match\n          str = text.slice(pos, p)\n          match.index -= pos\n        } else {\n          match = matchPattern(pattern, 0, str, lookbehind)\n          if (!match) {\n            continue\n          }\n        }\n\n        // eslint-disable-next-line no-redeclare\n        var from = match.index\n        var matchStr = match[0]\n        var before = str.slice(0, from)\n        var after = str.slice(from + matchStr.length)\n\n        var reach = pos + str.length\n        if (rematch && reach > rematch.reach) {\n          rematch.reach = reach\n        }\n\n        var removeFrom = currentNode.prev\n\n        if (before) {\n          removeFrom = addAfter(tokenList, removeFrom, before)\n          pos += before.length\n        }\n\n        removeRange(tokenList, removeFrom, removeCount)\n\n        var wrapped = new Token(\n          token,\n          inside ? _.tokenize(matchStr, inside) : matchStr,\n          alias,\n          matchStr\n        )\n        currentNode = addAfter(tokenList, removeFrom, wrapped)\n\n        if (after) {\n          addAfter(tokenList, currentNode, after)\n        }\n\n        if (removeCount > 1) {\n          // at least one Token object was removed, so we have to do some rematching\n          // this can only happen if the current pattern is greedy\n\n          /** @type {RematchOptions} */\n          var nestedRematch = {\n            cause: token + ',' + j,\n            reach: reach\n          }\n          matchGrammar(\n            text,\n            tokenList,\n            grammar,\n            currentNode.prev,\n            pos,\n            nestedRematch\n          )\n\n          // the reach might have been extended because of the rematching\n          if (rematch && nestedRematch.reach > rematch.reach) {\n            rematch.reach = nestedRematch.reach\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * @typedef LinkedListNode\n * @property {T} value\n * @property {LinkedListNode<T> | null} prev The previous node.\n * @property {LinkedListNode<T> | null} next The next node.\n * @template T\n * @private\n */\n\n/**\n * @template T\n * @private\n */\nfunction LinkedList() {\n  /** @type {LinkedListNode<T>} */\n  var head = {value: null, prev: null, next: null}\n  /** @type {LinkedListNode<T>} */\n  var tail = {value: null, prev: head, next: null}\n  head.next = tail\n\n  /** @type {LinkedListNode<T>} */\n  this.head = head\n  /** @type {LinkedListNode<T>} */\n  this.tail = tail\n  this.length = 0\n}\n\n/**\n * Adds a new node with the given value to the list.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {T} value\n * @returns {LinkedListNode<T>} The added node.\n * @template T\n */\nfunction addAfter(list, node, value) {\n  // assumes that node != list.tail && values.length >= 0\n  var next = node.next\n\n  var newNode = {value: value, prev: node, next: next}\n  node.next = newNode\n  next.prev = newNode\n  list.length++\n\n  return newNode\n}\n/**\n * Removes `count` nodes after the given node. The given node will not be removed.\n *\n * @param {LinkedList<T>} list\n * @param {LinkedListNode<T>} node\n * @param {number} count\n * @template T\n */\nfunction removeRange(list, node, count) {\n  var next = node.next\n  for (var i = 0; i < count && next !== list.tail; i++) {\n    next = next.next\n  }\n  node.next = next\n  next.prev = node\n  list.length -= i\n}\n/**\n * @param {LinkedList<T>} list\n * @returns {T[]}\n * @template T\n */\nfunction toArray(list) {\n  var array = []\n  var node = list.head.next\n  while (node !== list.tail) {\n    array.push(node.value)\n    node = node.next\n  }\n  return array\n}\n\nexport const Prism = _\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n"]},"metadata":{},"sourceType":"module"}