{"ast":null,"code":"import _toConsumableArray from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Selectors} Selectors\n *\n * @typedef Nest\n *   Rule sets by nesting.\n * @property {Array<RuleSet> | undefined} descendant\n *   `a b`\n * @property {Array<RuleSet> | undefined} directChild\n *   `a > b`\n * @property {Array<RuleSet> | undefined} adjacentSibling\n *   `a + b`\n * @property {Array<RuleSet> | undefined} generalSibling\n *   `a ~ b`\n *\n * @typedef Counts\n *   Info on elements in a parent.\n * @property {number} count\n *   Number of elements.\n * @property {Map<string, number>} types\n *   Number of elements by tag name.\n */\nimport { enterState } from './enter-state.js';\nimport { test } from './test.js';\n/** @type {Array<never>} */\n\nvar empty = [];\n/**\n * Turn a query into a uniform object.\n *\n * @param {Selectors | RuleSet | null} query\n * @returns {Selectors}\n */\n\nexport function queryToSelectors(query) {\n  if (query === null) {\n    return {\n      type: 'selectors',\n      selectors: []\n    };\n  }\n\n  if (query.type === 'ruleSet') {\n    return {\n      type: 'selectors',\n      selectors: [query]\n    };\n  }\n\n  return query;\n}\n/**\n * Walk a tree.\n *\n * @param {SelectState} state\n * @param {Node | undefined} tree\n */\n\nexport function walk(state, tree) {\n  if (tree) {\n    one(state, [], tree, undefined, undefined);\n  }\n}\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Array<RuleSet>} currentRules\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @returns {Nest}\n */\n\nfunction one(state, currentRules, node, index, parent) {\n  /** @type {Nest} */\n  var nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  };\n  var exit = enterState(state, node);\n\n  if (node.type === 'element') {\n    nestResult = applySelectors(state, // Try the root rules for this element too.\n    combine(currentRules, state.rootQuery.selectors), node, index, parent);\n  } // If this is a parent, and we want to delve into them, and we haven’t found\n  // our single result yet.\n\n\n  if ('children' in node && !state.shallow && !(state.one && state.found)) {\n    all(state, nestResult, node);\n  }\n\n  exit();\n  return nestResult;\n}\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Nest} nest\n * @param {Parent} node\n * @returns {void}\n */\n\n\nfunction all(state, nest, node) {\n  var fromParent = combine(nest.descendant, nest.directChild);\n  /** @type {Array<RuleSet> | undefined} */\n\n  var fromSibling;\n  var index = -1;\n  /**\n   * Total counts.\n   * @type {Counts}\n   */\n\n  var total = {\n    count: 0,\n    types: new Map()\n  };\n  /**\n   * Counts of previous siblings.\n   * @type {Counts}\n   */\n\n  var before = {\n    count: 0,\n    types: new Map()\n  };\n\n  while (++index < node.children.length) {\n    count(total, node.children[index]);\n  }\n\n  index = -1;\n\n  while (++index < node.children.length) {\n    var child = node.children[index]; // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n\n    var name = child.type === 'element' ? child.tagName.toUpperCase() : undefined; // Before counting further elements:\n\n    state.elementIndex = before.count;\n    state.typeIndex = name ? before.types.get(name) || 0 : 0; // After counting all elements.\n\n    state.elementCount = total.count;\n    state.typeCount = name ? total.types.get(name) : 0; // Only apply if this is a parent, this should be an element, but we check\n    // for parents so that we delve into custom nodes too.\n\n    if ('children' in child) {\n      var forSibling = combine(fromParent, fromSibling);\n\n      var _nest = one(state, forSibling, node.children[index], index, node);\n\n      fromSibling = combine(_nest.generalSibling, _nest.adjacentSibling);\n    } // We found one thing, and one is enough.\n\n\n    if (state.one && state.found) {\n      break;\n    }\n\n    count(before, node.children[index]);\n  }\n}\n/**\n * Apply selectors to an element.\n *\n * @param {SelectState} state\n *   Current state.\n * @param {Array<RuleSet>} rules\n *   Rules to apply.\n * @param {Element} node\n *   Element to apply rules to.\n * @param {number | undefined} index\n *   Index of node in parent.\n * @param {Parent | undefined} parent\n *   Parent of node.\n * @returns {Nest}\n *   Further rules.\n */\n\n\nfunction applySelectors(state, rules, node, index, parent) {\n  /** @type {Nest} */\n  var nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  };\n  var selectorIndex = -1;\n\n  while (++selectorIndex < rules.length) {\n    var ruleSet = rules[selectorIndex]; // We found one thing, and one is enough.\n\n    if (state.one && state.found) {\n      break;\n    } // When shallow, we don’t allow nested rules.\n    // Idea: we could allow a stack of parents?\n    // Might get quite complex though.\n\n\n    if (state.shallow && ruleSet.rule.rule) {\n      throw new Error('Expected selector without nesting');\n    } // If this rule matches:\n\n\n    if (test(ruleSet.rule, node, index, parent, state)) {\n      var nest = ruleSet.rule.rule; // Are there more?\n\n      if (nest) {\n        /** @type {RuleSet} */\n        var rule = {\n          type: 'ruleSet',\n          rule: nest\n        };\n        /** @type {keyof Nest} */\n\n        var label = nest.nestingOperator === '+' ? 'adjacentSibling' : nest.nestingOperator === '~' ? 'generalSibling' : nest.nestingOperator === '>' ? 'directChild' : 'descendant';\n        add(nestResult, label, rule);\n      } else {\n        // We have a match!\n        state.found = true;\n\n        if (!state.results.includes(node)) {\n          state.results.push(node);\n        }\n      }\n    } // Descendant.\n\n\n    if (ruleSet.rule.nestingOperator === null) {\n      add(nestResult, 'descendant', ruleSet);\n    } // Adjacent.\n    else if (ruleSet.rule.nestingOperator === '~') {\n      add(nestResult, 'generalSibling', ruleSet);\n    } // Drop top-level nesting (`undefined`), direct child (`>`), adjacent sibling (`+`).\n\n  }\n\n  return nestResult;\n}\n/**\n * Combine two lists, if needed.\n *\n * This is optimized to create as few lists as possible.\n *\n * @param {Array<RuleSet> | undefined} left\n * @param {Array<RuleSet> | undefined} right\n * @returns {Array<RuleSet>}\n */\n\n\nfunction combine(left, right) {\n  return left && right && left.length > 0 && right.length > 0 ? [].concat(_toConsumableArray(left), _toConsumableArray(right)) : left && left.length > 0 ? left : right && right.length > 0 ? right : empty;\n}\n/**\n * Add a rule to a nesting map.\n *\n * @param {Nest} nest\n * @param {keyof Nest} field\n * @param {RuleSet} rule\n */\n\n\nfunction add(nest, field, rule) {\n  var list = nest[field];\n\n  if (list) {\n    list.push(rule);\n  } else {\n    nest[field] = [rule];\n  }\n}\n/**\n * Count a node.\n *\n * @param {Counts} counts\n *   Counts.\n * @param {Node} node\n *   Node (we’re looking for elements).\n * @returns {void}\n *   Nothing.\n */\n\n\nfunction count(counts, node) {\n  if (node.type === 'element') {\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    var name = node.tagName.toUpperCase();\n\n    var _count = (counts.types.get(name) || 0) + 1;\n\n    counts.count++;\n    counts.types.set(name, _count);\n  }\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/hast-util-select/lib/walk.js"],"names":["enterState","test","empty","queryToSelectors","query","type","selectors","walk","state","tree","one","undefined","currentRules","node","index","parent","nestResult","directChild","descendant","adjacentSibling","generalSibling","exit","applySelectors","combine","rootQuery","shallow","found","all","nest","fromParent","fromSibling","total","count","types","Map","before","children","length","child","name","tagName","toUpperCase","elementIndex","typeIndex","get","elementCount","typeCount","forSibling","rules","selectorIndex","ruleSet","rule","Error","label","nestingOperator","add","results","includes","push","left","right","field","list","counts","set"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Selectors} Selectors\n *\n * @typedef Nest\n *   Rule sets by nesting.\n * @property {Array<RuleSet> | undefined} descendant\n *   `a b`\n * @property {Array<RuleSet> | undefined} directChild\n *   `a > b`\n * @property {Array<RuleSet> | undefined} adjacentSibling\n *   `a + b`\n * @property {Array<RuleSet> | undefined} generalSibling\n *   `a ~ b`\n *\n * @typedef Counts\n *   Info on elements in a parent.\n * @property {number} count\n *   Number of elements.\n * @property {Map<string, number>} types\n *   Number of elements by tag name.\n */\n\nimport {enterState} from './enter-state.js'\nimport {test} from './test.js'\n\n/** @type {Array<never>} */\nconst empty = []\n\n/**\n * Turn a query into a uniform object.\n *\n * @param {Selectors | RuleSet | null} query\n * @returns {Selectors}\n */\nexport function queryToSelectors(query) {\n  if (query === null) {\n    return {type: 'selectors', selectors: []}\n  }\n\n  if (query.type === 'ruleSet') {\n    return {type: 'selectors', selectors: [query]}\n  }\n\n  return query\n}\n\n/**\n * Walk a tree.\n *\n * @param {SelectState} state\n * @param {Node | undefined} tree\n */\nexport function walk(state, tree) {\n  if (tree) {\n    one(state, [], tree, undefined, undefined)\n  }\n}\n\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Array<RuleSet>} currentRules\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @returns {Nest}\n */\nfunction one(state, currentRules, node, index, parent) {\n  /** @type {Nest} */\n  let nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  }\n  const exit = enterState(state, node)\n\n  if (node.type === 'element') {\n    nestResult = applySelectors(\n      state,\n      // Try the root rules for this element too.\n      combine(currentRules, state.rootQuery.selectors),\n      node,\n      index,\n      parent\n    )\n  }\n\n  // If this is a parent, and we want to delve into them, and we haven’t found\n  // our single result yet.\n  if ('children' in node && !state.shallow && !(state.one && state.found)) {\n    all(state, nestResult, node)\n  }\n\n  exit()\n\n  return nestResult\n}\n\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Nest} nest\n * @param {Parent} node\n * @returns {void}\n */\nfunction all(state, nest, node) {\n  const fromParent = combine(nest.descendant, nest.directChild)\n  /** @type {Array<RuleSet> | undefined} */\n  let fromSibling\n  let index = -1\n  /**\n   * Total counts.\n   * @type {Counts}\n   */\n  const total = {count: 0, types: new Map()}\n  /**\n   * Counts of previous siblings.\n   * @type {Counts}\n   */\n  const before = {count: 0, types: new Map()}\n\n  while (++index < node.children.length) {\n    count(total, node.children[index])\n  }\n\n  index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name =\n      child.type === 'element' ? child.tagName.toUpperCase() : undefined\n    // Before counting further elements:\n    state.elementIndex = before.count\n    state.typeIndex = name ? before.types.get(name) || 0 : 0\n    // After counting all elements.\n    state.elementCount = total.count\n    state.typeCount = name ? total.types.get(name) : 0\n\n    // Only apply if this is a parent, this should be an element, but we check\n    // for parents so that we delve into custom nodes too.\n    if ('children' in child) {\n      const forSibling = combine(fromParent, fromSibling)\n      const nest = one(state, forSibling, node.children[index], index, node)\n      fromSibling = combine(nest.generalSibling, nest.adjacentSibling)\n    }\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    count(before, node.children[index])\n  }\n}\n\n/**\n * Apply selectors to an element.\n *\n * @param {SelectState} state\n *   Current state.\n * @param {Array<RuleSet>} rules\n *   Rules to apply.\n * @param {Element} node\n *   Element to apply rules to.\n * @param {number | undefined} index\n *   Index of node in parent.\n * @param {Parent | undefined} parent\n *   Parent of node.\n * @returns {Nest}\n *   Further rules.\n */\nfunction applySelectors(state, rules, node, index, parent) {\n  /** @type {Nest} */\n  const nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  }\n  let selectorIndex = -1\n\n  while (++selectorIndex < rules.length) {\n    const ruleSet = rules[selectorIndex]\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    // When shallow, we don’t allow nested rules.\n    // Idea: we could allow a stack of parents?\n    // Might get quite complex though.\n    if (state.shallow && ruleSet.rule.rule) {\n      throw new Error('Expected selector without nesting')\n    }\n\n    // If this rule matches:\n    if (test(ruleSet.rule, node, index, parent, state)) {\n      const nest = ruleSet.rule.rule\n\n      // Are there more?\n      if (nest) {\n        /** @type {RuleSet} */\n        const rule = {type: 'ruleSet', rule: nest}\n        /** @type {keyof Nest} */\n        const label =\n          nest.nestingOperator === '+'\n            ? 'adjacentSibling'\n            : nest.nestingOperator === '~'\n            ? 'generalSibling'\n            : nest.nestingOperator === '>'\n            ? 'directChild'\n            : 'descendant'\n        add(nestResult, label, rule)\n      } else {\n        // We have a match!\n        state.found = true\n\n        if (!state.results.includes(node)) {\n          state.results.push(node)\n        }\n      }\n    }\n\n    // Descendant.\n    if (ruleSet.rule.nestingOperator === null) {\n      add(nestResult, 'descendant', ruleSet)\n    }\n    // Adjacent.\n    else if (ruleSet.rule.nestingOperator === '~') {\n      add(nestResult, 'generalSibling', ruleSet)\n    }\n    // Drop top-level nesting (`undefined`), direct child (`>`), adjacent sibling (`+`).\n  }\n\n  return nestResult\n}\n\n/**\n * Combine two lists, if needed.\n *\n * This is optimized to create as few lists as possible.\n *\n * @param {Array<RuleSet> | undefined} left\n * @param {Array<RuleSet> | undefined} right\n * @returns {Array<RuleSet>}\n */\nfunction combine(left, right) {\n  return left && right && left.length > 0 && right.length > 0\n    ? [...left, ...right]\n    : left && left.length > 0\n    ? left\n    : right && right.length > 0\n    ? right\n    : empty\n}\n\n/**\n * Add a rule to a nesting map.\n *\n * @param {Nest} nest\n * @param {keyof Nest} field\n * @param {RuleSet} rule\n */\nfunction add(nest, field, rule) {\n  const list = nest[field]\n  if (list) {\n    list.push(rule)\n  } else {\n    nest[field] = [rule]\n  }\n}\n\n/**\n * Count a node.\n *\n * @param {Counts} counts\n *   Counts.\n * @param {Node} node\n *   Node (we’re looking for elements).\n * @returns {void}\n *   Nothing.\n */\nfunction count(counts, node) {\n  if (node.type === 'element') {\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name = node.tagName.toUpperCase()\n    const count = (counts.types.get(name) || 0) + 1\n    counts.count++\n    counts.types.set(name, count)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}