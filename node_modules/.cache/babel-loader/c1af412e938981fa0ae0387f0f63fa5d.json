{"ast":null,"code":"import _objectSpread from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\n/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {import('../complex-types').Raw} Raw\n *\n * @typedef {Omit<Comment, 'value'> & {value: {stitch: Node}}} Stitch\n *\n * @typedef Options\n * @property {Array<string>} [passThrough]\n *   List of custom hast node types to pass through (keep) in hast.\n *   If the passed through nodes have children, those children are expected to\n *   be hast and will be handled.\n *\n * @typedef HiddenTokenizer\n * @property {Array<HiddenLocationTracker>} __mixins\n *   Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {() => number} _consume\n * @property {Array<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array<number>} tempBuff\n * @property {Function} _flushCodePointsConsumedAsCharacterReference\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n * @property {Function} NAMED_CHARACTER_REFERENCE_STATE\n * @property {Function} NUMERIC_CHARACTER_REFERENCE_END_STATE\n *\n * @typedef {Record<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n// @ts-expect-error: untyped.\nimport Parser from 'parse5/lib/parser/index.js';\nimport { pointStart, pointEnd } from 'unist-util-position';\nimport { visit } from 'unist-util-visit';\nimport { fromParse5 } from 'hast-util-from-parse5';\nimport { toParse5 } from 'hast-util-to-parse5';\nimport { htmlVoidElements } from 'html-void-elements';\nimport { webNamespaces } from 'web-namespaces';\nimport { zwitch } from 'zwitch';\nvar inTemplateMode = 'IN_TEMPLATE_MODE';\nvar dataState = 'DATA_STATE';\nvar characterToken = 'CHARACTER_TOKEN';\nvar startTagToken = 'START_TAG_TOKEN';\nvar endTagToken = 'END_TAG_TOKEN';\nvar commentToken = 'COMMENT_TOKEN';\nvar doctypeToken = 'DOCTYPE_TOKEN';\n/** @type {P5ParserOptions} */\n\nvar parseOptions = {\n  sourceCodeLocationInfo: true,\n  scriptingEnabled: false\n};\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param tree\n *   Original hast tree.\n * @param file\n *   Virtual file for positional info, optional.\n * @param options\n *   Configuration.\n */\n\nexport var raw =\n/**\n * @param {Node} tree\n * @param {VFile} [file]\n * @param {Options} [options]\n */\nfunction raw(tree, file, options) {\n  var index = -1;\n  var parser = new Parser(parseOptions);\n  var one = zwitch('type', {\n    handlers: {\n      root: root,\n      element: element,\n      text: text,\n      comment: comment,\n      doctype: doctype,\n      raw: handleRaw\n    },\n    // @ts-expect-error: hush.\n    unknown: unknown\n  });\n  /** @type {boolean|undefined} */\n\n  var stitches;\n  /** @type {HiddenTokenizer|undefined} */\n\n  var tokenizer;\n  /** @type {HiddenPreprocessor|undefined} */\n\n  var preprocessor;\n  /** @type {HiddenPosTracker|undefined} */\n\n  var posTracker;\n  /** @type {HiddenLocationTracker|undefined} */\n\n  var locationTracker;\n\n  if (isOptions(file)) {\n    options = file;\n    file = undefined;\n  }\n\n  if (options && options.passThrough) {\n    while (++index < options.passThrough.length) {\n      // @ts-expect-error: hush.\n      one.handlers[options.passThrough[index]] = stitch;\n    }\n  }\n\n  var result = fromParse5(documentMode(tree) ? document() : fragment(), file);\n\n  if (stitches) {\n    visit(result, 'comment', function (node, index, parent) {\n      var stitch = node;\n\n      if (stitch.value.stitch && parent !== null && index !== null) {\n        // @ts-expect-error: assume the stitch is allowed.\n        parent.children[index] = stitch.value.stitch;\n        return index;\n      }\n    });\n  } // Unpack if possible and when not given a `root`.\n\n\n  if (tree.type !== 'root' && result.type === 'root' && result.children.length === 1) {\n    return result.children[0];\n  }\n\n  return result;\n  /**\n   * @returns {P5Fragment}\n   */\n\n  function fragment() {\n    /** @type {P5Element} */\n    var context = {\n      nodeName: 'template',\n      tagName: 'template',\n      attrs: [],\n      namespaceURI: webNamespaces.html,\n      childNodes: []\n    };\n    /** @type {P5Element} */\n\n    var mock = {\n      nodeName: 'documentmock',\n      tagName: 'documentmock',\n      attrs: [],\n      namespaceURI: webNamespaces.html,\n      childNodes: []\n    };\n    /** @type {P5Fragment} */\n\n    var doc = {\n      nodeName: '#document-fragment',\n      childNodes: []\n    };\n\n    parser._bootstrap(mock, context);\n\n    parser._pushTmplInsertionMode(inTemplateMode);\n\n    parser._initTokenizerForFragmentParsing();\n\n    parser._insertFakeRootElement();\n\n    parser._resetInsertionMode();\n\n    parser._findFormInFragmentContext();\n\n    tokenizer = parser.tokenizer;\n    /* c8 ignore next */\n\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    preprocessor = tokenizer.preprocessor;\n    locationTracker = tokenizer.__mixins[0];\n    posTracker = locationTracker.posTracker;\n    one(tree);\n    resetTokenizer();\n\n    parser._adoptNodes(mock.childNodes[0], doc);\n\n    return doc;\n  }\n  /**\n   * @returns {P5Document}\n   */\n\n\n  function document() {\n    /** @type {P5Document} */\n    var doc = parser.treeAdapter.createDocument();\n\n    parser._bootstrap(doc, undefined);\n\n    tokenizer = parser.tokenizer;\n    /* c8 ignore next */\n\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    preprocessor = tokenizer.preprocessor;\n    locationTracker = tokenizer.__mixins[0];\n    posTracker = locationTracker.posTracker;\n    one(tree);\n    resetTokenizer();\n    return doc;\n  }\n  /**\n   * @param {Array<Content>} nodes\n   * @returns {void}\n   */\n\n\n  function all(nodes) {\n    var index = -1;\n    /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n\n    if (nodes) {\n      while (++index < nodes.length) {\n        one(nodes[index]);\n      }\n    }\n  }\n  /**\n   * @param {Root} node\n   * @returns {void}\n   */\n\n\n  function root(node) {\n    all(node.children);\n  }\n  /**\n   * @param {Element} node\n   * @returns {void}\n   */\n\n\n  function element(node) {\n    resetTokenizer();\n\n    parser._processInputToken(startTag(node));\n\n    all(node.children);\n\n    if (!htmlVoidElements.includes(node.tagName)) {\n      resetTokenizer();\n\n      parser._processInputToken(endTag(node));\n    }\n  }\n  /**\n   * @param {Text} node\n   * @returns {void}\n   */\n\n\n  function text(node) {\n    resetTokenizer();\n\n    parser._processInputToken({\n      type: characterToken,\n      chars: node.value,\n      location: createParse5Location(node)\n    });\n  }\n  /**\n   * @param {Doctype} node\n   * @returns {void}\n   */\n\n\n  function doctype(node) {\n    resetTokenizer();\n\n    parser._processInputToken({\n      type: doctypeToken,\n      name: 'html',\n      forceQuirks: false,\n      publicId: '',\n      systemId: '',\n      location: createParse5Location(node)\n    });\n  }\n  /**\n   * @param {Comment|Stitch} node\n   * @returns {void}\n   */\n\n\n  function comment(node) {\n    resetTokenizer();\n\n    parser._processInputToken({\n      type: commentToken,\n      data: node.value,\n      location: createParse5Location(node)\n    });\n  }\n  /**\n   * @param {Raw} node\n   * @returns {void}\n   */\n\n\n  function handleRaw(node) {\n    var start = pointStart(node);\n    var line = start.line || 1;\n    var column = start.column || 1;\n    var offset = start.offset || 0;\n    /* c8 ignore next 4 */\n\n    if (!preprocessor) throw new Error('Expected `preprocessor`');\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    if (!posTracker) throw new Error('Expected `posTracker`');\n    if (!locationTracker) throw new Error('Expected `locationTracker`'); // Reset preprocessor:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js#L17>.\n\n    preprocessor.html = undefined;\n    preprocessor.pos = -1;\n    preprocessor.lastGapPos = -1;\n    preprocessor.lastCharPos = -1;\n    preprocessor.gapStack = [];\n    preprocessor.skipNextNewLine = false;\n    preprocessor.lastChunkWritten = false;\n    preprocessor.endOfChunkHit = false; // Reset preprocessor mixin:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n\n    posTracker.isEol = false;\n    posTracker.lineStartPos = -column + 1; // Looks weird, but ensures we get correct positional info.\n\n    posTracker.droppedBufferSize = offset;\n    posTracker.offset = 0;\n    posTracker.col = 1;\n    posTracker.line = line; // Reset location tracker:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n\n    locationTracker.currentAttrLocation = undefined;\n    locationTracker.ctLoc = createParse5Location(node); // See the code for `parse` and `parseFragment`:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n\n    tokenizer.write(node.value);\n\n    parser._runParsingLoop(null); // Character references hang, so if we ended there, we need to flush\n    // those too.\n    // We reset the preprocessor as if the document ends here.\n    // Then one single call to the relevant state does the trick, parse5\n    // consumes the whole token.\n\n\n    if (tokenizer.state === 'NAMED_CHARACTER_REFERENCE_STATE' || tokenizer.state === 'NUMERIC_CHARACTER_REFERENCE_END_STATE') {\n      preprocessor.lastChunkWritten = true;\n      tokenizer[tokenizer.state](tokenizer._consume());\n    }\n  }\n  /**\n   * @param {Node} node\n   */\n\n\n  function stitch(node) {\n    stitches = true;\n    /** @type {Node} */\n\n    var clone; // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n    // passed through node).\n\n    if ('children' in node) {\n      clone = _objectSpread(_objectSpread({}, node), {}, {\n        children: raw({\n          type: 'root',\n          children: node.children\n        }, file, options // @ts-expect-error Assume a given parent yields a parent.\n        ).children\n      });\n    } else {\n      clone = _objectSpread({}, node);\n    } // Hack: `value` is supposed to be a string, but as none of the tools\n    // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n    // through.\n\n\n    comment({\n      type: 'comment',\n      value: {\n        stitch: clone\n      }\n    });\n  }\n\n  function resetTokenizer() {\n    /* c8 ignore next 2 */\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    if (!posTracker) throw new Error('Expected `posTracker`'); // Process final characters if they’re still there after hibernating.\n    // Similar to:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n\n    var token = tokenizer.currentCharacterToken;\n\n    if (token) {\n      token.location.endLine = posTracker.line;\n      token.location.endCol = posTracker.col + 1;\n      token.location.endOffset = posTracker.offset + 1;\n\n      parser._processInputToken(token);\n    } // Reset tokenizer:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n    // Especially putting it back in the `data` state is useful: some elements,\n    // like textareas and iframes, change the state.\n    // See GH-7.\n    // But also if broken HTML is in `raw`, and then a correct element is given.\n    // See GH-11.\n\n\n    tokenizer.tokenQueue = [];\n    tokenizer.state = dataState;\n    tokenizer.returnState = '';\n    tokenizer.charRefCode = -1;\n    tokenizer.tempBuff = [];\n    tokenizer.lastStartTagName = '';\n    tokenizer.consumedAfterSnapshot = -1;\n    tokenizer.active = false;\n    tokenizer.currentCharacterToken = undefined;\n    tokenizer.currentToken = undefined;\n    tokenizer.currentAttr = undefined;\n  }\n};\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\n\nfunction startTag(node) {\n  /** @type {P5Location} */\n  var location = Object.assign(createParse5Location(node)); // @ts-expect-error extra positional info.\n\n  location.startTag = Object.assign({}, location); // Untyped token.\n\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location: location\n  };\n}\n/**\n * @param {Element} node\n * @returns {Array<P5Attribute>}\n */\n\n\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: [] // @ts-expect-error Assume element.\n\n  }).attrs;\n}\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\n\n\nfunction endTag(node) {\n  /** @type {P5Location} */\n  var location = Object.assign(createParse5Location(node)); // @ts-expect-error extra positional info.\n\n  location.startTag = Object.assign({}, location); // Untyped token.\n\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location: location\n  };\n}\n/**\n * @param {Node} node\n */\n\n\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node');\n}\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\nfunction documentMode(node) {\n  var head = node.type === 'root' ? node.children[0] : node;\n  return Boolean(head && (head.type === 'doctype' || head.type === 'element' && head.tagName === 'html'));\n}\n/**\n * @param {Node|Stitch} node\n * @returns {P5Location}\n */\n\n\nfunction createParse5Location(node) {\n  var start = pointStart(node);\n  var end = pointEnd(node);\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  };\n}\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\n\n\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value));\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/hast-util-raw/lib/index.js"],"names":["Parser","pointStart","pointEnd","visit","fromParse5","toParse5","htmlVoidElements","webNamespaces","zwitch","inTemplateMode","dataState","characterToken","startTagToken","endTagToken","commentToken","doctypeToken","parseOptions","sourceCodeLocationInfo","scriptingEnabled","raw","tree","file","options","index","parser","one","handlers","root","element","text","comment","doctype","handleRaw","unknown","stitches","tokenizer","preprocessor","posTracker","locationTracker","isOptions","undefined","passThrough","length","stitch","result","documentMode","document","fragment","node","parent","value","children","type","context","nodeName","tagName","attrs","namespaceURI","html","childNodes","mock","doc","_bootstrap","_pushTmplInsertionMode","_initTokenizerForFragmentParsing","_insertFakeRootElement","_resetInsertionMode","_findFormInFragmentContext","Error","__mixins","resetTokenizer","_adoptNodes","treeAdapter","createDocument","all","nodes","_processInputToken","startTag","includes","endTag","chars","location","createParse5Location","name","forceQuirks","publicId","systemId","data","start","line","column","offset","pos","lastGapPos","lastCharPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","isEol","lineStartPos","droppedBufferSize","col","currentAttrLocation","ctLoc","write","_runParsingLoop","state","_consume","clone","token","currentCharacterToken","endLine","endCol","endOffset","tokenQueue","returnState","charRefCode","tempBuff","lastStartTagName","consumedAfterSnapshot","active","currentToken","currentAttr","Object","assign","selfClosing","attributes","properties","head","Boolean","end","startLine","startCol","startOffset"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {import('../complex-types').Raw} Raw\n *\n * @typedef {Omit<Comment, 'value'> & {value: {stitch: Node}}} Stitch\n *\n * @typedef Options\n * @property {Array<string>} [passThrough]\n *   List of custom hast node types to pass through (keep) in hast.\n *   If the passed through nodes have children, those children are expected to\n *   be hast and will be handled.\n *\n * @typedef HiddenTokenizer\n * @property {Array<HiddenLocationTracker>} __mixins\n *   Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {() => number} _consume\n * @property {Array<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array<number>} tempBuff\n * @property {Function} _flushCodePointsConsumedAsCharacterReference\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n * @property {Function} NAMED_CHARACTER_REFERENCE_STATE\n * @property {Function} NUMERIC_CHARACTER_REFERENCE_END_STATE\n *\n * @typedef {Record<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n\n// @ts-expect-error: untyped.\nimport Parser from 'parse5/lib/parser/index.js'\nimport {pointStart, pointEnd} from 'unist-util-position'\nimport {visit} from 'unist-util-visit'\nimport {fromParse5} from 'hast-util-from-parse5'\nimport {toParse5} from 'hast-util-to-parse5'\nimport {htmlVoidElements} from 'html-void-elements'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\nconst inTemplateMode = 'IN_TEMPLATE_MODE'\nconst dataState = 'DATA_STATE'\nconst characterToken = 'CHARACTER_TOKEN'\nconst startTagToken = 'START_TAG_TOKEN'\nconst endTagToken = 'END_TAG_TOKEN'\nconst commentToken = 'COMMENT_TOKEN'\nconst doctypeToken = 'DOCTYPE_TOKEN'\n\n/** @type {P5ParserOptions} */\nconst parseOptions = {sourceCodeLocationInfo: true, scriptingEnabled: false}\n\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param tree\n *   Original hast tree.\n * @param file\n *   Virtual file for positional info, optional.\n * @param options\n *   Configuration.\n */\nexport const raw =\n  /**\n   * @type {(\n   *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &\n   *   ((tree: Node, options?: Options) => Node)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {VFile} [file]\n     * @param {Options} [options]\n     */\n    function (tree, file, options) {\n      let index = -1\n      const parser = new Parser(parseOptions)\n      const one = zwitch('type', {\n        handlers: {root, element, text, comment, doctype, raw: handleRaw},\n        // @ts-expect-error: hush.\n        unknown\n      })\n      /** @type {boolean|undefined} */\n      let stitches\n      /** @type {HiddenTokenizer|undefined} */\n      let tokenizer\n      /** @type {HiddenPreprocessor|undefined} */\n      let preprocessor\n      /** @type {HiddenPosTracker|undefined} */\n      let posTracker\n      /** @type {HiddenLocationTracker|undefined} */\n      let locationTracker\n\n      if (isOptions(file)) {\n        options = file\n        file = undefined\n      }\n\n      if (options && options.passThrough) {\n        while (++index < options.passThrough.length) {\n          // @ts-expect-error: hush.\n          one.handlers[options.passThrough[index]] = stitch\n        }\n      }\n\n      const result = fromParse5(\n        documentMode(tree) ? document() : fragment(),\n        file\n      )\n\n      if (stitches) {\n        visit(result, 'comment', (node, index, parent) => {\n          const stitch = /** @type {Stitch} */ (/** @type {unknown} */ (node))\n          if (stitch.value.stitch && parent !== null && index !== null) {\n            // @ts-expect-error: assume the stitch is allowed.\n            parent.children[index] = stitch.value.stitch\n            return index\n          }\n        })\n      }\n\n      // Unpack if possible and when not given a `root`.\n      if (\n        tree.type !== 'root' &&\n        result.type === 'root' &&\n        result.children.length === 1\n      ) {\n        return result.children[0]\n      }\n\n      return result\n\n      /**\n       * @returns {P5Fragment}\n       */\n      function fragment() {\n        /** @type {P5Element} */\n        const context = {\n          nodeName: 'template',\n          tagName: 'template',\n          attrs: [],\n          namespaceURI: webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Element} */\n        const mock = {\n          nodeName: 'documentmock',\n          tagName: 'documentmock',\n          attrs: [],\n          namespaceURI: webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Fragment} */\n        const doc = {nodeName: '#document-fragment', childNodes: []}\n\n        parser._bootstrap(mock, context)\n        parser._pushTmplInsertionMode(inTemplateMode)\n        parser._initTokenizerForFragmentParsing()\n        parser._insertFakeRootElement()\n        parser._resetInsertionMode()\n        parser._findFormInFragmentContext()\n\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        parser._adoptNodes(mock.childNodes[0], doc)\n\n        return doc\n      }\n\n      /**\n       * @returns {P5Document}\n       */\n      function document() {\n        /** @type {P5Document} */\n        const doc = parser.treeAdapter.createDocument()\n\n        parser._bootstrap(doc, undefined)\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        return doc\n      }\n\n      /**\n       * @param {Array<Content>} nodes\n       * @returns {void}\n       */\n      function all(nodes) {\n        let index = -1\n\n        /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n        if (nodes) {\n          while (++index < nodes.length) {\n            one(nodes[index])\n          }\n        }\n      }\n\n      /**\n       * @param {Root} node\n       * @returns {void}\n       */\n      function root(node) {\n        all(node.children)\n      }\n\n      /**\n       * @param {Element} node\n       * @returns {void}\n       */\n      function element(node) {\n        resetTokenizer()\n        parser._processInputToken(startTag(node))\n\n        all(node.children)\n\n        if (!htmlVoidElements.includes(node.tagName)) {\n          resetTokenizer()\n          parser._processInputToken(endTag(node))\n        }\n      }\n\n      /**\n       * @param {Text} node\n       * @returns {void}\n       */\n      function text(node) {\n        resetTokenizer()\n        parser._processInputToken({\n          type: characterToken,\n          chars: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Doctype} node\n       * @returns {void}\n       */\n      function doctype(node) {\n        resetTokenizer()\n        parser._processInputToken({\n          type: doctypeToken,\n          name: 'html',\n          forceQuirks: false,\n          publicId: '',\n          systemId: '',\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Comment|Stitch} node\n       * @returns {void}\n       */\n      function comment(node) {\n        resetTokenizer()\n        parser._processInputToken({\n          type: commentToken,\n          data: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Raw} node\n       * @returns {void}\n       */\n      function handleRaw(node) {\n        const start = pointStart(node)\n        const line = start.line || 1\n        const column = start.column || 1\n        const offset = start.offset || 0\n\n        /* c8 ignore next 4 */\n        if (!preprocessor) throw new Error('Expected `preprocessor`')\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n        if (!locationTracker) throw new Error('Expected `locationTracker`')\n\n        // Reset preprocessor:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js#L17>.\n        preprocessor.html = undefined\n        preprocessor.pos = -1\n        preprocessor.lastGapPos = -1\n        preprocessor.lastCharPos = -1\n        preprocessor.gapStack = []\n        preprocessor.skipNextNewLine = false\n        preprocessor.lastChunkWritten = false\n        preprocessor.endOfChunkHit = false\n\n        // Reset preprocessor mixin:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n        posTracker.isEol = false\n        posTracker.lineStartPos = -column + 1 // Looks weird, but ensures we get correct positional info.\n        posTracker.droppedBufferSize = offset\n        posTracker.offset = 0\n        posTracker.col = 1\n        posTracker.line = line\n\n        // Reset location tracker:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n        locationTracker.currentAttrLocation = undefined\n        locationTracker.ctLoc = createParse5Location(node)\n\n        // See the code for `parse` and `parseFragment`:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n        tokenizer.write(node.value)\n        parser._runParsingLoop(null)\n\n        // Character references hang, so if we ended there, we need to flush\n        // those too.\n        // We reset the preprocessor as if the document ends here.\n        // Then one single call to the relevant state does the trick, parse5\n        // consumes the whole token.\n        if (\n          tokenizer.state === 'NAMED_CHARACTER_REFERENCE_STATE' ||\n          tokenizer.state === 'NUMERIC_CHARACTER_REFERENCE_END_STATE'\n        ) {\n          preprocessor.lastChunkWritten = true\n          tokenizer[tokenizer.state](tokenizer._consume())\n        }\n      }\n\n      /**\n       * @param {Node} node\n       */\n      function stitch(node) {\n        stitches = true\n\n        /** @type {Node} */\n        let clone\n\n        // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n        // passed through node).\n        if ('children' in node) {\n          clone = {\n            ...node,\n            children: raw(\n              {type: 'root', children: node.children},\n              file,\n              options\n              // @ts-expect-error Assume a given parent yields a parent.\n            ).children\n          }\n        } else {\n          clone = {...node}\n        }\n\n        // Hack: `value` is supposed to be a string, but as none of the tools\n        // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n        // through.\n        comment({type: 'comment', value: {stitch: clone}})\n      }\n\n      function resetTokenizer() {\n        /* c8 ignore next 2 */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n\n        // Process final characters if they’re still there after hibernating.\n        // Similar to:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n        const token = tokenizer.currentCharacterToken\n\n        if (token) {\n          token.location.endLine = posTracker.line\n          token.location.endCol = posTracker.col + 1\n          token.location.endOffset = posTracker.offset + 1\n          parser._processInputToken(token)\n        }\n\n        // Reset tokenizer:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n        // Especially putting it back in the `data` state is useful: some elements,\n        // like textareas and iframes, change the state.\n        // See GH-7.\n        // But also if broken HTML is in `raw`, and then a correct element is given.\n        // See GH-11.\n        tokenizer.tokenQueue = []\n        tokenizer.state = dataState\n        tokenizer.returnState = ''\n        tokenizer.charRefCode = -1\n        tokenizer.tempBuff = []\n        tokenizer.lastStartTagName = ''\n        tokenizer.consumedAfterSnapshot = -1\n        tokenizer.active = false\n        tokenizer.currentCharacterToken = undefined\n        tokenizer.currentToken = undefined\n        tokenizer.currentAttr = undefined\n      }\n    }\n  )\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction startTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location\n  }\n}\n\n/**\n * @param {Element} node\n * @returns {Array<P5Attribute>}\n */\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: []\n    // @ts-expect-error Assume element.\n  }).attrs\n}\n\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction endTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location\n  }\n}\n\n/**\n * @param {Node} node\n */\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node')\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node\n  return Boolean(\n    head &&\n      (head.type === 'doctype' ||\n        (head.type === 'element' && head.tagName === 'html'))\n  )\n}\n\n/**\n * @param {Node|Stitch} node\n * @returns {P5Location}\n */\nfunction createParse5Location(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  }\n}\n\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value))\n}\n"]},"metadata":{},"sourceType":"module"}