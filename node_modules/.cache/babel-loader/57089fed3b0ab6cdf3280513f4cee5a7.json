{"ast":null,"code":"// @ts-nocheck\nodin.displayName = 'odin';\nodin.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nexport default function odin(Prism) {\n  ;\n\n  (function (Prism) {\n    var escapes = /\\\\(?:[\"'\\\\abefnrtv]|0[0-7]{2}|U[\\dA-Fa-f]{6}|u[\\dA-Fa-f]{4}|x[\\dA-Fa-f]{2})/;\n    Prism.languages.odin = {\n      /**\n       * The current implementation supports only 1 level of nesting.\n       *\n       * @author Michael Schmidt\n       * @author edukisto\n       */\n      comment: [{\n        pattern: /\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:\\*(?!\\/)|[^*])*(?:\\*\\/|$))*(?:\\*\\/|$)/,\n        greedy: true\n      }, {\n        pattern: /#![^\\n\\r]*/,\n        greedy: true\n      }, {\n        pattern: /\\/\\/[^\\n\\r]*/,\n        greedy: true\n      }],\n\n      /**\n       * Should be found before strings because of '\"'\"- and '`'`-like sequences.\n       */\n      char: {\n        pattern: /'(?:\\\\(?:.|[0Uux][0-9A-Fa-f]{1,6})|[^\\n\\r'\\\\])'/,\n        greedy: true,\n        inside: {\n          symbol: escapes\n        }\n      },\n      string: [{\n        pattern: /`[^`]*`/,\n        greedy: true\n      }, {\n        pattern: /\"(?:\\\\.|[^\\n\\r\"\\\\])*\"/,\n        greedy: true,\n        inside: {\n          symbol: escapes\n        }\n      }],\n      directive: {\n        pattern: /#\\w+/,\n        alias: 'property'\n      },\n      number: /\\b0(?:b[01_]+|d[\\d_]+|h_*(?:(?:(?:[\\dA-Fa-f]_*){8}){1,2}|(?:[\\dA-Fa-f]_*){4})|o[0-7_]+|x[\\dA-F_a-f]+|z[\\dAB_ab]+)\\b|(?:\\b\\d+(?:\\.(?!\\.)\\d*)?|\\B\\.\\d+)(?:[Ee][+-]?\\d*)?[ijk]?(?!\\w)/,\n      discard: {\n        pattern: /\\b_\\b/,\n        alias: 'keyword'\n      },\n      'procedure-definition': {\n        pattern: /\\b\\w+(?=[ \\t]*(?::\\s*){2}proc\\b)/,\n        alias: 'function'\n      },\n      keyword: /\\b(?:asm|auto_cast|bit_set|break|case|cast|context|continue|defer|distinct|do|dynamic|else|enum|fallthrough|for|foreign|if|import|in|map|matrix|not_in|or_else|or_return|package|proc|return|struct|switch|transmute|typeid|union|using|when|where)\\b/,\n\n      /**\n       * false, nil, true can be used as procedure names. \"_\" and keywords can't.\n       */\n      'procedure-name': {\n        pattern: /\\b\\w+(?=[ \\t]*\\()/,\n        alias: 'function'\n      },\n      boolean: /\\b(?:false|nil|true)\\b/,\n      'constant-parameter-sign': {\n        pattern: /\\$/,\n        alias: 'important'\n      },\n      undefined: {\n        pattern: /---/,\n        alias: 'operator'\n      },\n      arrow: {\n        pattern: /->/,\n        alias: 'punctuation'\n      },\n      operator: /\\+\\+|--|\\.\\.[<=]?|(?:&~|[-!*+/=~]|[%&<>|]{1,2})=?|[?^]/,\n      punctuation: /[(),.:;@\\[\\]{}]/\n    };\n  })(Prism);\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/refractor/lang/odin.js"],"names":["odin","displayName","aliases","Prism","escapes","languages","comment","pattern","greedy","char","inside","symbol","string","directive","alias","number","discard","keyword","boolean","undefined","arrow","operator","punctuation"],"mappings":"AAAA;AACAA,IAAI,CAACC,WAAL,GAAmB,MAAnB;AACAD,IAAI,CAACE,OAAL,GAAe,EAAf;AAEA;;AACA,eAAe,SAASF,IAAT,CAAcG,KAAd,EAAqB;AAClC;;AAAC,GAAC,UAAUA,KAAV,EAAiB;AACjB,QAAIC,OAAO,GACT,6EADF;AAEAD,IAAAA,KAAK,CAACE,SAAN,CAAgBL,IAAhB,GAAuB;AACrB;AACN;AACA;AACA;AACA;AACA;AACMM,MAAAA,OAAO,EAAE,CACP;AACEC,QAAAA,OAAO,EACL,6EAFJ;AAGEC,QAAAA,MAAM,EAAE;AAHV,OADO,EAMP;AACED,QAAAA,OAAO,EAAE,YADX;AAEEC,QAAAA,MAAM,EAAE;AAFV,OANO,EAUP;AACED,QAAAA,OAAO,EAAE,cADX;AAEEC,QAAAA,MAAM,EAAE;AAFV,OAVO,CAPY;;AAsBrB;AACN;AACA;AACMC,MAAAA,IAAI,EAAE;AACJF,QAAAA,OAAO,EAAE,iDADL;AAEJC,QAAAA,MAAM,EAAE,IAFJ;AAGJE,QAAAA,MAAM,EAAE;AACNC,UAAAA,MAAM,EAAEP;AADF;AAHJ,OAzBe;AAgCrBQ,MAAAA,MAAM,EAAE,CACN;AACEL,QAAAA,OAAO,EAAE,SADX;AAEEC,QAAAA,MAAM,EAAE;AAFV,OADM,EAKN;AACED,QAAAA,OAAO,EAAE,uBADX;AAEEC,QAAAA,MAAM,EAAE,IAFV;AAGEE,QAAAA,MAAM,EAAE;AACNC,UAAAA,MAAM,EAAEP;AADF;AAHV,OALM,CAhCa;AA6CrBS,MAAAA,SAAS,EAAE;AACTN,QAAAA,OAAO,EAAE,MADA;AAETO,QAAAA,KAAK,EAAE;AAFE,OA7CU;AAiDrBC,MAAAA,MAAM,EACJ,oLAlDmB;AAmDrBC,MAAAA,OAAO,EAAE;AACPT,QAAAA,OAAO,EAAE,OADF;AAEPO,QAAAA,KAAK,EAAE;AAFA,OAnDY;AAuDrB,8BAAwB;AACtBP,QAAAA,OAAO,EAAE,kCADa;AAEtBO,QAAAA,KAAK,EAAE;AAFe,OAvDH;AA2DrBG,MAAAA,OAAO,EACL,uPA5DmB;;AA6DrB;AACN;AACA;AACM,wBAAkB;AAChBV,QAAAA,OAAO,EAAE,mBADO;AAEhBO,QAAAA,KAAK,EAAE;AAFS,OAhEG;AAoErBI,MAAAA,OAAO,EAAE,wBApEY;AAqErB,iCAA2B;AACzBX,QAAAA,OAAO,EAAE,IADgB;AAEzBO,QAAAA,KAAK,EAAE;AAFkB,OArEN;AAyErBK,MAAAA,SAAS,EAAE;AACTZ,QAAAA,OAAO,EAAE,KADA;AAETO,QAAAA,KAAK,EAAE;AAFE,OAzEU;AA6ErBM,MAAAA,KAAK,EAAE;AACLb,QAAAA,OAAO,EAAE,IADJ;AAELO,QAAAA,KAAK,EAAE;AAFF,OA7Ec;AAiFrBO,MAAAA,QAAQ,EAAE,wDAjFW;AAkFrBC,MAAAA,WAAW,EAAE;AAlFQ,KAAvB;AAoFD,GAvFA,EAuFEnB,KAvFF;AAwFF","sourcesContent":["// @ts-nocheck\nodin.displayName = 'odin'\nodin.aliases = []\n\n/** @type {import('../core.js').Syntax} */\nexport default function odin(Prism) {\n  ;(function (Prism) {\n    var escapes =\n      /\\\\(?:[\"'\\\\abefnrtv]|0[0-7]{2}|U[\\dA-Fa-f]{6}|u[\\dA-Fa-f]{4}|x[\\dA-Fa-f]{2})/\n    Prism.languages.odin = {\n      /**\n       * The current implementation supports only 1 level of nesting.\n       *\n       * @author Michael Schmidt\n       * @author edukisto\n       */\n      comment: [\n        {\n          pattern:\n            /\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:\\*(?!\\/)|[^*])*(?:\\*\\/|$))*(?:\\*\\/|$)/,\n          greedy: true\n        },\n        {\n          pattern: /#![^\\n\\r]*/,\n          greedy: true\n        },\n        {\n          pattern: /\\/\\/[^\\n\\r]*/,\n          greedy: true\n        }\n      ],\n      /**\n       * Should be found before strings because of '\"'\"- and '`'`-like sequences.\n       */\n      char: {\n        pattern: /'(?:\\\\(?:.|[0Uux][0-9A-Fa-f]{1,6})|[^\\n\\r'\\\\])'/,\n        greedy: true,\n        inside: {\n          symbol: escapes\n        }\n      },\n      string: [\n        {\n          pattern: /`[^`]*`/,\n          greedy: true\n        },\n        {\n          pattern: /\"(?:\\\\.|[^\\n\\r\"\\\\])*\"/,\n          greedy: true,\n          inside: {\n            symbol: escapes\n          }\n        }\n      ],\n      directive: {\n        pattern: /#\\w+/,\n        alias: 'property'\n      },\n      number:\n        /\\b0(?:b[01_]+|d[\\d_]+|h_*(?:(?:(?:[\\dA-Fa-f]_*){8}){1,2}|(?:[\\dA-Fa-f]_*){4})|o[0-7_]+|x[\\dA-F_a-f]+|z[\\dAB_ab]+)\\b|(?:\\b\\d+(?:\\.(?!\\.)\\d*)?|\\B\\.\\d+)(?:[Ee][+-]?\\d*)?[ijk]?(?!\\w)/,\n      discard: {\n        pattern: /\\b_\\b/,\n        alias: 'keyword'\n      },\n      'procedure-definition': {\n        pattern: /\\b\\w+(?=[ \\t]*(?::\\s*){2}proc\\b)/,\n        alias: 'function'\n      },\n      keyword:\n        /\\b(?:asm|auto_cast|bit_set|break|case|cast|context|continue|defer|distinct|do|dynamic|else|enum|fallthrough|for|foreign|if|import|in|map|matrix|not_in|or_else|or_return|package|proc|return|struct|switch|transmute|typeid|union|using|when|where)\\b/,\n      /**\n       * false, nil, true can be used as procedure names. \"_\" and keywords can't.\n       */\n      'procedure-name': {\n        pattern: /\\b\\w+(?=[ \\t]*\\()/,\n        alias: 'function'\n      },\n      boolean: /\\b(?:false|nil|true)\\b/,\n      'constant-parameter-sign': {\n        pattern: /\\$/,\n        alias: 'important'\n      },\n      undefined: {\n        pattern: /---/,\n        alias: 'operator'\n      },\n      arrow: {\n        pattern: /->/,\n        alias: 'punctuation'\n      },\n      operator: /\\+\\+|--|\\.\\.[<=]?|(?:&~|[-!*+/=~]|[%&<>|]{1,2})=?|[?^]/,\n      punctuation: /[(),.:;@\\[\\]{}]/\n    }\n  })(Prism)\n}\n"]},"metadata":{},"sourceType":"module"}