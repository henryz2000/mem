{"ast":null,"code":"/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleAttr} RuleAttr\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Schema} Schema\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').PropertyValue} PropertyValue\n */\nimport { stringify as commas } from 'comma-separated-tokens';\nimport { hasProperty } from 'hast-util-has-property';\nimport { find } from 'property-information';\nimport { stringify as spaces } from 'space-separated-tokens';\nimport { zwitch } from 'zwitch';\n/** @type {(query: RuleAttr, element: Element, info: Info) => boolean} */\n\nvar handle = zwitch('operator', {\n  unknown: unknownOperator,\n  // @ts-expect-error: hush.\n  invalid: exists,\n  handlers: {\n    '=': exact,\n    '~=': spaceSeparatedList,\n    '|=': exactOrPrefix,\n    '^=': begins,\n    '$=': ends,\n    '*=': contains\n  }\n});\n/**\n * @param {Rule} query\n * @param {Element} element\n * @param {Schema} schema\n * @returns {boolean}\n */\n\nexport function attribute(query, element, schema) {\n  var attrs = query.attrs;\n  var index = -1;\n\n  while (++index < attrs.length) {\n    if (!handle(attrs[index], element, find(schema, attrs[index].name))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Check whether an attribute exists.\n *\n * `[attr]`\n *\n * @param {RuleAttr} _\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\nfunction exists(_, element, info) {\n  return hasProperty(element, info.property);\n}\n/**\n * Check whether an attribute has an exact value.\n *\n * `[attr=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction exact(query, element, info) {\n  return Boolean(hasProperty(element, info.property) && element.properties && normalizeValue(element.properties[info.property], info) === query.value);\n}\n/**\n * Check whether an attribute, interpreted as a space-separated list, contains\n * a value.\n *\n * `[attr~=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction spaceSeparatedList(query, element, info) {\n  var value = element.properties && element.properties[info.property];\n  return (// If this is a space-separated list, and the query is contained in it, return\n    // true.\n    !info.commaSeparated && value && typeof value === 'object' && query.value && value.includes(query.value) || hasProperty(element, info.property) && normalizeValue(value, info) === query.value\n  );\n}\n/**\n * Check whether an attribute has a substring as either the exact value or a\n * prefix.\n *\n * `[attr|=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction exactOrPrefix(query, element, info) {\n  var value = normalizeValue(element.properties && element.properties[info.property], info);\n  return Boolean(hasProperty(element, info.property) && query.value && (value === query.value || value.slice(0, query.value.length) === query.value && value.charAt(query.value.length) === '-'));\n}\n/**\n * Check whether an attribute has a substring as its start.\n *\n * `[attr^=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction begins(query, element, info) {\n  return Boolean(hasProperty(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).slice(0, query.value.length) === query.value);\n}\n/**\n * Check whether an attribute has a substring as its end.\n *\n * `[attr$=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction ends(query, element, info) {\n  return Boolean(hasProperty(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).slice(-query.value.length) === query.value);\n}\n/**\n * Check whether an attribute contains a substring.\n *\n * `[attr*=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\n\n\nfunction contains(query, element, info) {\n  return Boolean(hasProperty(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).includes(query.value));\n} // Shouldn’t be called, Parser throws an error instead.\n\n/**\n * @param {unknown} query\n * @returns {never}\n */\n\n/* c8 ignore next 4 */\n\n\nfunction unknownOperator(query) {\n  // @ts-expect-error: `operator` guaranteed.\n  throw new Error('Unknown operator `' + query.operator + '`');\n}\n/**\n * Stringify a hast value back to its HTML form.\n *\n * @param {PropertyValue} value\n * @param {Info} info\n * @returns {string}\n */\n\n\nfunction normalizeValue(value, info) {\n  if (typeof value === 'boolean') {\n    return info.attribute;\n  }\n\n  if (Array.isArray(value)) {\n    return (info.commaSeparated ? commas : spaces)(value);\n  }\n\n  return String(value);\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/hast-util-select/lib/attribute.js"],"names":["stringify","commas","hasProperty","find","spaces","zwitch","handle","unknown","unknownOperator","invalid","exists","handlers","exact","spaceSeparatedList","exactOrPrefix","begins","ends","contains","attribute","query","element","schema","attrs","index","length","name","_","info","property","Boolean","properties","normalizeValue","value","commaSeparated","includes","slice","charAt","Error","operator","Array","isArray","String"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,SAAS,IAAIC,MAArB,QAAkC,wBAAlC;AACA,SAAQC,WAAR,QAA0B,wBAA1B;AACA,SAAQC,IAAR,QAAmB,sBAAnB;AACA,SAAQH,SAAS,IAAII,MAArB,QAAkC,wBAAlC;AACA,SAAQC,MAAR,QAAqB,QAArB;AAEA;;AACA,IAAMC,MAAM,GAAGD,MAAM,CAAC,UAAD,EAAa;AAChCE,EAAAA,OAAO,EAAEC,eADuB;AAEhC;AACAC,EAAAA,OAAO,EAAEC,MAHuB;AAIhCC,EAAAA,QAAQ,EAAE;AACR,SAAKC,KADG;AAER,UAAMC,kBAFE;AAGR,UAAMC,aAHE;AAIR,UAAMC,MAJE;AAKR,UAAMC,IALE;AAMR,UAAMC;AANE;AAJsB,CAAb,CAArB;AAcA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,SAAT,CAAmBC,KAAnB,EAA0BC,OAA1B,EAAmCC,MAAnC,EAA2C;AAChD,MAAMC,KAAK,GAAGH,KAAK,CAACG,KAApB;AACA,MAAIC,KAAK,GAAG,CAAC,CAAb;;AAEA,SAAO,EAAEA,KAAF,GAAUD,KAAK,CAACE,MAAvB,EAA+B;AAC7B,QAAI,CAAClB,MAAM,CAACgB,KAAK,CAACC,KAAD,CAAN,EAAeH,OAAf,EAAwBjB,IAAI,CAACkB,MAAD,EAASC,KAAK,CAACC,KAAD,CAAL,CAAaE,IAAtB,CAA5B,CAAX,EAAqE;AACnE,aAAO,KAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASf,MAAT,CAAgBgB,CAAhB,EAAmBN,OAAnB,EAA4BO,IAA5B,EAAkC;AAChC,SAAOzB,WAAW,CAACkB,OAAD,EAAUO,IAAI,CAACC,QAAf,CAAlB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAShB,KAAT,CAAeO,KAAf,EAAsBC,OAAtB,EAA+BO,IAA/B,EAAqC;AACnC,SAAOE,OAAO,CACZ3B,WAAW,CAACkB,OAAD,EAAUO,IAAI,CAACC,QAAf,CAAX,IACER,OAAO,CAACU,UADV,IAEEC,cAAc,CAACX,OAAO,CAACU,UAAR,CAAmBH,IAAI,CAACC,QAAxB,CAAD,EAAoCD,IAApC,CAAd,KAA4DR,KAAK,CAACa,KAHxD,CAAd;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASnB,kBAAT,CAA4BM,KAA5B,EAAmCC,OAAnC,EAA4CO,IAA5C,EAAkD;AAChD,MAAMK,KAAK,GAAGZ,OAAO,CAACU,UAAR,IAAsBV,OAAO,CAACU,UAAR,CAAmBH,IAAI,CAACC,QAAxB,CAApC;AAEA,SACE;AACA;AACC,KAACD,IAAI,CAACM,cAAN,IACCD,KADD,IAEC,OAAOA,KAAP,KAAiB,QAFlB,IAGCb,KAAK,CAACa,KAHP,IAICA,KAAK,CAACE,QAAN,CAAef,KAAK,CAACa,KAArB,CAJF,IAOC9B,WAAW,CAACkB,OAAD,EAAUO,IAAI,CAACC,QAAf,CAAX,IACCG,cAAc,CAACC,KAAD,EAAQL,IAAR,CAAd,KAAgCR,KAAK,CAACa;AAX1C;AAaD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASlB,aAAT,CAAuBK,KAAvB,EAA8BC,OAA9B,EAAuCO,IAAvC,EAA6C;AAC3C,MAAMK,KAAK,GAAGD,cAAc,CAC1BX,OAAO,CAACU,UAAR,IAAsBV,OAAO,CAACU,UAAR,CAAmBH,IAAI,CAACC,QAAxB,CADI,EAE1BD,IAF0B,CAA5B;AAKA,SAAOE,OAAO,CACZ3B,WAAW,CAACkB,OAAD,EAAUO,IAAI,CAACC,QAAf,CAAX,IACET,KAAK,CAACa,KADR,KAEGA,KAAK,KAAKb,KAAK,CAACa,KAAhB,IACEA,KAAK,CAACG,KAAN,CAAY,CAAZ,EAAehB,KAAK,CAACa,KAAN,CAAYR,MAA3B,MAAuCL,KAAK,CAACa,KAA7C,IACCA,KAAK,CAACI,MAAN,CAAajB,KAAK,CAACa,KAAN,CAAYR,MAAzB,MAAqC,GAJ3C,CADY,CAAd;AAOD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAST,MAAT,CAAgBI,KAAhB,EAAuBC,OAAvB,EAAgCO,IAAhC,EAAsC;AACpC,SAAOE,OAAO,CACZ3B,WAAW,CAACkB,OAAD,EAAUO,IAAI,CAACC,QAAf,CAAX,IACER,OAAO,CAACU,UADV,IAEEX,KAAK,CAACa,KAFR,IAGED,cAAc,CAACX,OAAO,CAACU,UAAR,CAAmBH,IAAI,CAACC,QAAxB,CAAD,EAAoCD,IAApC,CAAd,CAAwDQ,KAAxD,CACE,CADF,EAEEhB,KAAK,CAACa,KAAN,CAAYR,MAFd,MAGML,KAAK,CAACa,KAPF,CAAd;AASD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAShB,IAAT,CAAcG,KAAd,EAAqBC,OAArB,EAA8BO,IAA9B,EAAoC;AAClC,SAAOE,OAAO,CACZ3B,WAAW,CAACkB,OAAD,EAAUO,IAAI,CAACC,QAAf,CAAX,IACER,OAAO,CAACU,UADV,IAEEX,KAAK,CAACa,KAFR,IAGED,cAAc,CAACX,OAAO,CAACU,UAAR,CAAmBH,IAAI,CAACC,QAAxB,CAAD,EAAoCD,IAApC,CAAd,CAAwDQ,KAAxD,CACE,CAAChB,KAAK,CAACa,KAAN,CAAYR,MADf,MAEML,KAAK,CAACa,KANF,CAAd;AAQD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASf,QAAT,CAAkBE,KAAlB,EAAyBC,OAAzB,EAAkCO,IAAlC,EAAwC;AACtC,SAAOE,OAAO,CACZ3B,WAAW,CAACkB,OAAD,EAAUO,IAAI,CAACC,QAAf,CAAX,IACER,OAAO,CAACU,UADV,IAEEX,KAAK,CAACa,KAFR,IAGED,cAAc,CAACX,OAAO,CAACU,UAAR,CAAmBH,IAAI,CAACC,QAAxB,CAAD,EAAoCD,IAApC,CAAd,CAAwDO,QAAxD,CACEf,KAAK,CAACa,KADR,CAJU,CAAd;AAQD,C,CAED;;AACA;AACA;AACA;AACA;;AACA;;;AACA,SAASxB,eAAT,CAAyBW,KAAzB,EAAgC;AAC9B;AACA,QAAM,IAAIkB,KAAJ,CAAU,uBAAuBlB,KAAK,CAACmB,QAA7B,GAAwC,GAAlD,CAAN;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASP,cAAT,CAAwBC,KAAxB,EAA+BL,IAA/B,EAAqC;AACnC,MAAI,OAAOK,KAAP,KAAiB,SAArB,EAAgC;AAC9B,WAAOL,IAAI,CAACT,SAAZ;AACD;;AAED,MAAIqB,KAAK,CAACC,OAAN,CAAcR,KAAd,CAAJ,EAA0B;AACxB,WAAO,CAACL,IAAI,CAACM,cAAL,GAAsBhC,MAAtB,GAA+BG,MAAhC,EAAwC4B,KAAxC,CAAP;AACD;;AAED,SAAOS,MAAM,CAACT,KAAD,CAAb;AACD","sourcesContent":["/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleAttr} RuleAttr\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Schema} Schema\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').PropertyValue} PropertyValue\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {hasProperty} from 'hast-util-has-property'\nimport {find} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {zwitch} from 'zwitch'\n\n/** @type {(query: RuleAttr, element: Element, info: Info) => boolean} */\nconst handle = zwitch('operator', {\n  unknown: unknownOperator,\n  // @ts-expect-error: hush.\n  invalid: exists,\n  handlers: {\n    '=': exact,\n    '~=': spaceSeparatedList,\n    '|=': exactOrPrefix,\n    '^=': begins,\n    '$=': ends,\n    '*=': contains\n  }\n})\n\n/**\n * @param {Rule} query\n * @param {Element} element\n * @param {Schema} schema\n * @returns {boolean}\n */\nexport function attribute(query, element, schema) {\n  const attrs = query.attrs\n  let index = -1\n\n  while (++index < attrs.length) {\n    if (!handle(attrs[index], element, find(schema, attrs[index].name))) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Check whether an attribute exists.\n *\n * `[attr]`\n *\n * @param {RuleAttr} _\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exists(_, element, info) {\n  return hasProperty(element, info.property)\n}\n\n/**\n * Check whether an attribute has an exact value.\n *\n * `[attr=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exact(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      normalizeValue(element.properties[info.property], info) === query.value\n  )\n}\n\n/**\n * Check whether an attribute, interpreted as a space-separated list, contains\n * a value.\n *\n * `[attr~=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction spaceSeparatedList(query, element, info) {\n  const value = element.properties && element.properties[info.property]\n\n  return (\n    // If this is a space-separated list, and the query is contained in it, return\n    // true.\n    (!info.commaSeparated &&\n      value &&\n      typeof value === 'object' &&\n      query.value &&\n      value.includes(query.value)) ||\n    // For all other values (including comma-separated lists), return whether this\n    // is an exact match.\n    (hasProperty(element, info.property) &&\n      normalizeValue(value, info) === query.value)\n  )\n}\n\n/**\n * Check whether an attribute has a substring as either the exact value or a\n * prefix.\n *\n * `[attr|=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exactOrPrefix(query, element, info) {\n  const value = normalizeValue(\n    element.properties && element.properties[info.property],\n    info\n  )\n\n  return Boolean(\n    hasProperty(element, info.property) &&\n      query.value &&\n      (value === query.value ||\n        (value.slice(0, query.value.length) === query.value &&\n          value.charAt(query.value.length) === '-'))\n  )\n}\n\n/**\n * Check whether an attribute has a substring as its start.\n *\n * `[attr^=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction begins(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      query.value &&\n      normalizeValue(element.properties[info.property], info).slice(\n        0,\n        query.value.length\n      ) === query.value\n  )\n}\n\n/**\n * Check whether an attribute has a substring as its end.\n *\n * `[attr$=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction ends(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      query.value &&\n      normalizeValue(element.properties[info.property], info).slice(\n        -query.value.length\n      ) === query.value\n  )\n}\n\n/**\n * Check whether an attribute contains a substring.\n *\n * `[attr*=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction contains(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      query.value &&\n      normalizeValue(element.properties[info.property], info).includes(\n        query.value\n      )\n  )\n}\n\n// Shouldn’t be called, Parser throws an error instead.\n/**\n * @param {unknown} query\n * @returns {never}\n */\n/* c8 ignore next 4 */\nfunction unknownOperator(query) {\n  // @ts-expect-error: `operator` guaranteed.\n  throw new Error('Unknown operator `' + query.operator + '`')\n}\n\n/**\n * Stringify a hast value back to its HTML form.\n *\n * @param {PropertyValue} value\n * @param {Info} info\n * @returns {string}\n */\nfunction normalizeValue(value, info) {\n  if (typeof value === 'boolean') {\n    return info.attribute\n  }\n\n  if (Array.isArray(value)) {\n    return (info.commaSeparated ? commas : spaces)(value)\n  }\n\n  return String(value)\n}\n"]},"metadata":{},"sourceType":"module"}