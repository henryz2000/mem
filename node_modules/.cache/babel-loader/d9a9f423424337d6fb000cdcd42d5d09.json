{"ast":null,"code":"import _objectSpread from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\n/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\n/**\n * @typedef {Extract<Root | Content, Parent>} Parents\n */\nimport { listItem } from 'mdast-util-to-markdown/lib/handle/list-item.js';\nimport { track } from 'mdast-util-to-markdown/lib/util/track.js'; // To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use\n// `track` from `state`.\n// To do: next major: replace exports with functions.\n// To do: next major: use `defaulthandlers.listItem`.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM task list items.\n *\n * @type {FromMarkdownExtension}\n */\n\nexport var gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n};\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM task list items.\n *\n * @type {ToMarkdownExtension}\n */\n\nexport var gfmTaskListItemToMarkdown = {\n  unsafe: [{\n    atBreak: true,\n    character: '-',\n    after: '[:|-]'\n  }],\n  handlers: {\n    listItem: listItemWithTaskListItem\n  }\n};\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\n\nfunction exitCheck(token) {\n  var node = this.stack[this.stack.length - 2]; // We’re always in a paragraph, in a list item.\n\n  node.checked = token.type === 'taskListCheckValueChecked';\n}\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\n\n\nfunction exitParagraphWithTaskListItem(token) {\n  var parent = this.stack[this.stack.length - 2];\n\n  if (parent && parent.type === 'listItem' && typeof parent.checked === 'boolean') {\n    var node = this.stack[this.stack.length - 1];\n    var head = node.children[0];\n\n    if (head && head.type === 'text') {\n      var siblings = parent.children;\n      var index = -1;\n      /** @type {Paragraph | undefined} */\n\n      var firstParaghraph;\n\n      while (++index < siblings.length) {\n        var sibling = siblings[index];\n\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling;\n          break;\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1);\n\n        if (head.value.length === 0) {\n          node.children.shift();\n        } else if (node.position && head.position && typeof head.position.start.offset === 'number') {\n          head.position.start.column++;\n          head.position.start.offset++;\n          node.position.start = Object.assign({}, head.position.start);\n        }\n      }\n    }\n  }\n\n  this.exit(token);\n}\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\n\n\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  var head = node.children[0];\n  var checkable = typeof node.checked === 'boolean' && head && head.type === 'paragraph';\n  var checkbox = '[' + (node.checked ? 'x' : ' ') + '] ';\n  var tracker = track(safeOptions);\n\n  if (checkable) {\n    tracker.move(checkbox);\n  }\n\n  var value = listItem(node, parent, context, _objectSpread(_objectSpread({}, safeOptions), tracker.current()));\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check);\n  }\n\n  return value;\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n\n  function check($0) {\n    return $0 + checkbox;\n  }\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/mdast-util-gfm-task-list-item/lib/index.js"],"names":["listItem","track","gfmTaskListItemFromMarkdown","exit","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","exitParagraphWithTaskListItem","gfmTaskListItemToMarkdown","unsafe","atBreak","character","after","handlers","listItemWithTaskListItem","token","node","stack","length","checked","type","parent","head","children","siblings","index","firstParaghraph","sibling","value","slice","shift","position","start","offset","column","Object","assign","context","safeOptions","checkable","checkbox","tracker","move","current","replace","check","$0"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\n/**\n * @typedef {Extract<Root | Content, Parent>} Parents\n */\n\nimport {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use\n// `track` from `state`.\n// To do: next major: replace exports with functions.\n// To do: next major: use `defaulthandlers.listItem`.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM task list items.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM task list items.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmTaskListItemToMarkdown = {\n  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n  handlers: {listItem: listItemWithTaskListItem}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])\n  // We’re always in a paragraph, in a list item.\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2])\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = track(safeOptions)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = listItem(node, parent, context, {\n    ...safeOptions,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n"]},"metadata":{},"sourceType":"module"}