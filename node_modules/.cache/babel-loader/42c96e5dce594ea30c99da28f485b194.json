{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Token.Location} P5Location\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in.\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {VFile | null | undefined} [file]\n *   File used to add positional info to nodes.\n *\n *   If given, the file should represent the original HTML source.\n * @property {boolean} [verbose=false]\n *   Whether to add extra positional info about starting tags, closing tags,\n *   and attributes to elements.\n *\n *   > ðŸ‘‰ **Note**: only used when `file` is given.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {Schema} schema\n *   Current schema.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n * @property {boolean} location\n *   Whether location info was found.\n */\nimport { h, s } from 'hastscript';\nimport { html, svg, find } from 'property-information';\nimport { location } from 'vfile-location';\nimport { webNamespaces } from 'web-namespaces';\nvar own = {}.hasOwnProperty;\n/** @type {unknown} */\n// type-coverage:ignore-next-line\n\nvar proto = Object.prototype;\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {P5Node} tree\n *   `parse5` tree to transform.\n * @param {Options | VFile | null | undefined} [options]\n *   Configuration.\n * @returns {Node}\n *   hast tree.\n */\n\nexport function fromParse5(tree, options) {\n  var options_ = options || {};\n  /** @type {Options} */\n\n  var settings;\n  /** @type {VFile | undefined} */\n\n  var file;\n\n  if (isFile(options_)) {\n    file = options_;\n    settings = {};\n  } else {\n    file = options_.file || undefined;\n    settings = options_;\n  }\n\n  return one({\n    schema: settings.space === 'svg' ? svg : html,\n    file: file,\n    verbose: settings.verbose,\n    location: false\n  }, tree);\n}\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} node\n *   p5 node.\n * @returns {Node}\n *   hast node.\n */\n\nfunction one(state, node) {\n  /** @type {Node} */\n  var result;\n\n  switch (node.nodeName) {\n    case '#comment':\n      {\n        var reference = node;\n        result = {\n          type: 'comment',\n          value: reference.data\n        };\n        patch(state, reference, result);\n        return result;\n      }\n\n    case '#document':\n    case '#document-fragment':\n      {\n        var _reference = node;\n        var quirksMode = 'mode' in _reference ? _reference.mode === 'quirks' || _reference.mode === 'limited-quirks' : false;\n        result = {\n          type: 'root',\n          children: all(state, node.childNodes),\n          data: {\n            quirksMode: quirksMode\n          }\n        };\n\n        if (state.file && state.location) {\n          var doc = String(state.file);\n          var loc = location(doc);\n          var start = loc.toPoint(0);\n          var end = loc.toPoint(doc.length); // @ts-expect-error: always defined as we give valid input.\n\n          result.position = {\n            start: start,\n            end: end\n          };\n        }\n\n        return result;\n      }\n\n    case '#documentType':\n      {\n        var _reference2 = node; // @ts-expect-error Types are out of date.\n\n        result = {\n          type: 'doctype'\n        };\n        patch(state, _reference2, result);\n        return result;\n      }\n\n    case '#text':\n      {\n        var _reference3 = node;\n        result = {\n          type: 'text',\n          value: _reference3.value\n        };\n        patch(state, _reference3, result);\n        return result;\n      }\n    // Element.\n\n    default:\n      {\n        var _reference4 = node;\n        result = element(state, _reference4);\n        return result;\n      }\n  }\n}\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<P5Node>} nodes\n *   Nodes.\n * @returns {Array<Content>}\n *   hast nodes.\n */\n\n\nfunction all(state, nodes) {\n  var index = -1;\n  /** @type {Array<Content>} */\n\n  var result = [];\n\n  while (++index < nodes.length) {\n    // @ts-expect-error Assume no roots in `nodes`.\n    result[index] = one(state, nodes[index]);\n  }\n\n  return result;\n}\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Element} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\n\n\nfunction element(state, node) {\n  var schema = state.schema;\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html; // Props.\n\n  var index = -1;\n  /** @type {Record<string, string>} */\n\n  var props = {};\n\n  while (++index < node.attrs.length) {\n    var attribute = node.attrs[index];\n    var name = (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name;\n\n    if (!own.call(proto, name)) {\n      props[name] = attribute.value;\n    }\n  } // Build.\n\n\n  var fn = state.schema.space === 'svg' ? s : h;\n  var result = fn(node.tagName, props, all(state, node.childNodes));\n  patch(state, node, result); // Switch content.\n\n  if (result.tagName === 'template') {\n    var reference = node;\n    var pos = reference.sourceCodeLocation;\n    var startTag = pos && pos.startTag && position(pos.startTag);\n    var endTag = pos && pos.endTag && position(pos.endTag);\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n\n    var content = one(state, reference.content);\n\n    if (startTag && endTag && state.file) {\n      content.position = {\n        start: startTag.end,\n        end: endTag.start\n      };\n    }\n\n    result.content = content;\n  }\n\n  state.schema = schema;\n  return result;\n}\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} from\n *   p5 node.\n * @param {Node} to\n *   hast node.\n * @returns {void}\n *   Nothing.\n */\n\n\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    var _position = createLocation(state, to, from.sourceCodeLocation);\n\n    if (_position) {\n      state.location = true;\n      to.position = _position;\n    }\n  }\n}\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Node} node\n *   hast node.\n * @param {P5ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\n\n\nfunction createLocation(state, node, location) {\n  var result = position(location);\n\n  if (node.type === 'element') {\n    var tail = node.children[node.children.length - 1]; // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n\n    if (result && !location.endTag && tail && tail.position && tail.position.end) {\n      result.end = Object.assign({}, tail.position.end);\n    }\n\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      var props = {};\n      /** @type {string} */\n\n      var key;\n\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            props[find(state.schema, key).property] = position(location.attrs[key]);\n          }\n        }\n      }\n\n      node.data = {\n        position: {\n          // @ts-expect-error: assume not `undefined`.\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      };\n    }\n  }\n\n  return result;\n}\n/**\n * Turn a p5 location into a position.\n *\n * @param {P5Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\n\n\nfunction position(loc) {\n  var start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  });\n  var end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  }); // @ts-expect-error `undefined` is fine.\n\n  return start || end ? {\n    start: start,\n    end: end\n  } : undefined;\n}\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\n\n\nfunction point(point) {\n  return point.line && point.column ? point : undefined;\n}\n/**\n * Check if something is a file.\n *\n * @param {VFile | Options} value\n *   File or options.\n * @returns {value is VFile}\n *   Whether `value` is a file.\n */\n\n\nfunction isFile(value) {\n  return 'messages' in value;\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/hast-util-from-parse5/lib/index.js"],"names":["h","s","html","svg","find","location","webNamespaces","own","hasOwnProperty","proto","Object","prototype","fromParse5","tree","options","options_","settings","file","isFile","undefined","one","schema","space","verbose","state","node","result","nodeName","reference","type","value","data","patch","quirksMode","mode","children","all","childNodes","doc","String","loc","start","toPoint","end","length","position","element","nodes","index","namespaceURI","props","attrs","attribute","name","prefix","call","fn","tagName","pos","sourceCodeLocation","startTag","endTag","content","from","to","createLocation","tail","assign","key","property","opening","closing","properties","point","line","startLine","column","startCol","offset","startOffset","endLine","endCol","endOffset"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Token.Location} P5Location\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in.\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {VFile | null | undefined} [file]\n *   File used to add positional info to nodes.\n *\n *   If given, the file should represent the original HTML source.\n * @property {boolean} [verbose=false]\n *   Whether to add extra positional info about starting tags, closing tags,\n *   and attributes to elements.\n *\n *   > ðŸ‘‰ **Note**: only used when `file` is given.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {Schema} schema\n *   Current schema.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n * @property {boolean} location\n *   Whether location info was found.\n */\n\nimport {h, s} from 'hastscript'\nimport {html, svg, find} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nconst proto = Object.prototype\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {P5Node} tree\n *   `parse5` tree to transform.\n * @param {Options | VFile | null | undefined} [options]\n *   Configuration.\n * @returns {Node}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  const options_ = options || {}\n  /** @type {Options} */\n  let settings\n  /** @type {VFile | undefined} */\n  let file\n\n  if (isFile(options_)) {\n    file = options_\n    settings = {}\n  } else {\n    file = options_.file || undefined\n    settings = options_\n  }\n\n  return one(\n    {\n      schema: settings.space === 'svg' ? svg : html,\n      file,\n      verbose: settings.verbose,\n      location: false\n    },\n    tree\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} node\n *   p5 node.\n * @returns {Node}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Node} */\n  let result\n\n  switch (node.nodeName) {\n    case '#comment': {\n      const reference = /** @type {P5Comment} */ (node)\n      result = {type: 'comment', value: reference.data}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#document':\n    case '#document-fragment': {\n      const reference = /** @type {P5Document | P5DocumentFragment} */ (node)\n      const quirksMode =\n        'mode' in reference\n          ? reference.mode === 'quirks' || reference.mode === 'limited-quirks'\n          : false\n\n      result = {\n        type: 'root',\n        children: all(state, node.childNodes),\n        data: {quirksMode}\n      }\n\n      if (state.file && state.location) {\n        const doc = String(state.file)\n        const loc = location(doc)\n        const start = loc.toPoint(0)\n        const end = loc.toPoint(doc.length)\n        // @ts-expect-error: always defined as we give valid input.\n        result.position = {start, end}\n      }\n\n      return result\n    }\n\n    case '#documentType': {\n      const reference = /** @type {P5DocumentType} */ (node)\n      // @ts-expect-error Types are out of date.\n      result = {type: 'doctype'}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#text': {\n      const reference = /** @type {P5Text} */ (node)\n      result = {type: 'text', value: reference.value}\n      patch(state, reference, result)\n      return result\n    }\n\n    // Element.\n    default: {\n      const reference = /** @type {P5Element} */ (node)\n      result = element(state, reference)\n      return result\n    }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<P5Node>} nodes\n *   Nodes.\n * @returns {Array<Content>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  let index = -1\n  /** @type {Array<Content>} */\n  const result = []\n\n  while (++index < nodes.length) {\n    // @ts-expect-error Assume no roots in `nodes`.\n    result[index] = one(state, nodes[index])\n  }\n\n  return result\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Element} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  const schema = state.schema\n\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html\n\n  // Props.\n  let index = -1\n  /** @type {Record<string, string>} */\n  const props = {}\n\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index]\n    const name =\n      (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name\n    if (!own.call(proto, name)) {\n      props[name] = attribute.value\n    }\n  }\n\n  // Build.\n  const fn = state.schema.space === 'svg' ? s : h\n  const result = fn(node.tagName, props, all(state, node.childNodes))\n  patch(state, node, result)\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    const reference = /** @type {P5Template} */ (node)\n    const pos = reference.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n    const content = one(state, reference.content)\n\n    if (startTag && endTag && state.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  state.schema = schema\n\n  return result\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} from\n *   p5 node.\n * @param {Node} to\n *   hast node.\n * @returns {void}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation)\n\n    if (position) {\n      state.location = true\n      to.position = position\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Node} node\n *   hast node.\n * @param {P5ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const props = {}\n      /** @type {string} */\n      let key\n\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            props[find(state.schema, key).property] = position(\n              location.attrs[key]\n            )\n          }\n        }\n      }\n\n      node.data = {\n        position: {\n          // @ts-expect-error: assume not `undefined`.\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {P5Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n  // @ts-expect-error `undefined` is fine.\n  return start || end ? {start, end} : undefined\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined\n}\n\n/**\n * Check if something is a file.\n *\n * @param {VFile | Options} value\n *   File or options.\n * @returns {value is VFile}\n *   Whether `value` is a file.\n */\nfunction isFile(value) {\n  return 'messages' in value\n}\n"]},"metadata":{},"sourceType":"module"}