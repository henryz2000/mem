{"ast":null,"code":"/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\nimport { checkBullet } from '../util/check-bullet.js';\nimport { checkListItemIndent } from '../util/check-list-item-indent.js';\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\n\nexport function listItem(node, parent, state, info) {\n  var listItemIndent = checkListItemIndent(state);\n  var bullet = state.bulletCurrent || checkBullet(state); // Add the marker value for ordered lists.\n\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet = (typeof parent.start === 'number' && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node)) + bullet;\n  }\n\n  var size = bullet.length + 1;\n\n  if (listItemIndent === 'tab' || listItemIndent === 'mixed' && (parent && parent.type === 'list' && parent.spread || node.spread)) {\n    size = Math.ceil(size / 4) * 4;\n  }\n\n  var tracker = state.createTracker(info);\n  tracker.move(bullet + ' '.repeat(size - bullet.length));\n  tracker.shift(size);\n  var exit = state.enter('listItem');\n  var value = state.indentLines(state.containerFlow(node, tracker.current()), map);\n  exit();\n  return value;\n  /** @type {Map} */\n\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line;\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line;\n  }\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/mdast-util-to-markdown/lib/handle/list-item.js"],"names":["checkBullet","checkListItemIndent","listItem","node","parent","state","info","listItemIndent","bullet","bulletCurrent","type","ordered","start","options","incrementListMarker","children","indexOf","size","length","spread","Math","ceil","tracker","createTracker","move","repeat","shift","exit","enter","value","indentLines","containerFlow","current","map","line","index","blank"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,WAAR,QAA0B,yBAA1B;AACA,SAAQC,mBAAR,QAAkC,mCAAlC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBC,IAAlB,EAAwBC,MAAxB,EAAgCC,KAAhC,EAAuCC,IAAvC,EAA6C;AAClD,MAAMC,cAAc,GAAGN,mBAAmB,CAACI,KAAD,CAA1C;AACA,MAAIG,MAAM,GAAGH,KAAK,CAACI,aAAN,IAAuBT,WAAW,CAACK,KAAD,CAA/C,CAFkD,CAIlD;;AACA,MAAID,MAAM,IAAIA,MAAM,CAACM,IAAP,KAAgB,MAA1B,IAAoCN,MAAM,CAACO,OAA/C,EAAwD;AACtDH,IAAAA,MAAM,GACJ,CAAC,OAAOJ,MAAM,CAACQ,KAAd,KAAwB,QAAxB,IAAoCR,MAAM,CAACQ,KAAP,GAAe,CAAC,CAApD,GACGR,MAAM,CAACQ,KADV,GAEG,CAFJ,KAGCP,KAAK,CAACQ,OAAN,CAAcC,mBAAd,KAAsC,KAAtC,GACG,CADH,GAEGV,MAAM,CAACW,QAAP,CAAgBC,OAAhB,CAAwBb,IAAxB,CALJ,IAMAK,MAPF;AAQD;;AAED,MAAIS,IAAI,GAAGT,MAAM,CAACU,MAAP,GAAgB,CAA3B;;AAEA,MACEX,cAAc,KAAK,KAAnB,IACCA,cAAc,KAAK,OAAnB,KACGH,MAAM,IAAIA,MAAM,CAACM,IAAP,KAAgB,MAA1B,IAAoCN,MAAM,CAACe,MAA5C,IAAuDhB,IAAI,CAACgB,MAD9D,CAFH,EAIE;AACAF,IAAAA,IAAI,GAAGG,IAAI,CAACC,IAAL,CAAUJ,IAAI,GAAG,CAAjB,IAAsB,CAA7B;AACD;;AAED,MAAMK,OAAO,GAAGjB,KAAK,CAACkB,aAAN,CAAoBjB,IAApB,CAAhB;AACAgB,EAAAA,OAAO,CAACE,IAAR,CAAahB,MAAM,GAAG,IAAIiB,MAAJ,CAAWR,IAAI,GAAGT,MAAM,CAACU,MAAzB,CAAtB;AACAI,EAAAA,OAAO,CAACI,KAAR,CAAcT,IAAd;AACA,MAAMU,IAAI,GAAGtB,KAAK,CAACuB,KAAN,CAAY,UAAZ,CAAb;AACA,MAAMC,KAAK,GAAGxB,KAAK,CAACyB,WAAN,CACZzB,KAAK,CAAC0B,aAAN,CAAoB5B,IAApB,EAA0BmB,OAAO,CAACU,OAAR,EAA1B,CADY,EAEZC,GAFY,CAAd;AAIAN,EAAAA,IAAI;AAEJ,SAAOE,KAAP;AAEA;;AACA,WAASI,GAAT,CAAaC,IAAb,EAAmBC,KAAnB,EAA0BC,KAA1B,EAAiC;AAC/B,QAAID,KAAJ,EAAW;AACT,aAAO,CAACC,KAAK,GAAG,EAAH,GAAQ,IAAIX,MAAJ,CAAWR,IAAX,CAAd,IAAkCiB,IAAzC;AACD;;AAED,WAAO,CAACE,KAAK,GAAG5B,MAAH,GAAYA,MAAM,GAAG,IAAIiB,MAAJ,CAAWR,IAAI,GAAGT,MAAM,CAACU,MAAzB,CAA3B,IAA+DgB,IAAtE;AACD;AACF","sourcesContent":["/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n"]},"metadata":{},"sourceType":"module"}