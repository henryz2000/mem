{"ast":null,"code":"// @ts-nocheck\ncue.displayName = 'cue';\ncue.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nexport default function cue(Prism) {\n  ;\n\n  (function (Prism) {\n    // https://cuelang.org/docs/references/spec/\n    // eslint-disable-next-line regexp/strict\n    var stringEscape = /\\\\(?:(?!\\2)|\\2(?:[^()\\r\\n]|\\([^()]*\\)))/.source; // eslint-disable-next-line regexp/strict\n\n    var stringTypes = /\"\"\"(?:[^\\\\\"]|\"(?!\"\"\\2)|<esc>)*\"\"\"/.source + // eslint-disable-next-line regexp/strict\n    '|' + /'''(?:[^\\\\']|'(?!''\\2)|<esc>)*'''/.source + // eslint-disable-next-line regexp/strict\n    '|' + /\"(?:[^\\\\\\r\\n\"]|\"(?!\\2)|<esc>)*\"/.source + // eslint-disable-next-line regexp/strict\n    '|' + /'(?:[^\\\\\\r\\n']|'(?!\\2)|<esc>)*'/.source;\n    var stringLiteral = '(?:' + stringTypes.replace(/<esc>/g, stringEscape) + ')';\n    Prism.languages.cue = {\n      comment: {\n        pattern: /\\/\\/.*/,\n        greedy: true\n      },\n      'string-literal': {\n        // eslint-disable-next-line regexp/strict\n        pattern: RegExp(/(^|[^#\"'\\\\])(#*)/.source + stringLiteral + /(?![\"'])\\2/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          // I'm using dirty hack here. We have to know the number hashes at the start of the string somehow,\n          // but we can't look back. So instead, we will use a lookahead, go to the end of the string, and\n          // capture the hashes at the end of the string.\n          escape: {\n            pattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1(?:U[a-fA-F0-9]{1,8}|u[a-fA-F0-9]{1,4}|x[a-fA-F0-9]{1,2}|\\d{2,3}|[^(])/,\n            greedy: true,\n            alias: 'string'\n          },\n          interpolation: {\n            pattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1\\([^()]*\\)/,\n            greedy: true,\n            inside: {\n              punctuation: /^\\\\#*\\(|\\)$/,\n              expression: {\n                pattern: /[\\s\\S]+/,\n                inside: null\n              }\n            }\n          },\n          string: /[\\s\\S]+/\n        }\n      },\n      keyword: {\n        pattern: /(^|[^\\w$])(?:for|if|import|in|let|null|package)(?![\\w$])/,\n        lookbehind: true\n      },\n      boolean: {\n        pattern: /(^|[^\\w$])(?:false|true)(?![\\w$])/,\n        lookbehind: true\n      },\n      builtin: {\n        pattern: /(^|[^\\w$])(?:bool|bytes|float|float(?:32|64)|u?int(?:8|16|32|64|128)?|number|rune|string)(?![\\w$])/,\n        lookbehind: true\n      },\n      attribute: {\n        pattern: /@[\\w$]+(?=\\s*\\()/,\n        alias: 'function'\n      },\n      function: {\n        pattern: /(^|[^\\w$])[a-z_$][\\w$]*(?=\\s*\\()/i,\n        lookbehind: true\n      },\n      number: {\n        pattern: /(^|[^\\w$.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][0-9A-Fa-f]+(?:_[0-9A-Fa-f]+)*|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[eE][+-]?\\d+(?:_\\d+)*)?(?:[KMGTP]i?)?)(?![\\w$])/,\n        lookbehind: true\n      },\n      operator: /\\.{3}|_\\|_|&&?|\\|\\|?|[=!]~|[<>=!]=?|[+\\-*/?]/,\n      punctuation: /[()[\\]{},.:]/\n    };\n    Prism.languages.cue['string-literal'].inside.interpolation.inside.expression.inside = Prism.languages.cue;\n  })(Prism);\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/refractor/lang/cue.js"],"names":["cue","displayName","aliases","Prism","stringEscape","source","stringTypes","stringLiteral","replace","languages","comment","pattern","greedy","RegExp","lookbehind","inside","escape","alias","interpolation","punctuation","expression","string","keyword","boolean","builtin","attribute","function","number","operator"],"mappings":"AAAA;AACAA,GAAG,CAACC,WAAJ,GAAkB,KAAlB;AACAD,GAAG,CAACE,OAAJ,GAAc,EAAd;AAEA;;AACA,eAAe,SAASF,GAAT,CAAaG,KAAb,EAAoB;AACjC;;AAAC,GAAC,UAAUA,KAAV,EAAiB;AACjB;AAEA;AACA,QAAIC,YAAY,GAAG,0CAA0CC,MAA7D,CAJiB,CAKjB;;AACA,QAAIC,WAAW,GACb,oCAAoCD,MAApC,GACA;AACA,OAFA,GAGA,oCAAoCA,MAHpC,GAIA;AACA,OALA,GAMA,kCAAkCA,MANlC,GAOA;AACA,OARA,GASA,kCAAkCA,MAVpC;AAWA,QAAIE,aAAa,GACf,QAAQD,WAAW,CAACE,OAAZ,CAAoB,QAApB,EAA8BJ,YAA9B,CAAR,GAAsD,GADxD;AAEAD,IAAAA,KAAK,CAACM,SAAN,CAAgBT,GAAhB,GAAsB;AACpBU,MAAAA,OAAO,EAAE;AACPC,QAAAA,OAAO,EAAE,QADF;AAEPC,QAAAA,MAAM,EAAE;AAFD,OADW;AAKpB,wBAAkB;AAChB;AACAD,QAAAA,OAAO,EAAEE,MAAM,CACb,mBAAmBR,MAAnB,GAA4BE,aAA5B,GAA4C,aAAaF,MAD5C,CAFC;AAKhBS,QAAAA,UAAU,EAAE,IALI;AAMhBF,QAAAA,MAAM,EAAE,IANQ;AAOhBG,QAAAA,MAAM,EAAE;AACN;AACA;AACA;AACAC,UAAAA,MAAM,EAAE;AACNL,YAAAA,OAAO,EACL,gGAFI;AAGNC,YAAAA,MAAM,EAAE,IAHF;AAINK,YAAAA,KAAK,EAAE;AAJD,WAJF;AAUNC,UAAAA,aAAa,EAAE;AACbP,YAAAA,OAAO,EAAE,oCADI;AAEbC,YAAAA,MAAM,EAAE,IAFK;AAGbG,YAAAA,MAAM,EAAE;AACNI,cAAAA,WAAW,EAAE,aADP;AAENC,cAAAA,UAAU,EAAE;AACVT,gBAAAA,OAAO,EAAE,SADC;AAEVI,gBAAAA,MAAM,EAAE;AAFE;AAFN;AAHK,WAVT;AAqBNM,UAAAA,MAAM,EAAE;AArBF;AAPQ,OALE;AAoCpBC,MAAAA,OAAO,EAAE;AACPX,QAAAA,OAAO,EAAE,0DADF;AAEPG,QAAAA,UAAU,EAAE;AAFL,OApCW;AAwCpBS,MAAAA,OAAO,EAAE;AACPZ,QAAAA,OAAO,EAAE,mCADF;AAEPG,QAAAA,UAAU,EAAE;AAFL,OAxCW;AA4CpBU,MAAAA,OAAO,EAAE;AACPb,QAAAA,OAAO,EACL,oGAFK;AAGPG,QAAAA,UAAU,EAAE;AAHL,OA5CW;AAiDpBW,MAAAA,SAAS,EAAE;AACTd,QAAAA,OAAO,EAAE,kBADA;AAETM,QAAAA,KAAK,EAAE;AAFE,OAjDS;AAqDpBS,MAAAA,QAAQ,EAAE;AACRf,QAAAA,OAAO,EAAE,mCADD;AAERG,QAAAA,UAAU,EAAE;AAFJ,OArDU;AAyDpBa,MAAAA,MAAM,EAAE;AACNhB,QAAAA,OAAO,EACL,qMAFI;AAGNG,QAAAA,UAAU,EAAE;AAHN,OAzDY;AA8DpBc,MAAAA,QAAQ,EAAE,8CA9DU;AA+DpBT,MAAAA,WAAW,EAAE;AA/DO,KAAtB;AAiEAhB,IAAAA,KAAK,CAACM,SAAN,CAAgBT,GAAhB,CACE,gBADF,EAEEe,MAFF,CAESG,aAFT,CAEuBH,MAFvB,CAE8BK,UAF9B,CAEyCL,MAFzC,GAEkDZ,KAAK,CAACM,SAAN,CAAgBT,GAFlE;AAGD,GAvFA,EAuFEG,KAvFF;AAwFF","sourcesContent":["// @ts-nocheck\ncue.displayName = 'cue'\ncue.aliases = []\n\n/** @type {import('../core.js').Syntax} */\nexport default function cue(Prism) {\n  ;(function (Prism) {\n    // https://cuelang.org/docs/references/spec/\n\n    // eslint-disable-next-line regexp/strict\n    var stringEscape = /\\\\(?:(?!\\2)|\\2(?:[^()\\r\\n]|\\([^()]*\\)))/.source\n    // eslint-disable-next-line regexp/strict\n    var stringTypes =\n      /\"\"\"(?:[^\\\\\"]|\"(?!\"\"\\2)|<esc>)*\"\"\"/.source +\n      // eslint-disable-next-line regexp/strict\n      '|' +\n      /'''(?:[^\\\\']|'(?!''\\2)|<esc>)*'''/.source +\n      // eslint-disable-next-line regexp/strict\n      '|' +\n      /\"(?:[^\\\\\\r\\n\"]|\"(?!\\2)|<esc>)*\"/.source +\n      // eslint-disable-next-line regexp/strict\n      '|' +\n      /'(?:[^\\\\\\r\\n']|'(?!\\2)|<esc>)*'/.source\n    var stringLiteral =\n      '(?:' + stringTypes.replace(/<esc>/g, stringEscape) + ')'\n    Prism.languages.cue = {\n      comment: {\n        pattern: /\\/\\/.*/,\n        greedy: true\n      },\n      'string-literal': {\n        // eslint-disable-next-line regexp/strict\n        pattern: RegExp(\n          /(^|[^#\"'\\\\])(#*)/.source + stringLiteral + /(?![\"'])\\2/.source\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          // I'm using dirty hack here. We have to know the number hashes at the start of the string somehow,\n          // but we can't look back. So instead, we will use a lookahead, go to the end of the string, and\n          // capture the hashes at the end of the string.\n          escape: {\n            pattern:\n              /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1(?:U[a-fA-F0-9]{1,8}|u[a-fA-F0-9]{1,4}|x[a-fA-F0-9]{1,2}|\\d{2,3}|[^(])/,\n            greedy: true,\n            alias: 'string'\n          },\n          interpolation: {\n            pattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1\\([^()]*\\)/,\n            greedy: true,\n            inside: {\n              punctuation: /^\\\\#*\\(|\\)$/,\n              expression: {\n                pattern: /[\\s\\S]+/,\n                inside: null\n              }\n            }\n          },\n          string: /[\\s\\S]+/\n        }\n      },\n      keyword: {\n        pattern: /(^|[^\\w$])(?:for|if|import|in|let|null|package)(?![\\w$])/,\n        lookbehind: true\n      },\n      boolean: {\n        pattern: /(^|[^\\w$])(?:false|true)(?![\\w$])/,\n        lookbehind: true\n      },\n      builtin: {\n        pattern:\n          /(^|[^\\w$])(?:bool|bytes|float|float(?:32|64)|u?int(?:8|16|32|64|128)?|number|rune|string)(?![\\w$])/,\n        lookbehind: true\n      },\n      attribute: {\n        pattern: /@[\\w$]+(?=\\s*\\()/,\n        alias: 'function'\n      },\n      function: {\n        pattern: /(^|[^\\w$])[a-z_$][\\w$]*(?=\\s*\\()/i,\n        lookbehind: true\n      },\n      number: {\n        pattern:\n          /(^|[^\\w$.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][0-9A-Fa-f]+(?:_[0-9A-Fa-f]+)*|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[eE][+-]?\\d+(?:_\\d+)*)?(?:[KMGTP]i?)?)(?![\\w$])/,\n        lookbehind: true\n      },\n      operator: /\\.{3}|_\\|_|&&?|\\|\\|?|[=!]~|[<>=!]=?|[+\\-*/?]/,\n      punctuation: /[()[\\]{},.:]/\n    }\n    Prism.languages.cue[\n      'string-literal'\n    ].inside.interpolation.inside.expression.inside = Prism.languages.cue\n  })(Prism)\n}\n"]},"metadata":{},"sourceType":"module"}