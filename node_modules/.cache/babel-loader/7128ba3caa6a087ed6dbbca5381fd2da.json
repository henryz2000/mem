{"ast":null,"code":"/**\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Content} Content\n */\nimport { whitespace } from 'hast-util-whitespace';\nimport { siblingBefore, siblingAfter } from './util/siblings.js';\nimport { closing } from './closing.js';\nimport { omission } from './omission.js';\nexport var opening = omission({\n  html: html,\n  head: head,\n  body: body,\n  colgroup: colgroup,\n  tbody: tbody\n});\n/**\n * Whether to omit `<html>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\n\nfunction html(node) {\n  var head = siblingAfter(node, -1);\n  return !head || head.type !== 'comment';\n}\n/**\n * Whether to omit `<head>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\n\n\nfunction head(node) {\n  var children = node.children;\n  /** @type {Array<string>} */\n\n  var seen = [];\n  var index = -1;\n\n  while (++index < children.length) {\n    var child = children[index];\n\n    if (child.type === 'element' && (child.tagName === 'title' || child.tagName === 'base')) {\n      if (seen.includes(child.tagName)) return false;\n      seen.push(child.tagName);\n    }\n  }\n\n  return children.length > 0;\n}\n/**\n * Whether to omit `<body>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\n\n\nfunction body(node) {\n  var head = siblingAfter(node, -1, true);\n  return !head || head.type !== 'comment' && !(head.type === 'text' && whitespace(head.value.charAt(0))) && !(head.type === 'element' && (head.tagName === 'meta' || head.tagName === 'link' || head.tagName === 'script' || head.tagName === 'style' || head.tagName === 'template'));\n}\n/**\n * Whether to omit `<colgroup>`.\n * The spec describes some logic for the opening tag, but it’s easier to\n * implement in the closing tag, to the same effect, so we handle it there\n * instead.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\n\n\nfunction colgroup(node, index, parent) {\n  var previous = siblingBefore(parent, index);\n  var head = siblingAfter(node, -1, true); // Previous colgroup was already omitted.\n\n  if (parent && previous && previous.type === 'element' && previous.tagName === 'colgroup' && closing(previous, parent.children.indexOf(previous), parent)) {\n    return false;\n  }\n\n  return head && head.type === 'element' && head.tagName === 'col';\n}\n/**\n * Whether to omit `<tbody>`.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\n\n\nfunction tbody(node, index, parent) {\n  var previous = siblingBefore(parent, index);\n  var head = siblingAfter(node, -1); // Previous table section was already omitted.\n\n  if (parent && previous && previous.type === 'element' && (previous.tagName === 'thead' || previous.tagName === 'tbody') && closing(previous, parent.children.indexOf(previous), parent)) {\n    return false;\n  }\n\n  return head && head.type === 'element' && head.tagName === 'tr';\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/hast-util-to-html/lib/omission/opening.js"],"names":["whitespace","siblingBefore","siblingAfter","closing","omission","opening","html","head","body","colgroup","tbody","node","type","children","seen","index","length","child","tagName","includes","push","value","charAt","parent","previous","indexOf"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Content} Content\n */\n\nimport {whitespace} from 'hast-util-whitespace'\nimport {siblingBefore, siblingAfter} from './util/siblings.js'\nimport {closing} from './closing.js'\nimport {omission} from './omission.js'\n\nexport const opening = omission({\n  html,\n  head,\n  body,\n  colgroup,\n  tbody\n})\n\n/**\n * Whether to omit `<html>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction html(node) {\n  const head = siblingAfter(node, -1)\n  return !head || head.type !== 'comment'\n}\n\n/**\n * Whether to omit `<head>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction head(node) {\n  const children = node.children\n  /** @type {Array<string>} */\n  const seen = []\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    if (\n      child.type === 'element' &&\n      (child.tagName === 'title' || child.tagName === 'base')\n    ) {\n      if (seen.includes(child.tagName)) return false\n      seen.push(child.tagName)\n    }\n  }\n\n  return children.length > 0\n}\n\n/**\n * Whether to omit `<body>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction body(node) {\n  const head = siblingAfter(node, -1, true)\n\n  return (\n    !head ||\n    (head.type !== 'comment' &&\n      !(head.type === 'text' && whitespace(head.value.charAt(0))) &&\n      !(\n        head.type === 'element' &&\n        (head.tagName === 'meta' ||\n          head.tagName === 'link' ||\n          head.tagName === 'script' ||\n          head.tagName === 'style' ||\n          head.tagName === 'template')\n      ))\n  )\n}\n\n/**\n * Whether to omit `<colgroup>`.\n * The spec describes some logic for the opening tag, but it’s easier to\n * implement in the closing tag, to the same effect, so we handle it there\n * instead.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction colgroup(node, index, parent) {\n  const previous = siblingBefore(parent, index)\n  const head = siblingAfter(node, -1, true)\n\n  // Previous colgroup was already omitted.\n  if (\n    parent &&\n    previous &&\n    previous.type === 'element' &&\n    previous.tagName === 'colgroup' &&\n    closing(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return head && head.type === 'element' && head.tagName === 'col'\n}\n\n/**\n * Whether to omit `<tbody>`.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction tbody(node, index, parent) {\n  const previous = siblingBefore(parent, index)\n  const head = siblingAfter(node, -1)\n\n  // Previous table section was already omitted.\n  if (\n    parent &&\n    previous &&\n    previous.type === 'element' &&\n    (previous.tagName === 'thead' || previous.tagName === 'tbody') &&\n    closing(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return head && head.type === 'element' && head.tagName === 'tr'\n}\n"]},"metadata":{},"sourceType":"module"}