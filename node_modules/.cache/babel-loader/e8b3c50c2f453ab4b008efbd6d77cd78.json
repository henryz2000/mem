{"ast":null,"code":"/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\nvar search = /[#.]/g;\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name.\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector.\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\n\nexport function parseSelector(selector, defaultTagName) {\n  var value = selector || '';\n  /** @type {Properties} */\n\n  var props = {};\n  var start = 0;\n  /** @type {string | undefined} */\n\n  var previous;\n  /** @type {string | undefined} */\n\n  var tagName;\n\n  while (start < value.length) {\n    search.lastIndex = start;\n    var match = search.exec(value);\n    var subvalue = value.slice(start, match ? match.index : value.length);\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue;\n      } else if (previous === '#') {\n        props.id = subvalue;\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue);\n      } else {\n        props.className = [subvalue];\n      }\n\n      start += subvalue.length;\n    }\n\n    if (match) {\n      previous = match[0];\n      start++;\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: fine.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  };\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/hast-util-parse-selector/lib/index.js"],"names":["search","parseSelector","selector","defaultTagName","value","props","start","previous","tagName","length","lastIndex","match","exec","subvalue","slice","index","id","Array","isArray","className","push","type","properties","children"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,IAAMA,MAAM,GAAG,OAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,CAAuBC,QAAvB,EAAiCC,cAAjC,EAAiD;AACtD,MAAMC,KAAK,GAAGF,QAAQ,IAAI,EAA1B;AACA;;AACA,MAAMG,KAAK,GAAG,EAAd;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA;;AACA,MAAIC,QAAJ;AACA;;AACA,MAAIC,OAAJ;;AAEA,SAAOF,KAAK,GAAGF,KAAK,CAACK,MAArB,EAA6B;AAC3BT,IAAAA,MAAM,CAACU,SAAP,GAAmBJ,KAAnB;AACA,QAAMK,KAAK,GAAGX,MAAM,CAACY,IAAP,CAAYR,KAAZ,CAAd;AACA,QAAMS,QAAQ,GAAGT,KAAK,CAACU,KAAN,CAAYR,KAAZ,EAAmBK,KAAK,GAAGA,KAAK,CAACI,KAAT,GAAiBX,KAAK,CAACK,MAA/C,CAAjB;;AAEA,QAAII,QAAJ,EAAc;AACZ,UAAI,CAACN,QAAL,EAAe;AACbC,QAAAA,OAAO,GAAGK,QAAV;AACD,OAFD,MAEO,IAAIN,QAAQ,KAAK,GAAjB,EAAsB;AAC3BF,QAAAA,KAAK,CAACW,EAAN,GAAWH,QAAX;AACD,OAFM,MAEA,IAAII,KAAK,CAACC,OAAN,CAAcb,KAAK,CAACc,SAApB,CAAJ,EAAoC;AACzCd,QAAAA,KAAK,CAACc,SAAN,CAAgBC,IAAhB,CAAqBP,QAArB;AACD,OAFM,MAEA;AACLR,QAAAA,KAAK,CAACc,SAAN,GAAkB,CAACN,QAAD,CAAlB;AACD;;AAEDP,MAAAA,KAAK,IAAIO,QAAQ,CAACJ,MAAlB;AACD;;AAED,QAAIE,KAAJ,EAAW;AACTJ,MAAAA,QAAQ,GAAGI,KAAK,CAAC,CAAD,CAAhB;AACAL,MAAAA,KAAK;AACN;AACF;;AAED,SAAO;AACLe,IAAAA,IAAI,EAAE,SADD;AAEL;AACAb,IAAAA,OAAO,EAAEA,OAAO,IAAIL,cAAX,IAA6B,KAHjC;AAILmB,IAAAA,UAAU,EAAEjB,KAJP;AAKLkB,IAAAA,QAAQ,EAAE;AALL,GAAP;AAOD","sourcesContent":["/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name.\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector.\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: fine.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n"]},"metadata":{},"sourceType":"module"}