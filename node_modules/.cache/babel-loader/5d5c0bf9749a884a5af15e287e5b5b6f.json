{"ast":null,"code":"import _defineProperty from \"/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\n/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\nimport { blankLine } from 'micromark-core-commonmark';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nvar indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n}; // To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\n\nexport function gfmFootnote() {\n  var _text;\n\n  /** @type {Extension} */\n  return {\n    document: _defineProperty({}, 91, {\n      tokenize: tokenizeDefinitionStart,\n      continuation: {\n        tokenize: tokenizeDefinitionContinuation\n      },\n      exit: gfmFootnoteDefinitionEnd\n    }),\n    text: (_text = {}, _defineProperty(_text, 91, {\n      tokenize: tokenizeGfmFootnoteCall\n    }), _defineProperty(_text, 93, {\n      add: 'after',\n      tokenize: tokenizePotentialGfmFootnoteCall,\n      resolveTo: resolveToPotentialGfmFootnoteCall\n    }), _text)\n  };\n} // To do: remove after micromark update.\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  var self = this;\n  var index = self.events.length;\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n\n  var defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {Token} */\n\n  var labelStart; // Find an opening.\n\n  while (index--) {\n    var token = self.events[index][1];\n\n    if (token.type === 'labelImage') {\n      labelStart = token;\n      break;\n    } // Exit if weâ€™ve walked far enough.\n\n\n    if (token.type === 'gfmFootnoteCall' || token.type === 'labelLink' || token.type === 'label' || token.type === 'image' || token.type === 'link') {\n      break;\n    }\n  }\n\n  return start;\n  /**\n   * @type {State}\n   */\n\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code);\n    }\n\n    var id = normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    }));\n\n    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code);\n    }\n\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return ok(code);\n  }\n} // To do: remove after micromark update.\n\n/** @type {Resolver} */\n\n\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  var index = events.length;\n  /** @type {Token | undefined} */\n\n  var labelStart; // Find an opening.\n\n  while (index--) {\n    if (events[index][1].type === 'labelImage' && events[index][0] === 'enter') {\n      labelStart = events[index][1];\n      break;\n    }\n  } // Change the `labelImageMarker` to a `data`.\n\n\n  events[index + 1][1].type = 'data';\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'; // The whole (without `!`):\n\n  var call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }; // The `^` marker\n\n  var marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }; // Increment the end 1 character.\n\n  marker.end.column++;\n  marker.end.offset++;\n  marker.end._bufferIndex++;\n  var string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  };\n  var chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  };\n  /** @type {Array<Event>} */\n\n  var replacement = [// Take the `labelImageMarker` (now `data`, the `!`)\n  events[index + 1], events[index + 2], ['enter', call, context], // The `[`\n  events[index + 3], events[index + 4], // The `^`.\n  ['enter', marker, context], ['exit', marker, context], // Everything in between.\n  ['enter', string, context], ['enter', chunk, context], ['exit', chunk, context], ['exit', string, context], // The ending (`]`, properly parsed and labelled).\n  events[events.length - 2], events[events.length - 1], ['exit', call, context]];\n  events.splice.apply(events, [index, events.length - index + 1].concat(replacement));\n  return events;\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  var self = this;\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n\n  var defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  var size = 0;\n  /** @type {boolean} */\n\n  var data; // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We canâ€™t do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n\n  return start;\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    effects.enter('gfmFootnoteCall');\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return callStart;\n  }\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function callStart(code) {\n    if (code !== 94) return nok(code);\n    effects.enter('gfmFootnoteCallMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallMarker');\n    effects.enter('gfmFootnoteCallString');\n    effects.enter('chunkString').contentType = 'string';\n    return callData;\n  }\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function callData(code) {\n    if ( // Too long.\n    size > 999 || code === 93 && !data || // Space or tab is not supported by GFM for some reason.\n    // `\\n` and `[` not being supported makes sense.\n    code === null || code === 91 || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      effects.exit('chunkString');\n      var token = effects.exit('gfmFootnoteCallString');\n\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code);\n      }\n\n      effects.enter('gfmFootnoteCallLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteCallLabelMarker');\n      effects.exit('gfmFootnoteCall');\n      return ok;\n    }\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n\n    size++;\n    effects.consume(code);\n    return code === 92 ? callEscape : callData;\n  }\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return callData;\n    }\n\n    return callData(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  var self = this;\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n\n  var defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {string} */\n\n  var identifier;\n  var size = 0;\n  /** @type {boolean | undefined} */\n\n  var data;\n  return start;\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true;\n    effects.enter('gfmFootnoteDefinitionLabel');\n    effects.enter('gfmFootnoteDefinitionLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteDefinitionLabelMarker');\n    return labelAtMarker;\n  }\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function labelAtMarker(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionMarker');\n      effects.enter('gfmFootnoteDefinitionLabelString');\n      effects.enter('chunkString').contentType = 'string';\n      return labelInside;\n    }\n\n    return nok(code);\n  }\n  /**\n   * In label.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function labelInside(code) {\n    if ( // Too long.\n    size > 999 || code === 93 && !data || // Space or tab is not supported by GFM for some reason.\n    // `\\n` and `[` not being supported makes sense.\n    code === null || code === 91 || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      effects.exit('chunkString');\n      var token = effects.exit('gfmFootnoteDefinitionLabelString');\n      identifier = normalizeIdentifier(self.sliceSerialize(token));\n      effects.enter('gfmFootnoteDefinitionLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionLabelMarker');\n      effects.exit('gfmFootnoteDefinitionLabel');\n      return labelAfter;\n    }\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n\n    size++;\n    effects.consume(code);\n    return code === 92 ? labelEscape : labelInside;\n  }\n  /**\n   * After `\\`, at a special character.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return labelInside;\n    }\n\n    return labelInside(code);\n  }\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker');\n\n      if (!defined.includes(identifier)) {\n        defined.push(identifier);\n      } // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n\n\n      return factorySpace(effects, whitespaceAfter, 'gfmFootnoteDefinitionWhitespace');\n    }\n\n    return nok(code);\n  }\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n\n\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code);\n  }\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok));\n}\n/** @type {Exiter} */\n\n\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition');\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\n\n\nfunction tokenizeIndent(effects, ok, nok) {\n  var self = this;\n  return factorySpace(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', 4 + 1);\n  /**\n   * @type {State}\n   */\n\n  function afterPrefix(code) {\n    var tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"sources":["/Users/henryz2000/Downloads/chrome-react-seo-extension/node_modules/micromark-extension-gfm-footnote/lib/syntax.js"],"names":["blankLine","factorySpace","markdownLineEndingOrSpace","normalizeIdentifier","indent","tokenize","tokenizeIndent","partial","gfmFootnote","document","tokenizeDefinitionStart","continuation","tokenizeDefinitionContinuation","exit","gfmFootnoteDefinitionEnd","text","tokenizeGfmFootnoteCall","add","tokenizePotentialGfmFootnoteCall","resolveTo","resolveToPotentialGfmFootnoteCall","effects","ok","nok","self","index","events","length","defined","parser","gfmFootnotes","labelStart","token","type","start","code","_balanced","id","sliceSerialize","end","now","codePointAt","includes","slice","enter","consume","context","call","Object","assign","marker","column","offset","_bufferIndex","string","chunk","contentType","replacement","splice","size","data","callStart","callData","callEscape","identifier","_container","labelAtMarker","labelInside","labelAfter","labelEscape","push","whitespaceAfter","check","attempt","afterPrefix","tail"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n\n// To do: remove after micromark update.\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1]\n    if (token.type === 'labelImage') {\n      labelStart = token\n      break\n    }\n\n    // Exit if weâ€™ve walked far enough.\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === 'labelLink' ||\n      token.type === 'label' ||\n      token.type === 'image' ||\n      token.type === 'link'\n    ) {\n      break\n    }\n  }\n  return start\n\n  /**\n   * @type {State}\n   */\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n    const id = normalizeIdentifier(\n      self.sliceSerialize({\n        start: labelStart.end,\n        end: self.now()\n      })\n    )\n    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token | undefined} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    if (\n      events[index][1].type === 'labelImage' &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = 'data'\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\n\n  // The whole (without `!`):\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  // The `^` marker\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }\n  // Increment the end 1 character.\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  const chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n\n  /** @type {Array<Event>} */\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context],\n    // The `[`\n    events[index + 3],\n    events[index + 4],\n    // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context],\n    // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context],\n    // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n  events.splice(index, events.length - index + 1, ...replacement)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n  let data\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We canâ€™t do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start\n\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callStart(code) {\n    if (code !== 94) return nok(code)\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callData(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteCallString')\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code)\n      }\n      effects.enter('gfmFootnoteCallLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteCallLabelMarker')\n      effects.exit('gfmFootnoteCall')\n      return ok\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? callEscape : callData\n  }\n\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n    return callData(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n  let identifier\n  let size = 0\n  /** @type {boolean | undefined} */\n  let data\n  return start\n\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelAtMarker\n  }\n\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAtMarker(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      effects.enter('chunkString').contentType = 'string'\n      return labelInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In label.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n    return labelInside(code)\n  }\n\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker')\n      if (!defined.includes(identifier)) {\n        defined.push(identifier)\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(\n        effects,\n        whitespaceAfter,\n        'gfmFootnoteDefinitionWhitespace'\n      )\n    }\n    return nok(code)\n  }\n\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    4 + 1\n  )\n\n  /**\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === 4\n      ? ok(code)\n      : nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}