/**
 * This file is automatically generated by graphql-code-generator.
 * Do not edit it manually.
 */
import { TypedDocumentNode as DocumentNode } from "@graphql-typed-document-node/core";
import { AnyJsonObjectScalar } from "../../utils/graphql/types";
import { AnyJsonValueScalar } from "../../utils/graphql/types";
import { ColorScalar } from "../../utils/graphql/types";
import { CursorScalar } from "../../utils/graphql/types";
import { DateTimeScalar } from "../../utils/graphql/types";
import { RichTextDeltaScalar } from "../../utils/graphql/types";
import { RichTextDocumentScalar } from "../../utils/graphql/types";
import { UploadScalar } from "../../utils/graphql/types";
import { UuidScalar } from "../../utils/graphql/types";
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    /** The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
    AnyJsonObject: AnyJsonObjectScalar;
    /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
    AnyJsonValue: AnyJsonValueScalar;
    /** Color Scalar Type */
    Color: ColorScalar;
    /** Cursor Scalar Type */
    Cursor: CursorScalar;
    /** DateTime Scalar Type */
    DateTime: DateTimeScalar;
    /** The `RichTextDelta` scalar type represents a Mem RichTextDelta. */
    RichTextDelta: RichTextDeltaScalar;
    /** The `RichTextDocument` scalar type represents a Mem RichTextDocument. */
    RichTextDocument: RichTextDocumentScalar;
    /** The `Upload` scalar type represents a file upload. */
    Upload: UploadScalar;
    /** Uuid Scalar Type */
    Uuid: UuidScalar;
};
/** An Account. */
export declare type GqAccount = GqNode & {
    __typename?: "Account";
    /** The unique identifier of the entity. */
    id: Scalars["Uuid"];
    /** The primary email connected to the user's account. */
    email: Scalars["String"];
    /** The profile display name which is associated with this account. */
    profileDisplayName: Scalars["String"];
    /** The profile image url which is associated with this account. */
    profileImageUrl: Scalars["String"];
    /**
     * The favorite items associated with this account.
     * @deprecated - use accountFavoriteItems instead.
     */
    favoriteItems: Array<GqFavoriteItem>;
    /** The semantically similar mems associated with this account and search query. */
    semanticallySimilarMemsForSearchQuery: Array<GqItemWithScore>;
    /** The favorite items associated with this account. */
    accountFavoriteItems: Array<GqAccountFavoriteItem>;
    /** The preferences associated with this account. */
    preferences: GqAccountPreferences;
    /** Represents whether the account is "internal" or not (meaning that they are an employee/internal account.) */
    isInternalAccount: Scalars["Boolean"];
    /** A list of enabled feature toggles. */
    enabledFeatureToggles: Array<GqFeatureToggleSlug>;
    /** API keys associated with the account. */
    searchAccountApiKeys: GqAccountApiKeyCursorConnection;
    /** Search the knowledge graph associated with the account. */
    searchKnowledgeGraph: GqKnowledgeGraphLimitOffsetConnection;
    /** Information associated with the account's knowledge graph. */
    knowledgeGraphInfo: GqAccountKnowledgeGraphInfo;
    /** Search the facets for the knowledge graph associated with the account. */
    searchKnowledgeGraphFacets: GqKnowledgeGraphFacetsLimitOffsetConnection;
    /** Returns the mem inbox details for the account <> mem mapping. */
    memInboxDetails: GqAccountMemInboxDetails;
    /** The WorkspaceAccounts associated with this account. */
    workspaceAccounts: Array<GqWorkspaceAccount>;
    /** The AccountBatchImports associated with this account. */
    accountBatchImports: Array<GqAccountBatchImport>;
    /**
     * The related firestore user.
     * It may not always exist (so it is nullable).
     */
    firestoreUser: Maybe<GqFirestoreUser>;
};
/** An Account. */
export declare type GqAccountSemanticallySimilarMemsForSearchQueryArgs = {
    searchQuery: Scalars["String"];
};
/** An Account. */
export declare type GqAccountSearchAccountApiKeysArgs = {
    after: Maybe<Scalars["Cursor"]>;
    before: Maybe<Scalars["Cursor"]>;
    first: Maybe<Scalars["Int"]>;
    last: Maybe<Scalars["Int"]>;
    filterBy: Maybe<GqAccountSearchAccountApiKeysFilters>;
};
/** An Account. */
export declare type GqAccountSearchKnowledgeGraphArgs = {
    limit: Maybe<Scalars["Int"]>;
    offset: Maybe<Scalars["Int"]>;
    filterBy: Maybe<GqAccountSearchKnowledgeGraphFilters>;
    source: Maybe<GqAccountSearchKnowledgeGraphSources>;
};
/** An Account. */
export declare type GqAccountSearchKnowledgeGraphFacetsArgs = {
    limit: Maybe<Scalars["Int"]>;
    offset: Maybe<Scalars["Int"]>;
    filterBy: Maybe<GqAccountSearchKnowledgeGraphFacetsFilters>;
};
/** An Account. */
export declare type GqAccountMemInboxDetailsArgs = {
    memId: Scalars["Uuid"];
};
/** An Account API Key. */
export declare type GqAccountApiKey = GqNode & {
    __typename?: "AccountApiKey";
    /** The unique identifier of the entity. */
    id: Scalars["Uuid"];
    /** The label of the token. */
    label: Scalars["String"];
    /** Some details about the token (what it is used for, where the token is stored, ...). */
    details: Maybe<Scalars["String"]>;
    /** The time at which the API Key was created. */
    createdAt: Scalars["DateTime"];
    /** The account that this API Key belongs to. */
    account: GqAccount;
};
/** The connection type for AccountApiKey. */
export declare type GqAccountApiKeyCursorConnection = {
    __typename?: "AccountApiKeyCursorConnection";
    /** A list of nodes. */
    nodes: Array<GqAccountApiKey>;
    /** Information to aid in pagination. */
    pageInfo: GqCursorPageInfo;
    /** Identifies the total count of items in the connection. */
    totalCount: Scalars["Int"];
};
export declare type GqAccountBatchImport = {
    __typename?: "AccountBatchImport";
    /** The id of the import batch. */
    id: Scalars["Uuid"];
    /** The tasks related to the import batch. */
    tasks: Array<GqAccountBatchImportTask>;
    /** Some details relating to the batch. */
    batchDetails: GqAccountBatchImportDetails;
};
export declare type GqAccountBatchImportDetails = {
    __typename?: "AccountBatchImportDetails";
    /** Total count of tasks in batch. */
    totalCount: Scalars["Int"];
    /** Total count of tasks "completed" in batch. */
    totalCountCompleted: Scalars["Int"];
    /** Total count of tasks "failed" in batch. */
    totalCountFailed: Scalars["Int"];
    /** Total count of tasks "in_progress" in batch. */
    totalCountInProgress: Scalars["Int"];
};
export declare type GqAccountBatchImportTask = {
    __typename?: "AccountBatchImportTask";
    /** The id of the import task. */
    id: Scalars["Uuid"];
    /** Some details relating to the task. */
    taskDetails: GqAccountBatchImportTaskDetails;
};
export declare type GqAccountBatchImportTaskDetails = {
    __typename?: "AccountBatchImportTaskDetails";
    /** The state of the import task. */
    state: Scalars["String"];
    /** The result of the import task. */
    result: Scalars["AnyJsonObject"];
    /** The error details of the import task. */
    errorDetails: Scalars["AnyJsonObject"];
};
/** The connection type for Account. */
export declare type GqAccountCursorConnection = {
    __typename?: "AccountCursorConnection";
    /** A list of nodes. */
    nodes: Array<GqAccount>;
    /** Information to aid in pagination. */
    pageInfo: GqCursorPageInfo;
    /** Identifies the total count of items in the connection. */
    totalCount: Scalars["Int"];
};
export declare type GqAccountFavoriteItem = GqMemAccountFavoriteItem | GqTopicAccountFavoriteItem | GqSearchQueryAccountFavoriteItem;
/** The kind of account favorite item. */
export declare enum GqAccountFavoriteItemKind {
    Mem = "MEM",
    SearchQuery = "SEARCH_QUERY",
    Topic = "TOPIC"
}
export declare type GqAccountKnowledgeGraphInfo = {
    __typename?: "AccountKnowledgeGraphInfo";
    /** Get recent knowledge graph searches. */
    recentSearches: Array<GqAccountKnowledgeGraphRecentSearch>;
    /**
     * Get recent knowledge graph searches from share sheet.
     * @deprecated Use `recentSearches with source: MEM_SHARE_SHEET` instead.
     */
    recentSearchesFromShareSheet: Array<GqAccountKnowledgeGraphRecentSearch>;
    /** Get recently edited mems. */
    recentMems: Array<GqMem>;
    /** Get knowledge graph recommended save-to-mem items for this account. */
    recommendedSavedToMemItems: Array<GqRecommendedSavedToMemItem>;
    /** Get knowledge graph recommended people for this account. */
    recommendedPeople: Array<GqAccount>;
    /** Get knowledge graph recommended topics for this account. */
    recommendedTopics: Array<GqTopic>;
    /** Get recommended action items for this account. */
    recommendedActionItems: Array<GqKnowledgeGraphRecommendedNodes>;
};
export declare type GqAccountKnowledgeGraphInfoRecentSearchesArgs = {
    source: Maybe<GqAccountSearchKnowledgeGraphSources>;
};
export declare type GqAccountKnowledgeGraphInfoRecommendedActionItemsArgs = {
    deviceCoordinates: Maybe<GqCoordinates>;
};
export declare type GqAccountKnowledgeGraphRecentSearch = {
    __typename?: "AccountKnowledgeGraphRecentSearch";
    /** A query string used most recently to search the knowledge graph by this account. */
    queryString: Scalars["String"];
};
export declare type GqAccountKnowledgeNode = GqGenericKnowledgeNode & {
    __typename?: "AccountKnowledgeNode";
    /** Internal Account-specific details related search system. */
    internalKnowledgeNodeDetails: GqInternalKnowledgeNodeDetails;
    /** Internal Account-specific details related to the search system. */
    internalAccountKnowledgeNodeDetails: GqInternalAccountKnowledgeNodeDetails;
    /** The primary label - used for displaying search results. */
    primaryLabel: Scalars["String"];
    /** The secondary label - used for displaying search results. Optional. */
    secondaryLabel: Maybe<Scalars["String"]>;
    /** The created-at time of the associated account. */
    createdAt: Scalars["DateTime"];
    /** The edited-at time of the associated account. */
    editedAt: Scalars["DateTime"];
};
export declare type GqAccountLimitOffsetConnection = {
    __typename?: "AccountLimitOffsetConnection";
    /** A list of nodes. */
    nodes: Array<GqAccount>;
    /** Information to aid in pagination. */
    pageInfo: GqLimitOffsetPageInfo;
    /** Identifies the total count of items in the connection. */
    totalCount: Scalars["Int"];
};
export declare type GqAccountMemInboxDetails = {
    __typename?: "AccountMemInboxDetails";
    /** Boolean that marks whether the inbox item is unread. */
    isUnread: Scalars["Boolean"];
    /** State of the mem in the account inbox (archived, snoozed, etc.) */
    inboxState: GqAccountMemInboxState;
    /** Subscription level between the account and mem (muted, etc.) */
    subscriptionLevel: GqAccountMemInboxSubscriptionLevel;
};
export declare type GqAccountMemInboxState = GqAccountMemInboxStateInbox | GqAccountMemInboxStateArchived | GqAccountMemInboxStateSnoozed;
export declare type GqAccountMemInboxStateArchived = GqGenericAccountMemInboxState & {
    __typename?: "AccountMemInboxStateArchived";
    /** The kind of inbox state. */
    kind: GqAccountMemInboxStateKind;
};
export declare type GqAccountMemInboxStateInbox = GqGenericAccountMemInboxState & {
    __typename?: "AccountMemInboxStateInbox";
    /** The kind of inbox state. */
    kind: GqAccountMemInboxStateKind;
};
export declare type GqAccountMemInboxStateInput = {
    /** The kind of inbox-state. */
    kind: GqAccountMemInboxStateKind;
    /** The "snoozed-until" time. */
    snoozedUntil: Maybe<Scalars["DateTime"]>;
};
/** A list of valid inbox account state kinds. */
export declare enum GqAccountMemInboxStateKind {
    Inbox = "INBOX",
    Archived = "ARCHIVED",
    Snoozed = "SNOOZED"
}
export declare type GqAccountMemInboxStateSnoozed = GqGenericAccountMemInboxState & {
    __typename?: "AccountMemInboxStateSnoozed";
    /** The kind of inbox state. */
    kind: GqAccountMemInboxStateKind;
    /** The "snoozed-until" time. */
    snoozedUntil: Scalars["DateTime"];
};
export declare type GqAccountMemInboxSubscriptionLevel = GqAccountMemInboxSubscriptionLevelAll | GqAccountMemInboxSubscriptionLevelDigest | GqAccountMemInboxSubscriptionLevelMuted;
export declare type GqAccountMemInboxSubscriptionLevelAll = GqGenericAccountMemInboxSubscriptionLevel & {
    __typename?: "AccountMemInboxSubscriptionLevelAll";
    /** The kind of inbox subscription level. */
    kind: GqAccountMemInboxSubscriptionLevelKind;
};
export declare type GqAccountMemInboxSubscriptionLevelDigest = GqGenericAccountMemInboxSubscriptionLevel & {
    __typename?: "AccountMemInboxSubscriptionLevelDigest";
    /** The kind of inbox subscription level. */
    kind: GqAccountMemInboxSubscriptionLevelKind;
};
export declare type GqAccountMemInboxSubscriptionLevelInput = {
    /** The kind of inbox subscription level. */
    kind: GqAccountMemInboxSubscriptionLevelKind;
};
/** A list of valid inbox subscription level kinds. */
export declare enum GqAccountMemInboxSubscriptionLevelKind {
    All = "ALL",
    Digest = "DIGEST",
    Muted = "MUTED"
}
export declare type GqAccountMemInboxSubscriptionLevelMuted = GqGenericAccountMemInboxSubscriptionLevel & {
    __typename?: "AccountMemInboxSubscriptionLevelMuted";
    /** The kind of inbox subscription level. */
    kind: GqAccountMemInboxSubscriptionLevelKind;
};
/** A list of valid account preference slugs. */
export declare enum GqAccountPreferenceSlug {
    ExampleAccountPreference = "EXAMPLE_ACCOUNT_PREFERENCE",
    RecordMemInteractionLocationPolicy = "RECORD_MEM_INTERACTION_LOCATION_POLICY"
}
export declare type GqAccountPreferences = {
    __typename?: "AccountPreferences";
    /**
     * A preference regarding whether locations should be recorded when mems
     * are interacted with (compose, edit, etc.)
     */
    recordMemInteractionLocationPolicy: GqRecordMemInteractionLocationPolicyAccountPreference;
};
export declare type GqAccountSearchAccountApiKeysFilters = {
    /** Include API Keys which have been revoked. */
    includeRevoked: Maybe<Scalars["Boolean"]>;
};
export declare type GqAccountSearchKnowledgeGraphFacetsFilters = {
    /** The query string. */
    queryString: Maybe<Scalars["String"]>;
};
export declare type GqAccountSearchKnowledgeGraphFilters = {
    /** The query string. */
    queryString: Maybe<Scalars["String"]>;
    /** Facets exposed by the search. */
    filterableFacetKinds: Maybe<Array<GqKnowledgeGraphFacetKind>>;
    /** The facet and value of the facet to filter by. */
    facetFilters: Maybe<Array<GqKnowledgeGraphFacetFilter>>;
    /** The kinds of entities to be retrieved by the search. */
    entityKindsToRetrieve: Maybe<Array<GqKnowledgeNodeSearchObjectKind>>;
};
export declare enum GqAccountSearchKnowledgeGraphSources {
    MemApp = "MEM_APP",
    MemIos = "MEM_IOS",
    MemKeyboard = "MEM_KEYBOARD",
    MemShareSheet = "MEM_SHARE_SHEET"
}
/** A list of valid account workspace roles. */
export declare enum GqAccountWorkspaceRoleKind {
    Owner = "OWNER",
    Admin = "ADMIN",
    Member = "MEMBER"
}
export declare type GqAddAccountFavoriteItemInput = {
    /** The identifier for the account which should be updated. */
    accountId: Scalars["Uuid"];
    /** String describing the item. */
    label: Scalars["String"];
    /** Value of the item. */
    value: GqFavoriteItemValueInput;
};
export declare type GqAddAccountFavoriteItemPayload = {
    __typename?: "AddAccountFavoriteItemPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The updated account. */
    account: GqAccount;
};
/** A list of admin functions. */
export declare enum GqAdminFunctionName {
    IndexAllMemsFromFirebase = "INDEX_ALL_MEMS_FROM_FIREBASE",
    ReindexAllMemsInApiDb = "REINDEX_ALL_MEMS_IN_API_DB",
    IndexAllTemplatesFromFirebase = "INDEX_ALL_TEMPLATES_FROM_FIREBASE",
    BackfillAllMemEmbeddings = "BACKFILL_ALL_MEM_EMBEDDINGS",
    BackfillMemCurieEmbeddingsForAuthorizedUsers = "BACKFILL_MEM_CURIE_EMBEDDINGS_FOR_AUTHORIZED_USERS",
    BackfillMemCurieEmbeddingsForAuthorizedUsersFromDate = "BACKFILL_MEM_CURIE_EMBEDDINGS_FOR_AUTHORIZED_USERS_FROM_DATE",
    BackfillMemCurieSearchDocEmbeddingsForAuthorizedUsers = "BACKFILL_MEM_CURIE_SEARCH_DOC_EMBEDDINGS_FOR_AUTHORIZED_USERS",
    IndexAllFirestoreUsersInFirebase = "INDEX_ALL_FIRESTORE_USERS_IN_FIREBASE"
}
export declare type GqAppendToMemContentInput = {
    /** The identifier for the target Mem. */
    memId: Scalars["Uuid"];
    /**
     * The contents which should be appended to the existing mem.
     * Must be in the markdown format.
     *
     * (Titles and tags are automatically parsed from the content.)
     */
    content: Maybe<Scalars["String"]>;
    /**
     * The contents which should be appended to the existing mem.
     * Must be in the rich-text-document format.
     */
    richTextDocument: Maybe<Scalars["RichTextDocument"]>;
    /**
     * Defaults to the current time.
     * Pass an explicit time to override the default.
     */
    updatedAt: Maybe<Scalars["DateTime"]>;
    /**
     * An identifier for the client submitting the request.
     * Optional, but recommended.
     */
    clientId: Maybe<Scalars["Uuid"]>;
};
export declare type GqAppendToMemContentPayload = {
    __typename?: "AppendToMemContentPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The Mem which was updated. */
    mem: GqMem;
};
export declare type GqAuthenticateAccountUsingGoogleOAuthCodeInput = {
    /** The code which should be used for authentication. */
    code: Scalars["String"];
    /** The client which the code is associated with. */
    client: GqGoogleOAuthClient;
    /** The redirectURI which the code is associated with. */
    redirectURI: Scalars["String"];
};
export declare type GqAuthenticateAccountUsingGoogleOAuthCodePayload = {
    __typename?: "AuthenticateAccountUsingGoogleOAuthCodePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The Account which was authenticated. */
    authenticatedAccount: GqAccount;
    /** The JWT which was generated. */
    token: Scalars["String"];
};
export declare type GqAuthenticateUsingEmailPasswordInput = {
    /** The email which should be used for authentication. */
    email: Scalars["String"];
    /** The password which should be used for authentication. */
    password: Scalars["String"];
};
export declare type GqAuthenticateUsingEmailPasswordPayload = {
    __typename?: "AuthenticateUsingEmailPasswordPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The Account which was authenticated. */
    authenticatedAccount: GqAccount;
    /** The JWT which was generated. */
    token: Scalars["String"];
};
export declare type GqCacheGetResults = {
    __typename?: "CacheGetResults";
    /** The result string for the specified query. */
    resultString: Scalars["String"];
};
export declare type GqCacheSetResults = {
    __typename?: "CacheSetResults";
    /** Whether the set was successful. */
    success: Scalars["Boolean"];
};
export declare enum GqClickedEntityEventNames {
    MemClicked = "MEM_CLICKED"
}
/** A list of valid client events. */
export declare enum GqClientEventKind {
    ExampleEvent = "EXAMPLE_EVENT",
    /** Generic */
    MemIosAppBooted = "MEM_IOS_APP_BOOTED",
    MemIosLoadPersistedAccountSuccess = "MEM_IOS_LOAD_PERSISTED_ACCOUNT_SUCCESS",
    MemIosLoadPersistedAccountFailureNotFound = "MEM_IOS_LOAD_PERSISTED_ACCOUNT_FAILURE_NOT_FOUND",
    MemIosAppOpened = "MEM_IOS_APP_OPENED",
    /** Login */
    MemIosLoginScreenViewed = "MEM_IOS_LOGIN_SCREEN_VIEWED",
    MemIosLoginScreenAccountLoginSuccess = "MEM_IOS_LOGIN_SCREEN_ACCOUNT_LOGIN_SUCCESS",
    MemIosLoginScreenAccountLoginFailureNotFound = "MEM_IOS_LOGIN_SCREEN_ACCOUNT_LOGIN_FAILURE_NOT_FOUND",
    MemIosLoginScreenAccountLoginFailureUnknown = "MEM_IOS_LOGIN_SCREEN_ACCOUNT_LOGIN_FAILURE_UNKNOWN",
    MemIosLoginScreenSignInWithGoogleClicked = "MEM_IOS_LOGIN_SCREEN_SIGN_IN_WITH_GOOGLE_CLICKED",
    MemIosLoginScreenLearnMoreClicked = "MEM_IOS_LOGIN_SCREEN_LEARN_MORE_CLICKED",
    MemIosLoginScreenAccountNotFoundMustSignUpClicked = "MEM_IOS_LOGIN_SCREEN_ACCOUNT_NOT_FOUND_MUST_SIGN_UP_CLICKED",
    /** Home */
    MemIosHomeScreenViewed = "MEM_IOS_HOME_SCREEN_VIEWED",
    MemIosHomeScreenLoadedResults = "MEM_IOS_HOME_SCREEN_LOADED_RESULTS",
    MemIosHomeScreenSawNoResults = "MEM_IOS_HOME_SCREEN_SAW_NO_RESULTS",
    MemIosHomeScreenLoadedMoreResults = "MEM_IOS_HOME_SCREEN_LOADED_MORE_RESULTS",
    MemIosHomeScreenRefreshedResults = "MEM_IOS_HOME_SCREEN_REFRESHED_RESULTS",
    MemIosHomeScreenSuggestionClicked = "MEM_IOS_HOME_SCREEN_SUGGESTION_CLICKED",
    /** Search */
    MemIosSearchScreenViewed = "MEM_IOS_SEARCH_SCREEN_VIEWED",
    MemIosSearchScreenSearchExecuted = "MEM_IOS_SEARCH_SCREEN_SEARCH_EXECUTED",
    MemIosSearchScreenSawNoResults = "MEM_IOS_SEARCH_SCREEN_SAW_NO_RESULTS",
    MemIosSearchScreenLoadedMoreResults = "MEM_IOS_SEARCH_SCREEN_LOADED_MORE_RESULTS",
    MemIosSearchScreenSuggestionClicked = "MEM_IOS_SEARCH_SCREEN_SUGGESTION_CLICKED",
    MemIosSearchScreenOpenedFromNavigationBar = "MEM_IOS_SEARCH_SCREEN_OPENED_FROM_NAVIGATION_BAR",
    MemIosSearchScreenOpenedFromHomeBar = "MEM_IOS_SEARCH_SCREEN_OPENED_FROM_HOME_BAR",
    /** Share Sheet */
    MemIosShareSheetViewed = "MEM_IOS_SHARE_SHEET_VIEWED",
    /** Slice Results (Home + Search Views) */
    MemIosSliceResultsItemClicked = "MEM_IOS_SLICE_RESULTS_ITEM_CLICKED",
    /** Details */
    MemIosDetailScreenViewed = "MEM_IOS_DETAIL_SCREEN_VIEWED",
    MemIosDetailScreenMemEdited = "MEM_IOS_DETAIL_SCREEN_MEM_EDITED",
    MemIosDetailScreenMemComposed = "MEM_IOS_DETAIL_SCREEN_MEM_COMPOSED",
    MemIosDetailScreenTopicClicked = "MEM_IOS_DETAIL_SCREEN_TOPIC_CLICKED",
    MemIosDetailScreenWebLinkClicked = "MEM_IOS_DETAIL_SCREEN_WEB_LINK_CLICKED",
    MemIosDetailScreenLinkedFirestoreNoteClicked = "MEM_IOS_DETAIL_SCREEN_LINKED_FIRESTORE_NOTE_CLICKED",
    MemIosDetailScreenMentionedFirestoreUserClicked = "MEM_IOS_DETAIL_SCREEN_MENTIONED_FIRESTORE_USER_CLICKED",
    MemIosDetailScreenMentionedFirestoreGroupClicked = "MEM_IOS_DETAIL_SCREEN_MENTIONED_FIRESTORE_GROUP_CLICKED",
    MemIosDetailScreenRelatedMemsViewed = "MEM_IOS_DETAIL_SCREEN_RELATED_MEMS_VIEWED",
    /** Editing */
    MemIosEditorCarouselCameraClicked = "MEM_IOS_EDITOR_CAROUSEL_CAMERA_CLICKED",
    MemIosEditorCarouselPhotoClicked = "MEM_IOS_EDITOR_CAROUSEL_PHOTO_CLICKED",
    MemIosEditorCarouselGalleryClicked = "MEM_IOS_EDITOR_CAROUSEL_GALLERY_CLICKED",
    MemIosEditorToolbarGalleryClicked = "MEM_IOS_EDITOR_TOOLBAR_GALLERY_CLICKED",
    MemIosEditorToolbarBulletedListClicked = "MEM_IOS_EDITOR_TOOLBAR_BULLETED_LIST_CLICKED",
    MemIosEditorToolbarChecklistClicked = "MEM_IOS_EDITOR_TOOLBAR_CHECKLIST_CLICKED",
    MemIosEditorToolbarAddTagClicked = "MEM_IOS_EDITOR_TOOLBAR_ADD_TAG_CLICKED",
    MemIosEditorToolbarFormatClicked = "MEM_IOS_EDITOR_TOOLBAR_FORMAT_CLICKED",
    MemIosEditorToolbarH1Clicked = "MEM_IOS_EDITOR_TOOLBAR_H1_CLICKED",
    MemIosEditorToolbarH2Clicked = "MEM_IOS_EDITOR_TOOLBAR_H2_CLICKED",
    MemIosEditorToolbarBoldClicked = "MEM_IOS_EDITOR_TOOLBAR_BOLD_CLICKED",
    MemIosEditorToolbarItalicClicked = "MEM_IOS_EDITOR_TOOLBAR_ITALIC_CLICKED",
    MemIosEditorToolbarUnderlineClicked = "MEM_IOS_EDITOR_TOOLBAR_UNDERLINE_CLICKED",
    MemIosEditorToolbarStrikethroughClicked = "MEM_IOS_EDITOR_TOOLBAR_STRIKETHROUGH_CLICKED",
    MemIosEditorToolbarCodeBlockClicked = "MEM_IOS_EDITOR_TOOLBAR_CODE_BLOCK_CLICKED",
    MemIosEditorToolbarQuoteBlockClicked = "MEM_IOS_EDITOR_TOOLBAR_QUOTE_BLOCK_CLICKED",
    MemIosEditorToolbarRemoveFormattingClicked = "MEM_IOS_EDITOR_TOOLBAR_REMOVE_FORMATTING_CLICKED",
    /** Side Navigation */
    MemIosSideNavigationViewed = "MEM_IOS_SIDE_NAVIGATION_VIEWED",
    /** Help And Support */
    MemIosSupportScreenViewed = "MEM_IOS_SUPPORT_SCREEN_VIEWED",
    MemIosSupportScreenProductUpdatesClicked = "MEM_IOS_SUPPORT_SCREEN_PRODUCT_UPDATES_CLICKED",
    MemIosSupportScreenFaqsClicked = "MEM_IOS_SUPPORT_SCREEN_FAQS_CLICKED",
    MemIosSupportScreenTutorialsClicked = "MEM_IOS_SUPPORT_SCREEN_TUTORIALS_CLICKED",
    MemIosSupportScreenBlogClicked = "MEM_IOS_SUPPORT_SCREEN_BLOG_CLICKED",
    MemIosSupportScreenContactUsClicked = "MEM_IOS_SUPPORT_SCREEN_CONTACT_US_CLICKED",
    /** Other Events */
    MemIosAccountLoggedOut = "MEM_IOS_ACCOUNT_LOGGED_OUT"
}
/** A list of valid cloud tasks. */
export declare enum GqCloudTaskKind {
    HealthCheck = "HEALTH_CHECK",
    ExampleEvent = "EXAMPLE_EVENT",
    IndexMemEntity = "INDEX_MEM_ENTITY",
    ReprocessMemEntity = "REPROCESS_MEM_ENTITY",
    ExtractPeopleFromMemEntity = "EXTRACT_PEOPLE_FROM_MEM_ENTITY",
    ExtractImplicitTopicsFromMemEntity = "EXTRACT_IMPLICIT_TOPICS_FROM_MEM_ENTITY",
    ExtractTextFromImagesInsideMemEntity = "EXTRACT_TEXT_FROM_IMAGES_INSIDE_MEM_ENTITY",
    StoreTrackedEvent = "STORE_TRACKED_EVENT",
    ReindexAllMemsForAccount = "REINDEX_ALL_MEMS_FOR_ACCOUNT",
    ReindexAllMemsInApiDb = "REINDEX_ALL_MEMS_IN_API_DB",
    IndexAllMemsInFirebase = "INDEX_ALL_MEMS_IN_FIREBASE",
    CreateUserAppNotificationForAllUsers = "CREATE_USER_APP_NOTIFICATION_FOR_ALL_USERS",
    BatchIndexMemEntities = "BATCH_INDEX_MEM_ENTITIES",
    IndexAccountEntity = "INDEX_ACCOUNT_ENTITY",
    IndexAllUsersInFirebase = "INDEX_ALL_USERS_IN_FIREBASE",
    BatchIndexFirestoreUsers = "BATCH_INDEX_FIRESTORE_USERS",
    IndexGroupEntity = "INDEX_GROUP_ENTITY",
    IndexMemTemplateEntity = "INDEX_MEM_TEMPLATE_ENTITY",
    IndexAllTemplatesInFirebase = "INDEX_ALL_TEMPLATES_IN_FIREBASE",
    BatchImportMems = "BATCH_IMPORT_MEMS",
    ImportMemTask = "IMPORT_MEM_TASK",
    BatchIndexMemTemplateEntities = "BATCH_INDEX_MEM_TEMPLATE_ENTITIES",
    BackfillAllMemEmbeddings = "BACKFILL_ALL_MEM_EMBEDDINGS",
    BackfillMemCurieEmbeddingsForAuthorizedUsers = "BACKFILL_MEM_CURIE_EMBEDDINGS_FOR_AUTHORIZED_USERS",
    BackfillMemCurieSearchDocEmbeddingsForAuthorizedUsers = "BACKFILL_MEM_CURIE_SEARCH_DOC_EMBEDDINGS_FOR_AUTHORIZED_USERS",
    BackfillMemCurieEmbeddingsForAuthorizedUsersFromDate = "BACKFILL_MEM_CURIE_EMBEDDINGS_FOR_AUTHORIZED_USERS_FROM_DATE",
    BatchEmbedMems = "BATCH_EMBED_MEMS",
    EmbedMem = "EMBED_MEM",
    EmbedMemSearchDoc = "EMBED_MEM_SEARCH_DOC",
    EmbedMems = "EMBED_MEMS",
    EmbedMemsSearchDoc = "EMBED_MEMS_SEARCH_DOC",
    BackfillMemCurieEmbeddingsForUserUsingFirestoreUserId = "BACKFILL_MEM_CURIE_EMBEDDINGS_FOR_USER_USING_FIRESTORE_USER_ID",
    BackfillMemCurieSearchDocEmbeddingsForUserUsingFirestoreUserId = "BACKFILL_MEM_CURIE_SEARCH_DOC_EMBEDDINGS_FOR_USER_USING_FIRESTORE_USER_ID"
}
export declare type GqCommentThread = {
    __typename?: "CommentThread";
    /** The identifier of the associated comment thread. */
    id: Scalars["String"];
    /** The created-at time of the associated comment thread. */
    createdAt: Scalars["DateTime"];
    /** The updated-at time of the associated comment thread. */
    updatedAt: Scalars["DateTime"];
    /** The comments that are in the associated comment thread (firestore notes). */
    comments: Array<GqFirestoreDraftNote>;
    /** Whether or not the thread is unread for the user. */
    isUnread: Scalars["Boolean"];
    /** Whether or not the thread is done for the user. */
    isDone: Scalars["Boolean"];
    /** Whether or not the thread has an associated sharing noteID. */
    isCommentThread: Scalars["Boolean"];
    /** The title of the associated comment thread. */
    title: Scalars["String"];
    /** The users that have this comment thread in their trash. */
    isInTrashForUsers: Array<Scalars["String"]>;
    /** The ids of the inbox items of the associated comment thread. */
    itemIds: Array<Scalars["String"]>;
};
export declare enum GqConvertedObjectIDsAfterSearchEventNames {
    MemConverted = "MEM_CONVERTED"
}
export declare type GqCoordinates = {
    /** The latitude of the geographical coordinate. */
    latitude: Scalars["Float"];
    /** The longitude of the geographical coordinate. */
    longitude: Scalars["Float"];
};
export declare type GqCreateAccountApiKeyInput = {
    /** The identifier for the Account API Key. If not provided, the server will generate one. */
    accountApiKeyId: Maybe<Scalars["Uuid"]>;
    /** The unique API token value. If not provided, the server will generate one. */
    token: Maybe<Scalars["Uuid"]>;
    /** The label for the API key. */
    label: Scalars["String"];
    /** Some details about the API key (what it is used for, where the token is stored, ...). */
    details: Maybe<Scalars["String"]>;
};
export declare type GqCreateAccountApiKeyPayload = {
    __typename?: "CreateAccountApiKeyPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The API key that was created. */
    accountApiKey: GqAccountApiKey;
    /** The token associated with the newly-created API Key. */
    token: Scalars["Uuid"];
};
export declare type GqCreateMemInput = {
    /** The identifier for the Mem. If not provided, the server will generate one. */
    memId: Maybe<Scalars["Uuid"]>;
    /**
     * The initial contents of the mem.
     * Must be in the markdown format.
     *
     * (Titles and tags are automatically parsed from the content.)
     */
    content: Maybe<Scalars["String"]>;
    /**
     * The initial contents of the mem.
     * Must be in the rich-text-document format.
     */
    richTextDocument: Maybe<Scalars["RichTextDocument"]>;
    /** Specify whether the mem should be automatically marked as "read". */
    isRead: Maybe<Scalars["Boolean"]>;
    /** Specify whether the mem should be automatically marked as "archived". */
    isArchived: Maybe<Scalars["Boolean"]>;
    /** Specify a timestamp at which the mem will "resurface". */
    scheduledFor: Maybe<Scalars["DateTime"]>;
    /**
     * Defaults to the current time.
     * Pass an explicit time to override the default.
     */
    createdAt: Maybe<Scalars["DateTime"]>;
    /**
     * Mem source metadata.
     * Defaults to API.
     */
    source: Maybe<GqCreateMemSourceInput>;
    /**
     * An identifier for the client submitting the request.
     * Optional, but recommended.
     */
    clientId: Maybe<Scalars["Uuid"]>;
};
export declare type GqCreateMemPayload = {
    __typename?: "CreateMemPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The Mem which was created. */
    mem: GqMem;
};
export declare type GqCreateMemSourceInput = {
    /** What created this mem. */
    type: GqMemCreationSourceKind;
    /** Unique batch ID for the "Import" source kind */
    importBatchId: Maybe<Scalars["Uuid"]>;
    /** What was the kind of product for "Import" source kind */
    importKind: Maybe<GqMemCreationImportSourceKind>;
};
export declare type GqCreateWorkspaceInput = {
    /** The identifier for the Workspace. If not provided, the server will generate one. */
    id: Maybe<Scalars["Uuid"]>;
    /** The name of the workspace. */
    name: Scalars["String"];
};
export declare type GqCreateWorkspacePayload = {
    __typename?: "CreateWorkspacePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The workspace which was created. */
    workspace: GqWorkspace;
};
/** Information about pagination in a connection. */
export declare type GqCursorPageInfo = {
    __typename?: "CursorPageInfo";
    /** When paginating forwards, the cursor to continue. */
    endCursor: Maybe<Scalars["Cursor"]>;
    /** When paginating backwards, the cursor to continue. */
    startCursor: Maybe<Scalars["Cursor"]>;
    /** When paginating forwards, are there more items? */
    hasNextPage: Scalars["Boolean"];
    /** When paginating backwards, are there more items? */
    hasPreviousPage: Scalars["Boolean"];
};
export declare type GqDeleteAccountBatchImportMemsInput = {
    /** The id of the import batch. */
    accountBatchImportId: Scalars["Uuid"];
};
export declare type GqDeleteAccountBatchImportMemsPayload = {
    __typename?: "DeleteAccountBatchImportMemsPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqDeleteAccountFavoriteItemInput = {
    /** The identifier for the account which should be updated. */
    accountId: Scalars["Uuid"];
    /** Value of the item. */
    value: GqFavoriteItemValueInput;
};
export declare type GqDeleteAccountFavoriteItemPayload = {
    __typename?: "DeleteAccountFavoriteItemPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The updated account. */
    account: GqAccount;
};
export declare type GqFactKnowledgeNode = GqGenericKnowledgeNode & {
    __typename?: "FactKnowledgeNode";
    /** Internal fact-specific details related search system. */
    internalKnowledgeNodeDetails: GqInternalKnowledgeNodeDetails;
    /** Internal fact-specific details related to the search system. */
    internalFactKnowledgeNodeDetails: GqInternalFactKnowledgeNodeDetails;
    /** The primary label - used for displaying search results. */
    primaryLabel: Scalars["String"];
    /** The secondary label - used for displaying search results. Optional. */
    secondaryLabel: Maybe<Scalars["String"]>;
    /** The created-at time of the associated fact. */
    createdAt: Scalars["DateTime"];
    /** The edited-at time of the associated fact. */
    editedAt: Scalars["DateTime"];
};
export declare type GqFactKnowledgeNodeContent = {
    __typename?: "FactKnowledgeNodeContent";
    /** Content in the plaintext format. */
    plaintext: Scalars["String"];
};
export declare enum GqFactType {
    Numeric = "NUMERIC",
    Email = "EMAIL",
    Url = "URL",
    Password = "PASSWORD"
}
/**
 * type FavoriteItem {
 * @deprecated - use AccountFavoriteItem instead.
 */
export declare type GqFavoriteItem = {
    __typename?: "FavoriteItem";
    /** String describing the item. */
    label: Scalars["String"];
    /** The item value. */
    value: GqFavoriteItemValue;
};
/**
 * The kind of favorite item.
 * @deprecated - use AccountFavoriteItemKind instead.
 */
export declare enum GqFavoriteItemKind {
    Mem = "MEM",
    SearchQuery = "SEARCH_QUERY",
    Topic = "TOPIC"
}
export declare type GqFavoriteItemValue = GqMem;
/** Union input type for all of the different FavoriteItemKinds. */
export declare type GqFavoriteItemValueInput = {
    /** The kind of the item. */
    kind: GqFavoriteItemKind;
    /**
     * Id of a mem which should be added as a favorite.
     * Required only for `kind` === `MEM`.
     */
    memId: Maybe<Scalars["Uuid"]>;
    /**
     * Query of the search.
     * Required only for `kind` === `SEARCH_QUERY`.
     */
    searchQuery: Maybe<Scalars["String"]>;
    /**
     * Label of the topic.
     * Required only for `kind` === `TOPIC`.
     */
    topicLabel: Maybe<Scalars["String"]>;
};
/** A list of valid feature toggle slugs. */
export declare enum GqFeatureToggleSlug {
    ExampleFeature = "EXAMPLE_FEATURE",
    MemIosAlphaTester = "MEM_IOS_ALPHA_TESTER",
    SearchIndexingAlphaTester = "SEARCH_INDEXING_ALPHA_TESTER",
    MemIosBroadcastOnClient = "MEM_IOS_BROADCAST_ON_CLIENT",
    SimilarMemsFeature = "SIMILAR_MEMS_FEATURE",
    WorkspacesAlphaTester = "WORKSPACES_ALPHA_TESTER",
    ElasticCloudSearchTester = "ELASTIC_CLOUD_SEARCH_TESTER"
}
export declare type GqFirestoreDraftNote = {
    __typename?: "FirestoreDraftNote";
    id: Scalars["String"];
    body: Scalars["String"];
    snapshotMap: Scalars["AnyJsonObject"];
    created: Scalars["DateTime"];
    streamIds: Array<Scalars["String"]>;
    threadNoteId: Scalars["String"];
    sharingNoteId: Scalars["String"];
    acl: Scalars["AnyJsonObject"];
    awareUserIds: Array<Scalars["String"]>;
    contexts: Scalars["AnyJsonObject"];
    updated: Scalars["DateTime"];
    editableDuringUxId: Scalars["Boolean"];
    source: Scalars["String"];
    automaticSharingMode: Scalars["String"];
    isInTrashForUsers: Array<Scalars["String"]>;
    changesetProjectionId: Scalars["String"];
    changesetVersion: Scalars["Int"];
};
export declare type GqFirestoreNote = {
    __typename?: "FirestoreNote";
    id: Scalars["String"];
};
export declare type GqFirestoreUser = {
    __typename?: "FirestoreUser";
    id: Scalars["String"];
};
export declare type GqGenericAccountFavoriteItem = {
    /** String describing the item. */
    label: Scalars["String"];
};
export declare type GqGenericAccountMemInboxState = {
    /** The kind of inbox state. */
    kind: GqAccountMemInboxStateKind;
};
export declare type GqGenericAccountMemInboxSubscriptionLevel = {
    /** The kind of inbox subscription level. */
    kind: GqAccountMemInboxSubscriptionLevelKind;
};
export declare type GqGenericItemWithScore = {
    /** The similarity score between this mem and the query mem. */
    score: Scalars["Float"];
};
export declare type GqGenericKnowledgeNode = {
    /** Internal details related to the knowledge node. */
    internalKnowledgeNodeDetails: GqInternalKnowledgeNodeDetails;
    /** The primary label - used for displaying search results. */
    primaryLabel: Scalars["String"];
    /** The secondary label - used for displaying search results. Optional. */
    secondaryLabel: Maybe<Scalars["String"]>;
    /** The created-at time of the associated entity. */
    createdAt: Scalars["DateTime"];
    /** The edited-at time of the associated entity. */
    editedAt: Scalars["DateTime"];
};
export declare type GqGenericKnowledgeNodePivot = {
    /** The primary label of the category - used for displaying search results. */
    primaryLabel: Scalars["String"];
};
/** @deprecated - use GenericItemWithScore instead. */
export declare type GqGenericSimilarItem = {
    /** The similarity score between this mem and the query mem. */
    score: Scalars["Float"];
};
export declare enum GqGoogleOAuthClient {
    MemWebClient = "MEM_WEB_CLIENT",
    MemAdminPortal = "MEM_ADMIN_PORTAL",
    MemIos = "MEM_IOS"
}
/** Details about the server's health. */
export declare type GqHealthCheckDetails = {
    __typename?: "HealthCheckDetails";
    /** Should always be true if the server responds. */
    apiStatus: Scalars["Boolean"];
    /** Queries the postgres database to ensure it is working. */
    postgresStatus: Scalars["Boolean"];
    /** Queries the firestore database to ensure it is working. */
    firestoreStatus: Scalars["Boolean"];
    /** Queries the redis cache to ensure it is working. */
    redisStatus: Scalars["Boolean"];
    /** Details regarding the server's build/deployment/environment/.. */
    serverInfo: GqServerInfo;
};
export declare type GqImportMemsInput = {
    /** The file(.zip/.enex) that contains the notes. */
    file: Scalars["Upload"];
    /** The source of the imported notes. */
    importKind: GqMemCreationImportSourceKind;
};
export declare type GqImportMemsPayload = {
    __typename?: "ImportMemsPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalAccountKnowledgeNodeDetails = {
    __typename?: "InternalAccountKnowledgeNodeDetails";
    /**
     * The unique identifier of the associated firestore user.
     * (Fetching data for these users should be done as a separate query.)
     */
    firestoreUserId: Maybe<Scalars["String"]>;
    /** Unique identifier of the account. */
    accountId: Scalars["Uuid"];
    /** The email of the account. */
    email: Scalars["String"];
    /** The display name of the account. */
    profileDisplayName: Scalars["String"];
    /** The profile photo url of the account. */
    profileImageUrl: Scalars["String"];
    /** The list of accounts permitted to view the account knowledge node. */
    permittedAccountIds: Array<Scalars["Uuid"]>;
    /** The list of users permitted to view the account knowledge node. */
    permittedFirestoreUserIds: Array<Scalars["String"]>;
};
export declare type GqInternalCloseAccountInput = {
    /** The identifier for the account which should be closed. */
    accountId: Scalars["Uuid"];
};
export declare type GqInternalCloseAccountPayload = {
    __typename?: "InternalCloseAccountPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalCreateUserAppNotificationForAllUsersInput = {
    /** The date for when users should be notified for this particular notification. */
    notifyStart: Scalars["DateTime"];
    /** The date for when users should stop being notified (assuming they haven't closed the notification yet). */
    notifyEnd: Scalars["DateTime"];
    /** The identifier for the particular notification. */
    notificationId: Scalars["String"];
};
export declare type GqInternalCreateUserAppNotificationForAllUsersPayload = {
    __typename?: "InternalCreateUserAppNotificationForAllUsersPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalCreateUserAppNotificationInput = {
    /** The date for when users should be notified for this particular notification. */
    notifyStart: Scalars["DateTime"];
    /** The date for when users should stop being notified (assuming they haven't closed the notification yet). */
    notifyEnd: Scalars["DateTime"];
    /** The identifier for the user. */
    userId: Scalars["String"];
    /** The identifier for the particular notification. */
    notificationId: Scalars["String"];
};
export declare type GqInternalCreateUserAppNotificationPayload = {
    __typename?: "InternalCreateUserAppNotificationPayload";
    /** The identifier for the created or duplicate user app notification. */
    userAppNotificationId: Scalars["String"];
    /** Whether the user app notification was a duplicate. */
    isDuplicate: Scalars["Boolean"];
};
export declare type GqInternalCreateVersionLaunchShowcaseAppNotificationInput = {
    /** The details required to create the app notification. */
    details: GqVersionLaunchShowcaseAppNotificationDetails;
};
export declare type GqInternalCreateVersionLaunchShowcaseAppNotificationPayload = {
    __typename?: "InternalCreateVersionLaunchShowcaseAppNotificationPayload";
    /** The identifier for the created app notification. */
    appNotificationId: Scalars["String"];
};
export declare type GqInternalDisableAccountFeatureToggleInput = {
    /** The identifier for the target account. */
    accountId: Scalars["Uuid"];
    /** The slug for the target feature toggle.. */
    featureToggleSlug: GqFeatureToggleSlug;
};
export declare type GqInternalDisableAccountFeatureTogglePayload = {
    __typename?: "InternalDisableAccountFeatureTogglePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The updated account. */
    account: GqAccount;
};
export declare type GqInternalEnableAccountFeatureToggleInput = {
    /** The identifier for the target account. */
    accountId: Scalars["Uuid"];
    /** The slug for the target feature toggle.. */
    featureToggleSlug: GqFeatureToggleSlug;
};
export declare type GqInternalEnableAccountFeatureTogglePayload = {
    __typename?: "InternalEnableAccountFeatureTogglePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The updated account. */
    account: GqAccount;
};
export declare type GqInternalEnableFeatureToggleForAllAccountWithEmailDomainInput = {
    /** The domain name of the users emails that should be affected (everything after the @ symbol). */
    domainName: Scalars["String"];
    /** The feature toggle to enable or disable. */
    featureToggleSlug: GqFeatureToggleSlug;
    /** Boolean indicating whether to enable or disable feature flag. */
    enable: Scalars["Boolean"];
};
export declare type GqInternalEnableFeatureToggleForAllAccountWithEmailDomainPayload = {
    __typename?: "InternalEnableFeatureToggleForAllAccountWithEmailDomainPayload";
    /** Whether the flag was successful. */
    success: Scalars["Boolean"];
    /** The updated accounts. */
    accounts: Array<GqAccount>;
};
export declare type GqInternalFactKnowledgeNodeDetails = {
    __typename?: "InternalFactKnowledgeNodeDetails";
    /** The unique identifier of the associated fact. */
    factId: Scalars["Uuid"];
    /** The unique identifier of the mem associated to this fact. */
    associatedMemId: Scalars["Uuid"];
    /** The content associated with the fact in different formats. */
    content: Maybe<GqFactKnowledgeNodeContent>;
    /** The type of the fact.  E.g. numeric, email, url, etc ... */
    type: GqFactType;
};
export declare type GqInternalFindOrImportAccountFromFirebaseAuthInput = {
    /** The firebaseAuthEmail of the target firestore-user. */
    firebaseAuthEmail: Scalars["String"];
};
export declare type GqInternalFindOrImportAccountFromFirebaseAuthPayload = {
    __typename?: "InternalFindOrImportAccountFromFirebaseAuthPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The account which was found-or-imported. */
    account: GqAccount;
};
export declare type GqInternalFindOrImportAccountFromFirestoreUserInput = {
    /** The firestoreUserId of the target firestore-user. */
    firestoreUserId: Scalars["String"];
};
export declare type GqInternalFindOrImportAccountFromFirestoreUserPayload = {
    __typename?: "InternalFindOrImportAccountFromFirestoreUserPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The account which was found-or-imported. */
    account: GqAccount;
};
export declare type GqInternalFindOrImportMemFromFirestoreNoteInput = {
    /** The id of the target firestore-note. */
    firestoreNoteId: Scalars["String"];
};
export declare type GqInternalFindOrImportMemFromFirestoreNotePayload = {
    __typename?: "InternalFindOrImportMemFromFirestoreNotePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The mem which was found-or-imported. */
    mem: GqMem;
};
export declare type GqInternalGetAllFeatureTogglesPayload = {
    __typename?: "InternalGetAllFeatureTogglesPayload";
    /** All the feature toggles that exist. */
    featureToggles: Array<GqFeatureToggleSlug>;
};
export declare type GqInternalIndexAccountUsingFirestoreUserIdInput = {
    /** The identifier for the firestore user id. */
    firestoreUserId: Scalars["String"];
};
export declare type GqInternalIndexAccountUsingFirestoreUserIdPayload = {
    __typename?: "InternalIndexAccountUsingFirestoreUserIdPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalIndexAllMemsForAccountInput = {
    /** The identifier for an associated account. */
    accountId: Scalars["Uuid"];
};
export declare type GqInternalIndexAllMemsForAccountPayload = {
    __typename?: "InternalIndexAllMemsForAccountPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalIndexGroupUsingFirestoreGroupIdInput = {
    /** The identifier for the firestore group. */
    firestoreGroupId: Scalars["String"];
};
export declare type GqInternalIndexGroupUsingFirestoreGroupIdPayload = {
    __typename?: "InternalIndexGroupUsingFirestoreGroupIdPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalIndexMemUsingFirestoreNoteIdInput = {
    /** The identifier for the firestore note id. */
    firestoreNoteId: Scalars["String"];
};
export declare type GqInternalIndexMemUsingFirestoreNoteIdPayload = {
    __typename?: "InternalIndexMemUsingFirestoreNoteIdPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalKnowledgeNodeDetails = {
    __typename?: "InternalKnowledgeNodeDetails";
    /** The internal object ID required by our search system. */
    objectId: Scalars["String"];
    /** The internal index version set by our search system. */
    indexVersion: Scalars["Int"];
    /** The index-at time version set by our search system. */
    indexedAt: Scalars["DateTime"];
    /**
     * The kind of knowledge node (Mem, Account, ...).
     * Used internally to resolve which kind of node should be returned.
     * Clients shouldn't use this - they should use the __typename instead.
     */
    knowledgeNodeKind: Scalars["String"];
    /** The created-at time of the associated entity. */
    createdAt: Scalars["DateTime"];
    /** The edited-at time of the associated entity. */
    editedAt: Scalars["DateTime"];
};
export declare type GqInternalMemKnowledgeNodeDetails = {
    __typename?: "InternalMemKnowledgeNodeDetails";
    /**
     * The unique identifier of the associated firestore note.
     * (Fetching data for these notes should be done as a separate query.)
     */
    firestoreNoteId: Maybe<Scalars["String"]>;
    /** The list of accounts permitted to view the mem knowledge node. */
    permittedAccountIds: Array<Scalars["Uuid"]>;
    /** The list of users permitted to view the mem knowledge node. */
    permittedFirestoreUserIds: Array<Scalars["String"]>;
    /** A list of account-ids which have the mem in their inbox. */
    isInInboxForAccounts: Array<Scalars["Uuid"]>;
    /** A list of account-ids which have the mem in their trash. */
    isInTrashForAccounts: Array<Scalars["Uuid"]>;
    /** A list of account-ids which have the mem on unread. */
    isUnreadForAccounts: Array<Scalars["Uuid"]>;
    /** The searchable plaintext used search system. Optional. */
    searchablePlaintext: Maybe<Scalars["String"]>;
    /**
     * The unique identifier of the associated mem.
     * (Fetching data for these mems should be done as a separate query.)
     */
    memId: Scalars["Uuid"];
    /** The topics associated with the associated mem. */
    topics: Array<GqTopic>;
    /** The content associated with the mem in different formats. */
    content: GqKnowledgeNodeContent;
};
export declare type GqInternalMemTemplateKnowledgeNodeDetails = {
    __typename?: "InternalMemTemplateKnowledgeNodeDetails";
    /** The unique identifier of the associated firestore template. */
    firestoreTemplateId: Maybe<Scalars["String"]>;
    /** The list of accounts permitted to view the mem template knowledge node. */
    permittedAccountIds: Array<Scalars["Uuid"]>;
    /** The list of users permitted to view the mem template knowledge node. */
    permittedFirestoreUserIds: Array<Scalars["String"]>;
    /** The searchable plaintext used in the search system. Optional. */
    searchablePlaintext: Maybe<Scalars["String"]>;
    /**
     * The unique identifier of the associated mem template.
     * (Fetching data for these mem templates should be done as a separate query.)
     */
    memTemplateId: Scalars["Uuid"];
    /** The content associated with the mem template in different formats. */
    content: GqKnowledgeNodeContent;
};
export declare type GqInternalMigrateAccountToNewEmailInput = {
    /** The id of the account which should be updated. */
    accountId: Scalars["Uuid"];
    /** The new email address which the account should be associated with. */
    email: Scalars["String"];
};
export declare type GqInternalMigrateAccountToNewEmailPayload = {
    __typename?: "InternalMigrateAccountToNewEmailPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The updated account. */
    account: GqAccount;
};
/**
 * The input type used when processing cloud tasks.
 * Note that the inputs are a union of all possible input types.
 * (CloudTaskAArgs U CloudTaskBArgs U CloudTaskCArgs U ...)
 */
export declare type GqInternalProcessCloudTaskInput = {
    /** The kind of cloud task which should be processed. */
    kind: GqCloudTaskKind;
    /** A value which can be provided for health-check purposes. */
    healthCheckValue: Maybe<Scalars["String"]>;
    /** The identifier for an associated account. */
    accountId: Maybe<Scalars["Uuid"]>;
    /** The identifier for an associated mem. */
    memId: Maybe<Scalars["Uuid"]>;
    /** The identifier for an associated group. */
    groupId: Maybe<Scalars["Uuid"]>;
    /** The identifier for an associated firestore note. */
    firestoreNoteId: Maybe<Scalars["String"]>;
    /** The identifier for an associated firestore user. */
    firestoreUserId: Maybe<Scalars["String"]>;
    /** The slug representing the kind of tracked event. */
    trackedEventSlug: Maybe<GqTrackedEventSlug>;
    /** The DateTime which the event was tracked at. */
    trackedEventDateTime: Maybe<Scalars["DateTime"]>;
    /**
     * Info associated with the tracked event.
     * In the JSON format.
     */
    trackedEventInfoJson: Maybe<Scalars["String"]>;
    /** An account id associated with the tracked event. */
    associatedAccountId: Maybe<Scalars["Uuid"]>;
    /** The start date to index mems which have a created date on/and after this specified date */
    startDate: Maybe<Scalars["DateTime"]>;
    /** The end date to index mems which have a created date on/and before this specified date */
    endDate: Maybe<Scalars["DateTime"]>;
    /** The date for when users should be notified for a particular notification. */
    notifyStart: Maybe<Scalars["DateTime"]>;
    /** The date for when users should stop being notified (assuming they haven't closed the notification yet). */
    notifyEnd: Maybe<Scalars["DateTime"]>;
    /** The identifier for a particular notification. */
    notificationId: Maybe<Scalars["String"]>;
    /** The limit of the batch of records to process. */
    batchLimit: Maybe<Scalars["Int"]>;
    /** The amount of records to skip on the current batch to process. */
    batchOffset: Maybe<Scalars["Int"]>;
    /** The firestore ids to be backfilled */
    firestoreIds: Maybe<Array<Scalars["String"]>>;
    /** The mem ids to be backfilled */
    memIds: Maybe<Array<Scalars["String"]>>;
    /** The identifier for an associated firestore template. */
    firestoreTemplateId: Maybe<Scalars["String"]>;
    /** The identifier for an associated batch import. */
    importBatchId: Maybe<Scalars["Uuid"]>;
    /** The identifier for an associated import task. */
    importTaskId: Maybe<Scalars["Uuid"]>;
    /** A boolean marking if the associated task is a backfill task. */
    isBackfillTask: Maybe<Scalars["Boolean"]>;
    /** A UUID associated with the parent cloud task.  (Used to track child processes) */
    trackingId: Maybe<Scalars["String"]>;
};
export declare type GqInternalProcessCloudTaskPayload = {
    __typename?: "InternalProcessCloudTaskPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalReindexAllMemsPayload = {
    __typename?: "InternalReindexAllMemsPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalReprocessMemEntityInput = {
    /** The uuid of the target mem. */
    memId: Scalars["Uuid"];
};
export declare type GqInternalReprocessMemEntityPayload = {
    __typename?: "InternalReprocessMemEntityPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalReprocessMemEntityUsingFirestoreNoteIdInput = {
    /** The identifier for the firestore note id. */
    firestoreNoteId: Scalars["String"];
    /** The identifier for an associated account. */
    accountId: Scalars["Uuid"];
};
export declare type GqInternalReprocessMemEntityUsingFirestoreNoteIdPayload = {
    __typename?: "InternalReprocessMemEntityUsingFirestoreNoteIdPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalReprocessMemTemplateEntityUsingFirestoreTemplateIdInput = {
    /** The identifier for the firestore template id. */
    firestoreTemplateId: Scalars["String"];
};
export declare type GqInternalReprocessMemTemplateEntityUsingFirestoreTemplateIdPayload = {
    __typename?: "InternalReprocessMemTemplateEntityUsingFirestoreTemplateIdPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalRunAdminFunctionInput = {
    /** The identifier for the firestore note id. */
    adminFunctionName: GqAdminFunctionName;
};
export declare type GqInternalRunAdminFunctionPayload = {
    __typename?: "InternalRunAdminFunctionPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** A UUID associated with the admin function.  (Used to track child processes) */
    trackingId: Maybe<Scalars["String"]>;
};
export declare type GqInternalSearchAccountApiKeysFilters = {
    /** Include API Keys which belong to the target account. */
    accountId: Maybe<Scalars["Uuid"]>;
    /** Include API Keys which have been revoked. */
    includeRevoked: Maybe<Scalars["Boolean"]>;
};
export declare type GqInternalSearchAccountsFilters = {
    /** Include Accounts which are related to the queryString. */
    queryString: Maybe<Scalars["String"]>;
};
export declare type GqInternalSearchKnowledgeGraphFilters = {
    /** The query string. */
    queryString: Maybe<Scalars["String"]>;
    /** Filter by mems which the target account has access to. */
    accountId: Maybe<Scalars["Uuid"]>;
    /** Facets which should be exposed by the search. */
    filterableFacetKinds: Maybe<Array<GqKnowledgeGraphFacetKind>>;
    /** The facet and value of the facet to filter by. */
    facetFilters: Maybe<Array<GqKnowledgeGraphFacetFilter>>;
    /** The kinds of entities to be retrieved by the search. */
    entityKindsToRetrieve: Maybe<Array<GqKnowledgeNodeSearchObjectKind>>;
};
export declare type GqInternalSearchWorkspacesFilters = {
    /** Include Workspaces which are related to the queryString. */
    queryString: Maybe<Scalars["String"]>;
};
export declare type GqInternalSendSearchAnalyticsInput = {
    /** The identifier for an associated account. */
    accountId: Scalars["Uuid"];
    /**
     * The name of the analytic event.
     *
     * @todo we should make this an enum.
     */
    eventName: Scalars["String"];
    /** The identifiers of the entities that were clicked. */
    entityIds: Array<Scalars["Uuid"]>;
    /** The identifier for the specified query */
    queryId: Maybe<Scalars["String"]>;
};
export declare type GqInternalSendSearchAnalyticsPayload = {
    __typename?: "InternalSendSearchAnalyticsPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqInternalTransitoryKnowledgeGraphFilters = {
    /** The query string. */
    queryString: Maybe<Scalars["String"]>;
    /** Filter by mems which the target account has access to. */
    accountId: Maybe<Scalars["Uuid"]>;
    /** Facets which should be exposed by the search. */
    filterableFacetKinds: Maybe<Array<GqKnowledgeGraphFacetKind>>;
    /** The facet and value of the facet to filter by. */
    facetFilters: Maybe<Array<GqKnowledgeGraphFacetFilter>>;
    /** The kinds of entities to be retrieved by the search. */
    entityKindsToRetrieve: Maybe<Array<GqKnowledgeNodeSearchObjectKind>>;
};
/** We can add more types here in the future. */
export declare type GqItemWithScore = GqMemWithScore;
/** Extra filterable facets @todo, find a better way to do this */
export declare enum GqKnowledgeGraphAttributesForFaceting {
    PermittedFirestoreUserIds = "permittedFirestoreUserIds",
    PermittedFirestoreUserIdsString = "permittedFirestoreUserIdsString"
}
export declare type GqKnowledgeGraphFacet = {
    __typename?: "KnowledgeGraphFacet";
    /** The kind of search facet that the values are associated with. */
    kind: GqKnowledgeGraphFacetKind;
    /** The display name used for the kind of search facet. */
    displayName: Scalars["String"];
    /** The related values for the search facet. */
    values: Array<Scalars["AnyJsonValue"]>;
};
export declare type GqKnowledgeGraphFacetFilter = {
    /** Facet to filter with. */
    kind: GqKnowledgeGraphFacetKind;
    /** Whether to exclude the records with the facet value.  Setting to true will return records that do NOT have the specified facet value. */
    exclude: Maybe<Scalars["Boolean"]>;
    /** The value to filter by for the particular facet. */
    value: Scalars["AnyJsonValue"];
};
/** Filterable facets for our knowledge graph. */
export declare enum GqKnowledgeGraphFacetKind {
    KnowledgeNodeKind = "KNOWLEDGE_NODE_KIND",
    TopicLabels = "TOPIC_LABELS",
    PermittedGroups = "PERMITTED_GROUPS",
    EditedByUsers = "EDITED_BY_USERS",
    LinkKinds = "LINK_KINDS",
    MediaKinds = "MEDIA_KINDS",
    CapturedWithSources = "CAPTURED_WITH_SOURCES",
    IsInInboxForAccounts = "IS_IN_INBOX_FOR_ACCOUNTS",
    IsInTrashForAccounts = "IS_IN_TRASH_FOR_ACCOUNTS",
    IsUnreadForAccounts = "IS_UNREAD_FOR_ACCOUNTS",
    CreatedByAccount = "CREATED_BY_ACCOUNT",
    PermittedFirestoreGroupsAndUsers = "PERMITTED_FIRESTORE_GROUPS_AND_USERS",
    LastEditedByAccountId = "LAST_EDITED_BY_ACCOUNT_ID"
}
export declare type GqKnowledgeGraphFacetsLimitOffsetConnection = {
    __typename?: "KnowledgeGraphFacetsLimitOffsetConnection";
    /** A list of nodes. */
    nodes: Array<GqKnowledgeNodeFacet>;
    /** Information to aid in pagination. */
    pageInfo: GqLimitOffsetPageInfo;
    /** Identifies the total count of items in the connection. */
    totalCount: Scalars["Int"];
};
/**
 * The limit-offset-connection type for KnowledgeGraphNode.
 * @deprecated(reason: "Use KnowledgeNodesLimitOffsetConnection instead.")
 */
export declare type GqKnowledgeGraphLimitOffsetConnection = {
    __typename?: "KnowledgeGraphLimitOffsetConnection";
    /** A list of nodes. */
    nodes: Array<GqKnowledgeNode>;
    /** Information to aid in pagination. */
    pageInfo: GqLimitOffsetPageInfo;
    /** Identifies the total count of items in the connection. */
    totalCount: Scalars["Int"];
    /** Extra information related to the current search. */
    searchInfo: GqKnowledgeGraphSearchInfo;
};
export declare enum GqKnowledgeGraphRecommendedActionType {
    OpenMem = "OPEN_MEM"
}
export declare type GqKnowledgeGraphRecommendedNodes = {
    __typename?: "KnowledgeGraphRecommendedNodes";
    /** A recommended node */
    node: GqKnowledgeNode;
    /** The label explaining where the recommendation comes from. */
    label: Scalars["String"];
    /** The action related to the node */
    actionType: GqKnowledgeGraphRecommendedActionType;
};
/** @deprecated(reason: "Use KnowledgeNodesSearchInfo instead.") */
export declare type GqKnowledgeGraphSearchInfo = {
    __typename?: "KnowledgeGraphSearchInfo";
    /** A unique identifier for the query. */
    queryId: Scalars["String"];
    /** Facets */
    facets: Array<GqKnowledgeGraphFacet>;
};
export declare type GqKnowledgeNode = GqMemKnowledgeNode | GqAccountKnowledgeNode | GqMemTemplateKnowledgeNode | GqFactKnowledgeNode;
/**
 * In the future, we should consider turning this into a union type with "common topics", "mentions the word", ...
 * @deprecated - "Use KnowledgeNodePivot instead."
 */
export declare type GqKnowledgeNodeCategory = {
    __typename?: "KnowledgeNodeCategory";
    /** The primary label of the category - used for displaying search results. */
    primaryLabel: Scalars["String"];
    /** Search for related knowledge nodes. */
    searchKnowledgeNodes: GqKnowledgeNodesLimitOffsetConnection;
};
/**
 * In the future, we should consider turning this into a union type with "common topics", "mentions the word", ...
 * @deprecated - "Use KnowledgeNodePivot instead."
 */
export declare type GqKnowledgeNodeCategorySearchKnowledgeNodesArgs = {
    limit: Maybe<Scalars["Int"]>;
    offset: Maybe<Scalars["Int"]>;
};
/**
 * The limit-offset-connection type for KnowledgeGraphNode.
 * @deprecated - "Use KnowledgeNodePivotLimitOffsetConnection instead."
 */
export declare type GqKnowledgeNodeCategoryLimitOffsetConnection = {
    __typename?: "KnowledgeNodeCategoryLimitOffsetConnection";
    /** A list of nodes. */
    nodes: Array<GqKnowledgeNodeCategory>;
    /** Information to aid in pagination. */
    pageInfo: GqLimitOffsetPageInfo;
    /** Identifies the total count of items in the connection. */
    totalCount: Scalars["Int"];
};
export declare type GqKnowledgeNodeContent = {
    __typename?: "KnowledgeNodeContent";
    /** Content in the `Rich Text Delta` format. */
    richTextDocument: Scalars["RichTextDocument"];
    /** Content in the plaintext format. */
    plaintext: Scalars["String"];
    /** Content in the rich-clipboard style format. */
    htmlString: Scalars["String"];
};
export declare type GqKnowledgeNodeFacet = {
    __typename?: "KnowledgeNodeFacet";
    /** The primary label - used for displaying search results. */
    primaryLabel: Scalars["String"];
};
export declare type GqKnowledgeNodePivot = GqTopicKnowledgeNodePivot | GqSimilarItemsKnowledgeNodePivot;
/** The limit-offset-connection type for KnowledgeNodePivotLimitOffsetConnection. */
export declare type GqKnowledgeNodePivotLimitOffsetConnection = {
    __typename?: "KnowledgeNodePivotLimitOffsetConnection";
    /** A list of nodes. */
    nodes: Array<GqKnowledgeNodePivot>;
    /** Information to aid in pagination. */
    pageInfo: GqLimitOffsetPageInfo;
    /** Identifies the total count of items in the connection. */
    totalCount: Scalars["Int"];
};
export declare enum GqKnowledgeNodeSearchObjectKind {
    Mem = "MEM",
    Account = "ACCOUNT",
    Group = "GROUP",
    MemTemplate = "MEM_TEMPLATE",
    Fact = "FACT"
}
/** The limit-offset-connection type for KnowledgeGraphNode. */
export declare type GqKnowledgeNodesLimitOffsetConnection = {
    __typename?: "KnowledgeNodesLimitOffsetConnection";
    /** A list of nodes. */
    nodes: Array<GqKnowledgeNode>;
    /** Information to aid in pagination. */
    pageInfo: GqLimitOffsetPageInfo;
    /** Identifies the total count of items in the connection. */
    totalCount: Scalars["Int"];
};
export declare type GqLimitOffsetPageInfo = {
    __typename?: "LimitOffsetPageInfo";
    /** When paginating forwards, the offset to start with. */
    endOffset: Maybe<Scalars["Int"]>;
    /** When paginating backwards, the offset to end with. */
    startOffset: Maybe<Scalars["Int"]>;
    /** When paginating forwards, are there more items? */
    hasNextPage: Scalars["Boolean"];
    /** When paginating backwards, are there more items? */
    hasPreviousPage: Scalars["Boolean"];
};
/** A mem - our standard Rich-Text-Document entity. */
export declare type GqMem = GqNode & {
    __typename?: "Mem";
    /** The unique identifier of the entity. */
    id: Scalars["Uuid"];
    /**
     * The url of the mem page.
     *
     * Example:
     *   - https://mem.ai/m/abcdefghij0123456789
     *
     * Note that the mem's note identifier may be different from the mem's id.
     */
    url: Scalars["String"];
    /** The title of the mem. */
    title: Scalars["String"];
    /** The tagline of the mem. */
    tagline: Scalars["String"];
    /** The topics associated with the mem. */
    topics: Array<GqTopic>;
    /** The content of the mem in different formats. */
    content: GqMemContent;
    /**
     * The related firestore note.
     * It may not always exist (so it is nullable).
     */
    firestoreNote: Maybe<GqFirestoreNote>;
    /**
     * The last time the note was edited.
     * (Note that this is different than a generic "updatedAt" time)
     */
    editedAt: Scalars["DateTime"];
    /**
     * Metadata related to the note.
     * Used for optimized rendering purposes on the client.
     */
    metadata: GqMemMetadata;
    /** Mems mentioned inside the content. */
    mentionedMems: Array<GqMem>;
    /**
     * Search knowledge node categories.
     * @deprecated - "Use searchKnowledgeNodePivots instead."
     * @deprecated Use searchKnowledgeNodePivots instead.
     */
    searchKnowledgeNodeCategories: GqKnowledgeNodeCategoryLimitOffsetConnection;
    /** Search knowledge node categories. */
    searchKnowledgeNodePivots: GqKnowledgeNodePivotLimitOffsetConnection;
    /** The comment threads associated with the mem. */
    commentThreads: Array<GqCommentThread>;
};
/** A mem - our standard Rich-Text-Document entity. */
export declare type GqMemSearchKnowledgeNodeCategoriesArgs = {
    limit: Maybe<Scalars["Int"]>;
    offset: Maybe<Scalars["Int"]>;
};
/** A mem - our standard Rich-Text-Document entity. */
export declare type GqMemSearchKnowledgeNodePivotsArgs = {
    limit: Maybe<Scalars["Int"]>;
    offset: Maybe<Scalars["Int"]>;
};
export declare type GqMemAccountFavoriteItem = GqGenericAccountFavoriteItem & {
    __typename?: "MemAccountFavoriteItem";
    /** String describing the item. */
    label: Scalars["String"];
    /** The item value. */
    value: GqMem;
};
export declare type GqMemContent = {
    __typename?: "MemContent";
    /** Content in the `Rich Text Delta` format. */
    richTextDocument: Scalars["RichTextDocument"];
    /** Content in a JSON-ified quill delta format (encoded as a string). */
    quillDeltaJson: Scalars["String"];
    /** Content in a JSON-ified quill delta format. */
    quillDeltaJsonObject: Scalars["AnyJsonObject"];
    /** Content in a stringified markdown format. */
    markdown: Scalars["String"];
    /**
     * The version of the mem's content.
     * Used for syncing.
     */
    version: Scalars["Int"];
};
export declare enum GqMemCreationImportSourceKind {
    Notion = "Notion",
    Obsidian = "Obsidian",
    Markdown = "Markdown",
    Roam = "Roam",
    AppleNotes = "AppleNotes",
    Bear = "Bear",
    IaWriter = "IAWriter",
    Evernote = "Evernote"
}
export declare enum GqMemCreationSourceKind {
    App = "App",
    Import = "Import",
    Sms = "Sms",
    Api = "API",
    Unknown = "Unknown"
}
/** This is deprecated, and should no longer be used. */
export declare enum GqMemFormat {
    Markdown = "MARKDOWN"
}
export declare type GqMemKnowledgeNode = GqGenericKnowledgeNode & {
    __typename?: "MemKnowledgeNode";
    /** Internal mem-specific details related to the knowledge node. */
    internalKnowledgeNodeDetails: GqInternalKnowledgeNodeDetails;
    /** Internal mem-specific details related to the search system. */
    internalMemKnowledgeNodeDetails: GqInternalMemKnowledgeNodeDetails;
    /** The primary label - used for displaying search results. */
    primaryLabel: Scalars["String"];
    /** The secondary label - used for displaying search results. Optional. */
    secondaryLabel: Maybe<Scalars["String"]>;
    /**
     * The unique identifier of the associated mem.
     * (Fetching data for these mems should be done as a separate query.)
     */
    memId: Scalars["Uuid"];
    /** The topics associated with the associated mem. */
    topics: Array<GqTopic>;
    /** The created-at time of the associated mem. */
    createdAt: Scalars["DateTime"];
    /** The edited-at time of the associated mem. */
    editedAt: Scalars["DateTime"];
};
export declare type GqMemMetadata = {
    __typename?: "MemMetadata";
    /** A list of display names which are associated with the note's authors. */
    authorProfileDisplayNames: Array<Scalars["String"]>;
    /** A label containing authors and creation date. */
    authorsLabel: Scalars["String"];
};
export declare type GqMemSimilarItem = GqGenericSimilarItem & {
    __typename?: "MemSimilarItem";
    /** The similarity score between this mem and the query mem. */
    score: Scalars["Float"];
    /** The associated MemKnowledgeNode. */
    value: GqMemKnowledgeNode;
};
export declare type GqMemTemplateKnowledgeNode = GqGenericKnowledgeNode & {
    __typename?: "MemTemplateKnowledgeNode";
    /** Internal mem template-specific details related search system. */
    internalKnowledgeNodeDetails: GqInternalKnowledgeNodeDetails;
    /** Internal mem template-specific details related to the search system. */
    internalMemTemplateKnowledgeNodeDetails: GqInternalMemTemplateKnowledgeNodeDetails;
    /** The primary label - used for displaying search results. */
    primaryLabel: Scalars["String"];
    /** The secondary label - used for displaying search results. Optional. */
    secondaryLabel: Maybe<Scalars["String"]>;
    /** The created-at time of the associated mem template. */
    createdAt: Scalars["DateTime"];
    /** The edited-at time of the associated mem template. */
    editedAt: Scalars["DateTime"];
};
export declare type GqMemWithScore = GqGenericItemWithScore & {
    __typename?: "MemWithScore";
    /** The similarity score between this mem and the query mem. */
    score: Scalars["Float"];
    /** The associated MemKnowledgeNode. */
    value: GqMemKnowledgeNode;
};
export declare type GqMutation = {
    __typename?: "Mutation";
    /** Create a new Account API key. */
    createAccountApiKey: GqCreateAccountApiKeyPayload;
    /** Updates an existing Account API key's details. */
    updateAccountApiKeyDetails: GqUpdateAccountApiKeyDetailsPayload;
    /** Revoke an existing Account API Key. */
    revokeAccountApiKey: GqRevokeAccountApiKeyPayload;
    /**
     * Update an account's details.
     *
     * Right now you can only modify the account's profile picture.
     */
    updateAccountDetails: GqUpdateAccountDetailsPayload;
    /** Update the location policy. */
    updateAccountPreferences: GqUpdateAccountPreferencesPayload;
    /** Add a favorite item to the current account. */
    addAccountFavoriteItem: GqAddAccountFavoriteItemPayload;
    /** Delete a favorite item from the current account. */
    deleteAccountFavoriteItem: GqDeleteAccountFavoriteItemPayload;
    /** Authenticate using an email and password. */
    authenticateAccountUsingEmailPassword: GqAuthenticateUsingEmailPasswordPayload;
    /** Authenticate using a Google OAuth code from various clients. */
    authenticateAccountUsingGoogleOAuthCode: GqAuthenticateAccountUsingGoogleOAuthCodePayload;
    _empty: Maybe<Scalars["String"]>;
    /** Create a new Mem. */
    createMem: GqCreateMemPayload;
    /** Create a new Mem. */
    batchCreateMems: Array<GqCreateMemPayload>;
    /** Appends to an existing mem. */
    appendToMemContent: GqAppendToMemContentPayload;
    /** Appends to a batch of existing mems. */
    batchAppendToMemContent: Array<GqAppendToMemContentPayload>;
    /** Syncs a mem's updated content with an existing mem. */
    syncMemContent: GqSyncMemContentPayload;
    /** Transform's a mem's content by applying some operations. */
    transformMemContent: GqTransformMemContentPayload;
    /** Delete a mem. */
    softDeleteMem: GqSoftDeleteMemPayload;
    /** Save to mem(MemIt). */
    saveToMem: GqSaveToMemPayload;
    /** Import mems. */
    importMems: GqImportMemsPayload;
    /** Given a firebase-auth's details, we find or import the corresponding account. */
    internalFindOrImportAccountFromFirebaseAuth: GqInternalFindOrImportAccountFromFirebaseAuthPayload;
    /**
     * Archives the account, then "hard-deletes" all of the
     * associated models/objects. (firebase user, etc.)
     *
     * Irrecoverable.
     */
    internalCloseAccount: GqInternalCloseAccountPayload;
    /** Processes a client event based on its kind */
    recordClientEvent: GqRecordClientEventPayload;
    /** Processes a client event based on its kind */
    internalProcessCloudTask: GqInternalProcessCloudTaskPayload;
    /** Given a firebase-note's details, we find or import the corresponding mem. */
    internalFindOrImportMemFromFirestoreNote: GqInternalFindOrImportMemFromFirestoreNotePayload;
    /** Re-pr */
    internalReprocessMemEntity: GqInternalReprocessMemEntityPayload;
    /** Re-pr */
    internalReprocessMemEntityUsingFirestoreNoteId: GqInternalReprocessMemEntityUsingFirestoreNoteIdPayload;
    /** Enables a feature toggle for an account. */
    internalEnableAccountFeatureToggle: GqInternalEnableAccountFeatureTogglePayload;
    /** Disables a feature toggle for an account. */
    internalDisableAccountFeatureToggle: GqInternalDisableAccountFeatureTogglePayload;
    /** Indexes a mem using a firestore note id. */
    internalIndexMemUsingFirestoreNoteId: GqInternalIndexMemUsingFirestoreNoteIdPayload;
    /**
     * Reprocess the target mem entity associated to the provided
     * firestore note.
     */
    transitoryReprocessMemEntityUsingFirestoreNoteId: GqTransitoryReprocessMemEntityUsingFirestoreNoteIdPayload;
    /** Indexes all mems for an account. */
    internalIndexAllMemsForAccount: GqInternalIndexAllMemsForAccountPayload;
    /** Create a notification for a particular user. */
    internalCreateUserAppNotification: GqInternalCreateUserAppNotificationPayload;
    /** Create an app notification with the provided input. */
    internalCreateVersionLaunchShowcaseAppNotification: GqInternalCreateVersionLaunchShowcaseAppNotificationPayload;
    /** Create a version launch showcase notification for all users. */
    internalCreateUserAppNotificationForAllUsers: GqInternalCreateUserAppNotificationForAllUsersPayload;
    /** Search the knowledge graph associated with the account. */
    internalCacheSet: GqCacheSetResults;
    /** Indexes all mems. */
    internalReindexAllMems: GqInternalReindexAllMemsPayload;
    internalRunAdminFunction: GqInternalRunAdminFunctionPayload;
    /** Given a firebase-note's id, we archive the note */
    internalArchiveMem: GqInternalArchiveMemPayload;
    /** Sends analytics events to Algolia. */
    internalSendSearchAnalytics: GqInternalSendSearchAnalyticsPayload;
    /** Migrate an account to a new email address. */
    internalMigrateAccountToNewEmail: GqInternalMigrateAccountToNewEmailPayload;
    /** Update a mem's AccountInboxDetails. */
    updateAccountMemInboxDetails: GqUpdateAccountMemInboxDetailsPayload;
    /** Indexes an account using a firestore user id. */
    internalIndexAccountUsingFirestoreUserId: GqInternalIndexAccountUsingFirestoreUserIdPayload;
    /** Indexes a group using a group id. */
    internalIndexGroupUsingFirestoreGroupId: GqInternalIndexGroupUsingFirestoreGroupIdPayload;
    /** Upload a file to the server. */
    uploadFile: GqUploadFilePayload;
    /** Re-pr */
    internalReprocessMemTemplateEntityUsingFirestoreTemplateId: GqInternalReprocessMemTemplateEntityUsingFirestoreTemplateIdPayload;
    /**
     * Index the target mem entity associated to the provided
     * firestore note.
     */
    transitoryIndexMemEntityUsingFirestoreNoteId: GqTransitoryIndexMemEntityUsingFirestoreNoteIdPayload;
    /** Given a firestore user's details, we find or import the corresponding account. */
    internalFindOrImportAccountFromFirestoreUser: GqInternalFindOrImportAccountFromFirestoreUserPayload;
    /** Given a firebase-note's id, we update the mem's trash state in the search service */
    internalUpdateMemTrashState: GqInternalUpdateMemTrashStatePayload;
    /**
     * Reprocess the target account entity associated to the provided
     * firestore user.
     */
    transitoryReprocessAccountEntityUsingFirestoreUserId: GqTransitoryReprocessAccountEntityUsingFirestoreUserIdPayload;
    /** Given a firebase-account's id, we archive the account */
    internalArchiveAccount: GqInternalArchiveAccountPayload;
    /** Creates a new workspace. */
    createWorkspace: GqCreateWorkspacePayload;
    /** Delete all mems associated with an AccountBatchImport. */
    deleteAccountBatchImportMems: GqDeleteAccountBatchImportMemsPayload;
    /** Enables the feature flag for all the members with a certain email domain */
    internalEnableFeatureToggleForAllAccountWithEmailDomain: GqInternalEnableFeatureToggleForAllAccountWithEmailDomainPayload;
};
export declare type GqMutationCreateAccountApiKeyArgs = {
    input: GqCreateAccountApiKeyInput;
};
export declare type GqMutationUpdateAccountApiKeyDetailsArgs = {
    input: GqUpdateAccountApiKeyDetailsInput;
};
export declare type GqMutationRevokeAccountApiKeyArgs = {
    input: GqRevokeAccountApiKeyInput;
};
export declare type GqMutationUpdateAccountDetailsArgs = {
    input: GqUpdateAccountDetailsInput;
};
export declare type GqMutationUpdateAccountPreferencesArgs = {
    input: GqUpdateAccountPreferencesInput;
};
export declare type GqMutationAddAccountFavoriteItemArgs = {
    input: GqAddAccountFavoriteItemInput;
};
export declare type GqMutationDeleteAccountFavoriteItemArgs = {
    input: GqDeleteAccountFavoriteItemInput;
};
export declare type GqMutationAuthenticateAccountUsingEmailPasswordArgs = {
    input: GqAuthenticateUsingEmailPasswordInput;
};
export declare type GqMutationAuthenticateAccountUsingGoogleOAuthCodeArgs = {
    input: GqAuthenticateAccountUsingGoogleOAuthCodeInput;
};
export declare type GqMutationCreateMemArgs = {
    input: GqCreateMemInput;
};
export declare type GqMutationBatchCreateMemsArgs = {
    inputs: Array<GqCreateMemInput>;
};
export declare type GqMutationAppendToMemContentArgs = {
    input: GqAppendToMemContentInput;
};
export declare type GqMutationBatchAppendToMemContentArgs = {
    inputs: Array<GqAppendToMemContentInput>;
};
export declare type GqMutationSyncMemContentArgs = {
    input: GqSyncMemContentInput;
};
export declare type GqMutationTransformMemContentArgs = {
    input: GqTransformMemContentInput;
};
export declare type GqMutationSoftDeleteMemArgs = {
    input: GqSoftDeleteMemInput;
};
export declare type GqMutationSaveToMemArgs = {
    input: GqSaveToMemInput;
};
export declare type GqMutationImportMemsArgs = {
    input: GqImportMemsInput;
};
export declare type GqMutationInternalFindOrImportAccountFromFirebaseAuthArgs = {
    input: GqInternalFindOrImportAccountFromFirebaseAuthInput;
};
export declare type GqMutationInternalCloseAccountArgs = {
    input: GqInternalCloseAccountInput;
};
export declare type GqMutationRecordClientEventArgs = {
    input: GqRecordClientEventInput;
};
export declare type GqMutationInternalProcessCloudTaskArgs = {
    input: GqInternalProcessCloudTaskInput;
};
export declare type GqMutationInternalFindOrImportMemFromFirestoreNoteArgs = {
    input: GqInternalFindOrImportMemFromFirestoreNoteInput;
};
export declare type GqMutationInternalReprocessMemEntityArgs = {
    input: GqInternalReprocessMemEntityInput;
};
export declare type GqMutationInternalReprocessMemEntityUsingFirestoreNoteIdArgs = {
    input: GqInternalReprocessMemEntityUsingFirestoreNoteIdInput;
};
export declare type GqMutationInternalEnableAccountFeatureToggleArgs = {
    input: GqInternalEnableAccountFeatureToggleInput;
};
export declare type GqMutationInternalDisableAccountFeatureToggleArgs = {
    input: GqInternalDisableAccountFeatureToggleInput;
};
export declare type GqMutationInternalIndexMemUsingFirestoreNoteIdArgs = {
    input: GqInternalIndexMemUsingFirestoreNoteIdInput;
};
export declare type GqMutationTransitoryReprocessMemEntityUsingFirestoreNoteIdArgs = {
    input: GqTransitoryReprocessMemEntityUsingFirestoreNoteIdInput;
};
export declare type GqMutationInternalIndexAllMemsForAccountArgs = {
    input: GqInternalIndexAllMemsForAccountInput;
};
export declare type GqMutationInternalCreateUserAppNotificationArgs = {
    input: GqInternalCreateUserAppNotificationInput;
};
export declare type GqMutationInternalCreateVersionLaunchShowcaseAppNotificationArgs = {
    input: GqInternalCreateVersionLaunchShowcaseAppNotificationInput;
};
export declare type GqMutationInternalCreateUserAppNotificationForAllUsersArgs = {
    input: GqInternalCreateUserAppNotificationForAllUsersInput;
};
export declare type GqMutationInternalCacheSetArgs = {
    key: GqRedisKey;
    value: Scalars["String"];
};
export declare type GqMutationInternalRunAdminFunctionArgs = {
    input: GqInternalRunAdminFunctionInput;
};
export declare type GqMutationInternalArchiveMemArgs = {
    input: GqInternalArchiveMemInput;
};
export declare type GqMutationInternalSendSearchAnalyticsArgs = {
    input: GqInternalSendSearchAnalyticsInput;
};
export declare type GqMutationInternalMigrateAccountToNewEmailArgs = {
    input: GqInternalMigrateAccountToNewEmailInput;
};
export declare type GqMutationUpdateAccountMemInboxDetailsArgs = {
    input: GqUpdateAccountMemInboxDetailsInput;
};
export declare type GqMutationInternalIndexAccountUsingFirestoreUserIdArgs = {
    input: GqInternalIndexAccountUsingFirestoreUserIdInput;
};
export declare type GqMutationInternalIndexGroupUsingFirestoreGroupIdArgs = {
    input: GqInternalIndexGroupUsingFirestoreGroupIdInput;
};
export declare type GqMutationUploadFileArgs = {
    input: GqUploadFileInput;
};
export declare type GqMutationInternalReprocessMemTemplateEntityUsingFirestoreTemplateIdArgs = {
    input: GqInternalReprocessMemTemplateEntityUsingFirestoreTemplateIdInput;
};
export declare type GqMutationTransitoryIndexMemEntityUsingFirestoreNoteIdArgs = {
    input: GqTransitoryIndexMemEntityUsingFirestoreNoteIdInput;
};
export declare type GqMutationInternalFindOrImportAccountFromFirestoreUserArgs = {
    input: GqInternalFindOrImportAccountFromFirestoreUserInput;
};
export declare type GqMutationInternalUpdateMemTrashStateArgs = {
    input: GqInternalUpdateMemTrashStateInput;
};
export declare type GqMutationTransitoryReprocessAccountEntityUsingFirestoreUserIdArgs = {
    input: GqTransitoryReprocessAccountEntityUsingFirestoreUserIdInput;
};
export declare type GqMutationInternalArchiveAccountArgs = {
    input: GqInternalArchiveAccountInput;
};
export declare type GqMutationCreateWorkspaceArgs = {
    input: GqCreateWorkspaceInput;
};
export declare type GqMutationDeleteAccountBatchImportMemsArgs = {
    input: GqDeleteAccountBatchImportMemsInput;
};
export declare type GqMutationInternalEnableFeatureToggleForAllAccountWithEmailDomainArgs = {
    input: GqInternalEnableFeatureToggleForAllAccountWithEmailDomainInput;
};
/** An object with a universal ID (globally-unique). */
export declare type GqNode = {
    /** The unique identifier of the entity. */
    id: Scalars["Uuid"];
};
export declare type GqPlatformFeature = {
    __typename?: "PlatformFeature";
    name: Scalars["String"];
    kind: GqPlatformFeatureKind;
    gate: GqPlatformFeatureGate;
};
/** Platform Feature Gate */
export declare type GqPlatformFeatureGate = {
    __typename?: "PlatformFeatureGate";
    enabled: Scalars["Boolean"];
    limit: Maybe<Scalars["Int"]>;
    gateMessage: Maybe<Scalars["String"]>;
    inboundUpgradeMessage: Maybe<Scalars["String"]>;
    outboundUpgradePaths: Array<GqPlatformPlanKind>;
};
/** Platform Features */
export declare enum GqPlatformFeatureKind {
    Tags = "TAGS",
    Templates = "TEMPLATES",
    ConnectedEmails = "CONNECTED_EMAILS",
    ConnectedCalendars = "CONNECTED_CALENDARS",
    Texts = "TEXTS",
    SmartSearch = "SMART_SEARCH",
    SimilarMems = "SIMILAR_MEMS",
    ApiKeys = "API_KEYS",
    Zapier = "ZAPIER",
    Groups = "GROUPS",
    GroupMembers = "GROUP_MEMBERS",
    FileStorage = "FILE_STORAGE",
    FileUploads = "FILE_UPLOADS"
}
/** Platform Plans */
export declare type GqPlatformPlan = {
    __typename?: "PlatformPlan";
    name: Scalars["String"];
    kind: GqPlatformPlanKind;
    /** Platform Features */
    apiKeysFeature: GqPlatformFeature;
    connectedCalendarsFeature: GqPlatformFeature;
    connectedEmailsFeature: GqPlatformFeature;
    fileStorageFeature: GqPlatformFeature;
    fileUploadsFeature: GqPlatformFeature;
    groupsFeature: GqPlatformFeature;
    groupMembersFeature: GqPlatformFeature;
    similarMemsFeature: GqPlatformFeature;
    smartSearchFeature: GqPlatformFeature;
    tagsFeature: GqPlatformFeature;
    templatesFeature: GqPlatformFeature;
    textsFeature: GqPlatformFeature;
    zapierFeature: GqPlatformFeature;
};
export declare type GqPlatformPlanCatalog = {
    __typename?: "PlatformPlanCatalog";
    memFree: GqPlatformPlan;
    memPro: GqPlatformPlan;
    memX: GqPlatformPlan;
    memTeams: GqPlatformPlan;
};
/** Platform Plans */
export declare enum GqPlatformPlanKind {
    MemFree = "MEM_FREE",
    MemPro = "MEM_PRO",
    MemX = "MEM_X",
    MemTeams = "MEM_TEAMS"
}
export declare type GqQuery = {
    __typename?: "Query";
    /** Get an Account API Key by id. */
    getAccountApiKey: GqAccountApiKey;
    /**
     * Search for account api keys.
     * This is deprecated...
     * Use `internalSearchAccountApiKeys` instead.
     * @deprecated Use `internalSearchAccountApiKeys` instead.
     */
    searchAccountApiKeys: GqAccountApiKeyCursorConnection;
    /**
     * Gets the currently authenticated account.
     * If there is not a currently authenticated account, this raises an error.
     */
    getCurrentAccount: GqAccount;
    /** Get an Account by id. */
    getAccount: GqAccount;
    /** Search for account api keys. */
    searchAccounts: GqAccountCursorConnection;
    /** Server health-check details. */
    healthCheckDetails: GqHealthCheckDetails;
    _empty: Maybe<Scalars["String"]>;
    /** Get a Mem by id. */
    getMem: GqMem;
    /** Search the knowledge graph associated with the account. */
    internalSearchKnowledgeGraph: GqKnowledgeGraphLimitOffsetConnection;
    /** Get a Mem by the associated firestore note id. */
    transitoryGetMemByFirestoreNoteId: GqMem;
    /** Search the knowledge graph associated with the account. */
    internalCacheGet: GqCacheGetResults;
    /** Search for any account api keys. */
    internalSearchAccountApiKeys: GqAccountApiKeyCursorConnection;
    /** Search for any accounts. */
    internalSearchAccounts: GqAccountLimitOffsetConnection;
    /** Get a workspace by id. */
    getWorkspace: GqWorkspace;
    /** Search for any accounts. */
    internalSearchWorkspaces: GqWorkspaceLimitOffsetConnection;
    /** Get an AccountBatchImport by id. */
    getAccountBatchImport: GqAccountBatchImport;
    /** Search the knowledge graph associated with the account. */
    internalTransitorySearchKnowledgeGraph: GqKnowledgeGraphLimitOffsetConnection;
    /** Fetch the different available plans. */
    platformPlanCatalog: GqPlatformPlanCatalog;
    /** Returns all available feature toggles that exist. */
    internalGetAllFeatureToggles: GqInternalGetAllFeatureTogglesPayload;
};
export declare type GqQueryGetAccountApiKeyArgs = {
    accountApiKeyId: Scalars["Uuid"];
};
export declare type GqQuerySearchAccountApiKeysArgs = {
    after: Maybe<Scalars["Cursor"]>;
    before: Maybe<Scalars["Cursor"]>;
    first: Maybe<Scalars["Int"]>;
    last: Maybe<Scalars["Int"]>;
    filterBy: Maybe<GqSearchAccountApiKeysFilters>;
};
export declare type GqQueryGetAccountArgs = {
    accountId: Scalars["Uuid"];
};
export declare type GqQuerySearchAccountsArgs = {
    after: Maybe<Scalars["Cursor"]>;
    before: Maybe<Scalars["Cursor"]>;
    first: Maybe<Scalars["Int"]>;
    last: Maybe<Scalars["Int"]>;
    filterBy: Maybe<GqSearchAccountsFilters>;
};
export declare type GqQueryGetMemArgs = {
    memId: Scalars["Uuid"];
};
export declare type GqQueryInternalSearchKnowledgeGraphArgs = {
    limit: Maybe<Scalars["Int"]>;
    offset: Maybe<Scalars["Int"]>;
    filterBy: Maybe<GqInternalSearchKnowledgeGraphFilters>;
};
export declare type GqQueryTransitoryGetMemByFirestoreNoteIdArgs = {
    firestoreNoteId: Scalars["String"];
};
export declare type GqQueryInternalCacheGetArgs = {
    queryString: GqRedisKey;
};
export declare type GqQueryInternalSearchAccountApiKeysArgs = {
    after: Maybe<Scalars["Cursor"]>;
    before: Maybe<Scalars["Cursor"]>;
    first: Maybe<Scalars["Int"]>;
    last: Maybe<Scalars["Int"]>;
    filterBy: Maybe<GqInternalSearchAccountApiKeysFilters>;
};
export declare type GqQueryInternalSearchAccountsArgs = {
    limit: Maybe<Scalars["Int"]>;
    offset: Maybe<Scalars["Int"]>;
    filterBy: Maybe<GqInternalSearchAccountsFilters>;
};
export declare type GqQueryGetWorkspaceArgs = {
    workspaceId: Scalars["Uuid"];
};
export declare type GqQueryInternalSearchWorkspacesArgs = {
    limit: Maybe<Scalars["Int"]>;
    offset: Maybe<Scalars["Int"]>;
    filterBy: Maybe<GqInternalSearchWorkspacesFilters>;
};
export declare type GqQueryGetAccountBatchImportArgs = {
    accountBatchImportId: Scalars["Uuid"];
};
export declare type GqQueryInternalTransitorySearchKnowledgeGraphArgs = {
    limit: Maybe<Scalars["Int"]>;
    offset: Maybe<Scalars["Int"]>;
    filterBy: Maybe<GqInternalTransitoryKnowledgeGraphFilters>;
};
export declare type GqRecordClientEventInput = {
    /** The kind of client event. */
    kind: GqClientEventKind;
    /** Details related to the event. */
    clientEventInfo: Maybe<Scalars["AnyJsonObject"]>;
    /** Details about the environment of the client. */
    clientInfo: Maybe<Scalars["AnyJsonObject"]>;
};
export declare type GqRecordClientEventPayload = {
    __typename?: "RecordClientEventPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqRecordMemInteractionLocationPolicyAccountPreference = {
    __typename?: "RecordMemInteractionLocationPolicyAccountPreference";
    /** Whether the preference is enabled. */
    enabled: Scalars["Boolean"];
};
/** A list of common redis keys. */
export declare enum GqRedisKey {
    NotificationGenerationProgress = "NOTIFICATION_GENERATION_PROGRESS",
    ReindexAllMemsInApiDbProgress = "REINDEX_ALL_MEMS_IN_API_DB_PROGRESS",
    Ping = "PING"
}
export declare type GqRevokeAccountApiKeyInput = {
    /** The identifier for the Account API Key. */
    accountApiKeyId: Scalars["Uuid"];
};
export declare type GqRevokeAccountApiKeyPayload = {
    __typename?: "RevokeAccountApiKeyPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqSaveToMemInput = {
    /** The identifier for the target Mem in case of update. If not provided, a new mem is created. */
    memId: Maybe<Scalars["Uuid"]>;
    /**
     * The contents which should be appended to the existing mem.
     * Must be in the markdown format.
     *
     * (Titles and tags are automatically parsed from the content.)
     */
    markdown: Maybe<Scalars["String"]>;
    /**
     * The contents which should be appended to the existing mem.
     * Must be in the rich-text-document format.
     */
    richTextDocument: Maybe<Scalars["RichTextDocument"]>;
};
export declare type GqSaveToMemPayload = {
    __typename?: "SaveToMemPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The Mem which was updated/created. */
    mem: GqMem;
};
/**
 * This is deprecated...
 * Use `internalSearchAccountApiKeys` instead.
 */
export declare type GqSearchAccountApiKeysFilters = {
    /** Include API Keys which have been revoked. */
    includeRevoked: Maybe<Scalars["Boolean"]>;
};
export declare type GqSearchAccountsFilters = {
    /** Include accounts which have been revoked. */
    includeSoftDeleted: Maybe<Scalars["Boolean"]>;
};
export declare type GqSearchQuery = {
    __typename?: "SearchQuery";
    /** The query for the search. */
    query: Scalars["String"];
};
export declare type GqSearchQueryAccountFavoriteItem = GqGenericAccountFavoriteItem & {
    __typename?: "SearchQueryAccountFavoriteItem";
    /** String describing the item. */
    label: Scalars["String"];
    /** The item value. */
    value: GqSearchQuery;
};
/** Details regarding the server's build/deployment/environment/... */
export declare type GqServerInfo = {
    __typename?: "ServerInfo";
    /** Time that the server was last built/deployed. */
    builtAt: Scalars["DateTime"];
    /** The name of the deployed service. */
    serviceName: Scalars["String"];
    /**
     * An identifier which uniquely represents this build.
     * (A new identifier is generated every time the app is built.)
     */
    buildIdentifier: Scalars["Uuid"];
    /**
     * An identifier which uniquely represents this server instance.
     * (A new identifier is generated every time the server boots.)
     */
    instanceIdentifier: Scalars["Uuid"];
    /**
     * An identifier which uniquely represents this API request.
     * (A new identifier is generated every time a request is made.)
     */
    requestIdentifier: Scalars["Uuid"];
};
/** We can add more types here in the future. */
export declare type GqSimilarItem = GqMemSimilarItem;
export declare type GqSimilarItemsKnowledgeNodePivot = GqGenericKnowledgeNodePivot & {
    __typename?: "SimilarItemsKnowledgeNodePivot";
    /** The primary label of the category - used for displaying search results. */
    primaryLabel: Scalars["String"];
    /** @deprecated - use   itemsWithScore: [ItemWithScore!]! instead */
    items: Array<GqSimilarItem>;
};
export declare type GqSoftDeleteMemInput = {
    /** The identifier for the target Mem. */
    memId: Scalars["Uuid"];
};
export declare type GqSoftDeleteMemPayload = {
    __typename?: "SoftDeleteMemPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqSubscription = {
    __typename?: "Subscription";
    _empty: Maybe<Scalars["String"]>;
};
export declare type GqSyncMemContentInput = {
    /** The identifier for the target Mem. */
    memId: Scalars["Uuid"];
    /** The version of the last time the content was synced. */
    lastSyncVersion: Scalars["Int"];
    /**
     * The contents which should replace the existing mem.
     * Must be in the markdown format.
     *
     * (Titles and tags are automatically parsed from the content.)
     */
    markdown: Maybe<Scalars["String"]>;
    /**
     * The contents which should replace the existing mem.
     * Must be in the rich-text-document format.
     */
    richTextDocument: Maybe<Scalars["RichTextDocument"]>;
    /**
     * An identifier for the client submitting the request.
     * Optional, but recommended.
     */
    clientId: Maybe<Scalars["Uuid"]>;
};
export declare type GqSyncMemContentPayload = {
    __typename?: "SyncMemContentPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The Mem which was updated. */
    mem: GqMem;
};
export declare type GqTopic = {
    __typename?: "Topic";
    /**
     * The label of the topic.
     * For #meetings, the label would be `meetings`.
     */
    label: Scalars["String"];
    /** The color of the topic. */
    color: Scalars["Color"];
};
export declare type GqTopicAccountFavoriteItem = GqGenericAccountFavoriteItem & {
    __typename?: "TopicAccountFavoriteItem";
    /** String describing the item. */
    label: Scalars["String"];
    /** The item value. */
    value: GqTopic;
};
export declare type GqTopicKnowledgeNodePivot = GqGenericKnowledgeNodePivot & {
    __typename?: "TopicKnowledgeNodePivot";
    /** The primary label of the category - used for displaying search results. */
    primaryLabel: Scalars["String"];
    /** Search for the pivot's knowledge nodes. */
    searchKnowledgeNodes: GqKnowledgeNodesLimitOffsetConnection;
};
export declare type GqTopicKnowledgeNodePivotSearchKnowledgeNodesArgs = {
    limit: Maybe<Scalars["Int"]>;
    offset: Maybe<Scalars["Int"]>;
};
/** A list of valid tracked event slugs. */
export declare enum GqTrackedEventSlug {
    ExampleEvent = "EXAMPLE_EVENT",
    PersonIndexed = "PERSON_INDEXED",
    AccountIndexed = "ACCOUNT_INDEXED",
    GroupIndexed = "GROUP_INDEXED",
    MemTemplateIndexed = "MEM_TEMPLATE_INDEXED",
    MemCreated = "MEM_CREATED",
    MemContentAppended = "MEM_CONTENT_APPENDED",
    MemContentSynced = "MEM_CONTENT_SYNCED",
    MemContentTransformed = "MEM_CONTENT_TRANSFORMED",
    MemIndexed = "MEM_INDEXED",
    MemArchived = "MEM_ARCHIVED",
    /** Generic */
    MemIosAppBooted = "MEM_IOS_APP_BOOTED",
    MemIosLoadPersistedAccountSuccess = "MEM_IOS_LOAD_PERSISTED_ACCOUNT_SUCCESS",
    MemIosLoadPersistedAccountFailureNotFound = "MEM_IOS_LOAD_PERSISTED_ACCOUNT_FAILURE_NOT_FOUND",
    MemIosAppOpened = "MEM_IOS_APP_OPENED",
    /** Login */
    MemIosLoginScreenViewed = "MEM_IOS_LOGIN_SCREEN_VIEWED",
    MemIosLoginScreenAccountLoginSuccess = "MEM_IOS_LOGIN_SCREEN_ACCOUNT_LOGIN_SUCCESS",
    MemIosLoginScreenAccountLoginFailureNotFound = "MEM_IOS_LOGIN_SCREEN_ACCOUNT_LOGIN_FAILURE_NOT_FOUND",
    MemIosLoginScreenAccountLoginFailureUnknown = "MEM_IOS_LOGIN_SCREEN_ACCOUNT_LOGIN_FAILURE_UNKNOWN",
    MemIosLoginScreenSignInWithGoogleClicked = "MEM_IOS_LOGIN_SCREEN_SIGN_IN_WITH_GOOGLE_CLICKED",
    MemIosLoginScreenLearnMoreClicked = "MEM_IOS_LOGIN_SCREEN_LEARN_MORE_CLICKED",
    MemIosLoginScreenAccountNotFoundMustSignUpClicked = "MEM_IOS_LOGIN_SCREEN_ACCOUNT_NOT_FOUND_MUST_SIGN_UP_CLICKED",
    /** Home */
    MemIosHomeScreenViewed = "MEM_IOS_HOME_SCREEN_VIEWED",
    MemIosHomeScreenLoadedResults = "MEM_IOS_HOME_SCREEN_LOADED_RESULTS",
    MemIosHomeScreenSawNoResults = "MEM_IOS_HOME_SCREEN_SAW_NO_RESULTS",
    MemIosHomeScreenLoadedMoreResults = "MEM_IOS_HOME_SCREEN_LOADED_MORE_RESULTS",
    MemIosHomeScreenRefreshedResults = "MEM_IOS_HOME_SCREEN_REFRESHED_RESULTS",
    MemIosHomeScreenSuggestionClicked = "MEM_IOS_HOME_SCREEN_SUGGESTION_CLICKED",
    /** Search */
    MemIosSearchScreenViewed = "MEM_IOS_SEARCH_SCREEN_VIEWED",
    MemIosSearchScreenSearchExecuted = "MEM_IOS_SEARCH_SCREEN_SEARCH_EXECUTED",
    MemIosSearchScreenSawNoResults = "MEM_IOS_SEARCH_SCREEN_SAW_NO_RESULTS",
    MemIosSearchScreenLoadedMoreResults = "MEM_IOS_SEARCH_SCREEN_LOADED_MORE_RESULTS",
    MemIosSearchScreenSuggestionClicked = "MEM_IOS_SEARCH_SCREEN_SUGGESTION_CLICKED",
    MemIosSearchScreenOpenedFromNavigationBar = "MEM_IOS_SEARCH_SCREEN_OPENED_FROM_NAVIGATION_BAR",
    MemIosSearchScreenOpenedFromHomeBar = "MEM_IOS_SEARCH_SCREEN_OPENED_FROM_HOME_BAR",
    /** Share Sheet */
    MemIosShareSheetViewed = "MEM_IOS_SHARE_SHEET_VIEWED",
    /** Slice Results (Home + Search Views) */
    MemIosSliceResultsItemClicked = "MEM_IOS_SLICE_RESULTS_ITEM_CLICKED",
    /** Details */
    MemIosDetailScreenViewed = "MEM_IOS_DETAIL_SCREEN_VIEWED",
    MemIosDetailScreenMemEdited = "MEM_IOS_DETAIL_SCREEN_MEM_EDITED",
    MemIosDetailScreenMemComposed = "MEM_IOS_DETAIL_SCREEN_MEM_COMPOSED",
    MemIosDetailScreenTopicClicked = "MEM_IOS_DETAIL_SCREEN_TOPIC_CLICKED",
    MemIosDetailScreenWebLinkClicked = "MEM_IOS_DETAIL_SCREEN_WEB_LINK_CLICKED",
    MemIosDetailScreenLinkedFirestoreNoteClicked = "MEM_IOS_DETAIL_SCREEN_LINKED_FIRESTORE_NOTE_CLICKED",
    MemIosDetailScreenMentionedFirestoreUserClicked = "MEM_IOS_DETAIL_SCREEN_MENTIONED_FIRESTORE_USER_CLICKED",
    MemIosDetailScreenMentionedFirestoreGroupClicked = "MEM_IOS_DETAIL_SCREEN_MENTIONED_FIRESTORE_GROUP_CLICKED",
    MemIosDetailScreenRelatedMemsViewed = "MEM_IOS_DETAIL_SCREEN_RELATED_MEMS_VIEWED",
    /** Editing */
    MemIosEditorCarouselCameraClicked = "MEM_IOS_EDITOR_CAROUSEL_CAMERA_CLICKED",
    MemIosEditorCarouselPhotoClicked = "MEM_IOS_EDITOR_CAROUSEL_PHOTO_CLICKED",
    MemIosEditorCarouselGalleryClicked = "MEM_IOS_EDITOR_CAROUSEL_GALLERY_CLICKED",
    MemIosEditorToolbarGalleryClicked = "MEM_IOS_EDITOR_TOOLBAR_GALLERY_CLICKED",
    MemIosEditorToolbarBulletedListClicked = "MEM_IOS_EDITOR_TOOLBAR_BULLETED_LIST_CLICKED",
    MemIosEditorToolbarChecklistClicked = "MEM_IOS_EDITOR_TOOLBAR_CHECKLIST_CLICKED",
    MemIosEditorToolbarAddTagClicked = "MEM_IOS_EDITOR_TOOLBAR_ADD_TAG_CLICKED",
    MemIosEditorToolbarFormatClicked = "MEM_IOS_EDITOR_TOOLBAR_FORMAT_CLICKED",
    MemIosEditorToolbarH1Clicked = "MEM_IOS_EDITOR_TOOLBAR_H1_CLICKED",
    MemIosEditorToolbarH2Clicked = "MEM_IOS_EDITOR_TOOLBAR_H2_CLICKED",
    MemIosEditorToolbarBoldClicked = "MEM_IOS_EDITOR_TOOLBAR_BOLD_CLICKED",
    MemIosEditorToolbarItalicClicked = "MEM_IOS_EDITOR_TOOLBAR_ITALIC_CLICKED",
    MemIosEditorToolbarUnderlineClicked = "MEM_IOS_EDITOR_TOOLBAR_UNDERLINE_CLICKED",
    MemIosEditorToolbarStrikethroughClicked = "MEM_IOS_EDITOR_TOOLBAR_STRIKETHROUGH_CLICKED",
    MemIosEditorToolbarCodeBlockClicked = "MEM_IOS_EDITOR_TOOLBAR_CODE_BLOCK_CLICKED",
    MemIosEditorToolbarQuoteBlockClicked = "MEM_IOS_EDITOR_TOOLBAR_QUOTE_BLOCK_CLICKED",
    MemIosEditorToolbarRemoveFormattingClicked = "MEM_IOS_EDITOR_TOOLBAR_REMOVE_FORMATTING_CLICKED",
    /** Side Navigation */
    MemIosSideNavigationViewed = "MEM_IOS_SIDE_NAVIGATION_VIEWED",
    /** Help And Support */
    MemIosSupportScreenViewed = "MEM_IOS_SUPPORT_SCREEN_VIEWED",
    MemIosSupportScreenProductUpdatesClicked = "MEM_IOS_SUPPORT_SCREEN_PRODUCT_UPDATES_CLICKED",
    MemIosSupportScreenFaqsClicked = "MEM_IOS_SUPPORT_SCREEN_FAQS_CLICKED",
    MemIosSupportScreenTutorialsClicked = "MEM_IOS_SUPPORT_SCREEN_TUTORIALS_CLICKED",
    MemIosSupportScreenBlogClicked = "MEM_IOS_SUPPORT_SCREEN_BLOG_CLICKED",
    MemIosSupportScreenContactUsClicked = "MEM_IOS_SUPPORT_SCREEN_CONTACT_US_CLICKED",
    /** Other Events */
    MemIosAccountLoggedOut = "MEM_IOS_ACCOUNT_LOGGED_OUT",
    /** Recommended */
    EntitiesRecommended = "ENTITIES_RECOMMENDED"
}
export declare type GqTransformMemContentInput = {
    /** The identifier for the target Mem. */
    memId: Scalars["Uuid"];
    /** The version of the last time the content was synced. */
    lastSyncVersion: Scalars["Int"];
    /**
     * The contents which should replace the existing mem.
     * Must be in the rich-text-delta format.
     */
    richTextDelta: Maybe<Scalars["RichTextDelta"]>;
    /**
     * An identifier for the client submitting the request.
     * Optional, but recommended.
     */
    clientId: Maybe<Scalars["Uuid"]>;
};
export declare type GqTransformMemContentPayload = {
    __typename?: "TransformMemContentPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The Mem which was updated. */
    mem: GqMem;
};
export declare type GqTransitoryIndexMemEntityUsingFirestoreNoteIdInput = {
    /** The identifier for the firestore note id. */
    firestoreNoteId: Scalars["String"];
};
export declare type GqTransitoryIndexMemEntityUsingFirestoreNoteIdPayload = {
    __typename?: "TransitoryIndexMemEntityUsingFirestoreNoteIdPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqTransitoryReprocessAccountEntityUsingFirestoreUserIdInput = {
    /** The identifier for the firestore user id. */
    firestoreUserId: Scalars["String"];
};
export declare type GqTransitoryReprocessAccountEntityUsingFirestoreUserIdPayload = {
    __typename?: "TransitoryReprocessAccountEntityUsingFirestoreUserIdPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqTransitoryReprocessMemEntityUsingFirestoreNoteIdInput = {
    /** The identifier for the firestore note id. */
    firestoreNoteId: Scalars["String"];
};
export declare type GqTransitoryReprocessMemEntityUsingFirestoreNoteIdPayload = {
    __typename?: "TransitoryReprocessMemEntityUsingFirestoreNoteIdPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type GqUpdateAccountApiKeyDetailsInput = {
    /** The identifier for the Account API Key. */
    accountApiKeyId: Scalars["Uuid"];
    /** Some details about the API key (what it is used for, where the token is stored, ...). */
    details: Maybe<Scalars["String"]>;
};
export declare type GqUpdateAccountApiKeyDetailsPayload = {
    __typename?: "UpdateAccountApiKeyDetailsPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The API key that was updated. */
    accountApiKey: GqAccountApiKey;
};
export declare type GqUpdateAccountDetailsInput = {
    /** The identifier for the account which should be updated. */
    accountId: Scalars["Uuid"];
    /** An updated profile image url for the account. Optional. */
    profileImageUrl: Maybe<Scalars["String"]>;
};
export declare type GqUpdateAccountDetailsPayload = {
    __typename?: "UpdateAccountDetailsPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The updated account. */
    account: GqAccount;
};
export declare type GqUpdateAccountMemInboxDetailsInput = {
    /** The identifier for the target mem. */
    memId: Scalars["Uuid"];
    /** The identifier for the target account. */
    accountId: Scalars["Uuid"];
    /** Boolean that marks whether the inbox item is unread. */
    isUnread: Maybe<Scalars["Boolean"]>;
    /** State of the mem in the account inbox (archived, snoozed, etc.) */
    inboxState: Maybe<GqAccountMemInboxStateInput>;
    /** Subscription level between the account and mem (muted, etc.) */
    subscriptionLevel: Maybe<GqAccountMemInboxSubscriptionLevelInput>;
};
export declare type GqUpdateAccountMemInboxDetailsPayload = {
    __typename?: "UpdateAccountMemInboxDetailsPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The updated account. */
    account: GqAccount;
};
export declare type GqUpdateAccountPreferenceRecordMemInteractionLocationPolicyInput = {
    /** The new value for the location policy. */
    enabled: Scalars["Boolean"];
};
export declare type GqUpdateAccountPreferencesInput = {
    /** The identifier for the account which should be updated. */
    accountId: Scalars["Uuid"];
    /** Updates for the `recordMemInteractionLocationPolicy` preference. Optional. */
    recordMemInteractionLocationPolicy: Maybe<GqUpdateAccountPreferenceRecordMemInteractionLocationPolicyInput>;
};
export declare type GqUpdateAccountPreferencesPayload = {
    __typename?: "UpdateAccountPreferencesPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The updated account. */
    account: GqAccount;
};
export declare type GqUploadFileInput = {
    /** The file. */
    file: Scalars["Upload"];
};
export declare type GqUploadFilePayload = {
    __typename?: "UploadFilePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The uploaded file. */
    uploadedFile: GqUploadedFile;
};
export declare type GqUploadedFile = {
    __typename?: "UploadedFile";
    /** The url of the uploaded file. */
    fileUrl: Scalars["String"];
};
/** Details about the showcase app notification. */
export declare type GqVersionLaunchShowcaseAppNotificationDetails = {
    /** The title of the app notification, located at the top of the notification. */
    title: Scalars["String"];
    /** The secondary label of the app notification, located below the title. */
    text: Scalars["String"];
    /** The noteId of the showcase note for the version launch. */
    showcaseNoteId: Scalars["String"];
};
/** A Workspace. */
export declare type GqWorkspace = GqNode & {
    __typename?: "Workspace";
    /** The unique identifier of the entity. */
    id: Scalars["Uuid"];
    /** The name of the workspace. */
    name: Scalars["String"];
    /** Associated accounts. */
    workspaceAccounts: Array<GqWorkspaceAccount>;
};
/** A WorkspaceAccount. */
export declare type GqWorkspaceAccount = GqNode & {
    __typename?: "WorkspaceAccount";
    /** The unique identifier of the entity. */
    id: Scalars["Uuid"];
    /** The associated workspace. */
    workspace: GqWorkspace;
    /** The associated account. */
    account: GqAccount;
    /** The role of the account within the workspace. */
    role: GqAccountWorkspaceRoleKind;
};
export declare type GqWorkspaceLimitOffsetConnection = {
    __typename?: "WorkspaceLimitOffsetConnection";
    /** A list of nodes. */
    nodes: Array<GqWorkspace>;
    /** Information to aid in pagination. */
    pageInfo: GqLimitOffsetPageInfo;
    /** Identifies the total count of items in the connection. */
    totalCount: Scalars["Int"];
};
export declare type GqInternalArchiveAccountInput = {
    /** The id of the target firestore-account. */
    firestoreUserId: Scalars["String"];
};
export declare type GqInternalArchiveAccountPayload = {
    __typename?: "internalArchiveAccountPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The id of the account which was archived. */
    accountId: Scalars["Uuid"];
};
export declare type GqInternalArchiveMemInput = {
    /** The id of the target firestore-note. */
    firestoreNoteId: Scalars["String"];
};
export declare type GqInternalArchiveMemPayload = {
    __typename?: "internalArchiveMemPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The id of the mem which was archived. */
    memId: Scalars["Uuid"];
};
export declare type GqInternalUpdateMemTrashStateInput = {
    /** The id of the target firestore-note. */
    firestoreNoteId: Scalars["String"];
    /** The array of userId's that have the target firestore-note in their trash. */
    isInTrashForUsers: Array<Scalars["String"]>;
};
export declare type GqInternalUpdateMemTrashStatePayload = {
    __typename?: "internalUpdateMemTrashStatePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The id of the mem that was updated. */
    memId: Scalars["Uuid"];
};
export declare type GqRecommendedSavedToMemItem = GqMem;
export declare type GqBatchCreateMemsMutationVariables = Exact<{
    inputs: Array<GqCreateMemInput> | GqCreateMemInput;
}>;
export declare type GqBatchCreateMemsMutation = {
    __typename?: "Mutation";
} & {
    batchCreateMems: Array<{
        __typename?: "CreateMemPayload";
    } & Pick<GqCreateMemPayload, "success"> & {
        mem: {
            __typename?: "Mem";
        } & Pick<GqMem, "id">;
    }>;
};
export declare type GqCreateMemMutationVariables = Exact<{
    input: GqCreateMemInput;
}>;
export declare type GqCreateMemMutation = {
    __typename?: "Mutation";
} & {
    createMem: {
        __typename?: "CreateMemPayload";
    } & Pick<GqCreateMemPayload, "success"> & {
        mem: {
            __typename?: "Mem";
        } & Pick<GqMem, "id">;
    };
};
export declare type GqHealthCheckQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type GqHealthCheckQuery = {
    __typename?: "Query";
} & {
    healthCheckDetails: {
        __typename?: "HealthCheckDetails";
    } & Pick<GqHealthCheckDetails, "apiStatus">;
};
export declare const BatchCreateMemsDocument: DocumentNode<GqBatchCreateMemsMutation, Exact<{
    inputs: Array<GqCreateMemInput> | GqCreateMemInput;
}>>;
export declare const CreateMemDocument: DocumentNode<GqCreateMemMutation, Exact<{
    input: GqCreateMemInput;
}>>;
export declare const HealthCheckDocument: DocumentNode<GqHealthCheckQuery, Exact<{
    [key: string]: never;
}>>;
//# sourceMappingURL=types.d.ts.map